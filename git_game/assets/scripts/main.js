(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/parse-uri/index.js
  var require_parse_uri = __commonJS((exports, module) => {
    "use strict";
    function parseURI(str, opts) {
      if (!str)
        return void 0;
      opts = opts || {};
      var o2 = {
        key: [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      var m2 = o2.parser[opts.strictMode ? "strict" : "loose"].exec(str);
      var uri = {};
      var i2 = 14;
      while (i2--)
        uri[o2.key[i2]] = m2[i2] || "";
      uri[o2.q.name] = {};
      uri[o2.key[12]].replace(o2.q.parser, function($0, $1, $2) {
        if ($1)
          uri[o2.q.name][$1] = $2;
      });
      return uri;
    }
    module.exports = parseURI;
  });

  // node_modules/mini-signals/lib/mini-signals.js
  var require_mini_signals = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var MiniSignalBinding = function() {
      function MiniSignalBinding2(fn, once, thisArg) {
        if (once === void 0)
          once = false;
        _classCallCheck(this, MiniSignalBinding2);
        this._fn = fn;
        this._once = once;
        this._thisArg = thisArg;
        this._next = this._prev = this._owner = null;
      }
      _createClass(MiniSignalBinding2, [{
        key: "detach",
        value: function detach() {
          if (this._owner === null)
            return false;
          this._owner.detach(this);
          return true;
        }
      }]);
      return MiniSignalBinding2;
    }();
    function _addMiniSignalBinding(self2, node) {
      if (!self2._head) {
        self2._head = node;
        self2._tail = node;
      } else {
        self2._tail._next = node;
        node._prev = self2._tail;
        self2._tail = node;
      }
      node._owner = self2;
      return node;
    }
    var MiniSignal = function() {
      function MiniSignal2() {
        _classCallCheck(this, MiniSignal2);
        this._head = this._tail = void 0;
      }
      _createClass(MiniSignal2, [{
        key: "handlers",
        value: function handlers() {
          var exists = arguments.length <= 0 || arguments[0] === void 0 ? false : arguments[0];
          var node = this._head;
          if (exists)
            return !!node;
          var ee = [];
          while (node) {
            ee.push(node);
            node = node._next;
          }
          return ee;
        }
      }, {
        key: "has",
        value: function has(node) {
          if (!(node instanceof MiniSignalBinding)) {
            throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
          }
          return node._owner === this;
        }
      }, {
        key: "dispatch",
        value: function dispatch() {
          var node = this._head;
          if (!node)
            return false;
          while (node) {
            if (node._once)
              this.detach(node);
            node._fn.apply(node._thisArg, arguments);
            node = node._next;
          }
          return true;
        }
      }, {
        key: "add",
        value: function add(fn) {
          var thisArg = arguments.length <= 1 || arguments[1] === void 0 ? null : arguments[1];
          if (typeof fn !== "function") {
            throw new Error("MiniSignal#add(): First arg must be a Function.");
          }
          return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
        }
      }, {
        key: "once",
        value: function once(fn) {
          var thisArg = arguments.length <= 1 || arguments[1] === void 0 ? null : arguments[1];
          if (typeof fn !== "function") {
            throw new Error("MiniSignal#once(): First arg must be a Function.");
          }
          return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
        }
      }, {
        key: "detach",
        value: function detach(node) {
          if (!(node instanceof MiniSignalBinding)) {
            throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
          }
          if (node._owner !== this)
            return this;
          if (node._prev)
            node._prev._next = node._next;
          if (node._next)
            node._next._prev = node._prev;
          if (node === this._head) {
            this._head = node._next;
            if (node._next === null) {
              this._tail = null;
            }
          } else if (node === this._tail) {
            this._tail = node._prev;
            this._tail._next = null;
          }
          node._owner = null;
          return this;
        }
      }, {
        key: "detachAll",
        value: function detachAll() {
          var node = this._head;
          if (!node)
            return this;
          this._head = this._tail = null;
          while (node) {
            node._owner = null;
            node = node._next;
          }
          return this;
        }
      }]);
      return MiniSignal2;
    }();
    MiniSignal.MiniSignalBinding = MiniSignalBinding;
    exports["default"] = MiniSignal;
    module.exports = exports["default"];
  });

  // node_modules/resource-loader/dist/resource-loader.cjs.js
  var require_resource_loader_cjs = __commonJS((exports) => {
    /*!
     * resource-loader - v3.0.1
     * https://github.com/pixijs/pixi-sound
     * Compiled Tue, 02 Jul 2019 14:06:18 UTC
     *
     * resource-loader is licensed under the MIT license.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var parseUri = _interopDefault(require_parse_uri());
    var Signal = _interopDefault(require_mini_signals());
    function _noop() {
    }
    function eachSeries(array, iterator, callback, deferNext) {
      var i2 = 0;
      var len = array.length;
      (function next(err) {
        if (err || i2 === len) {
          if (callback) {
            callback(err);
          }
          return;
        }
        if (deferNext) {
          setTimeout(function() {
            iterator(array[i2++], next);
          }, 1);
        } else {
          iterator(array[i2++], next);
        }
      })();
    }
    function onlyOnce(fn) {
      return function onceWrapper() {
        if (fn === null) {
          throw new Error("Callback was already called.");
        }
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    function queue(worker, concurrency) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      var workers = 0;
      var q = {
        _tasks: [],
        concurrency,
        saturated: _noop,
        unsaturated: _noop,
        buffer: concurrency / 4,
        empty: _noop,
        drain: _noop,
        error: _noop,
        started: false,
        paused: false,
        push: function push(data, callback) {
          _insert(data, false, callback);
        },
        kill: function kill() {
          workers = 0;
          q.drain = _noop;
          q.started = false;
          q._tasks = [];
        },
        unshift: function unshift(data, callback) {
          _insert(data, true, callback);
        },
        process: function process2() {
          while (!q.paused && workers < q.concurrency && q._tasks.length) {
            var task = q._tasks.shift();
            if (q._tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            if (workers === q.concurrency) {
              q.saturated();
            }
            worker(task.data, onlyOnce(_next(task)));
          }
        },
        length: function length() {
          return q._tasks.length;
        },
        running: function running() {
          return workers;
        },
        idle: function idle() {
          return q._tasks.length + workers === 0;
        },
        pause: function pause() {
          if (q.paused === true) {
            return;
          }
          q.paused = true;
        },
        resume: function resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          for (var w2 = 1; w2 <= q.concurrency; w2++) {
            q.process();
          }
        }
      };
      function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        if (data == null && q.idle()) {
          setTimeout(function() {
            return q.drain();
          }, 1);
          return;
        }
        var item = {
          data,
          callback: typeof callback === "function" ? callback : _noop
        };
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        setTimeout(function() {
          return q.process();
        }, 1);
      }
      function _next(task) {
        return function next() {
          workers -= 1;
          task.callback.apply(task, arguments);
          if (arguments[0] != null) {
            q.error(arguments[0], task.data);
          }
          if (workers <= q.concurrency - q.buffer) {
            q.unsaturated();
          }
          if (q.idle()) {
            q.drain();
          }
          q.process();
        };
      }
      return q;
    }
    var async = {
      eachSeries,
      queue
    };
    var cache2 = {};
    function caching(resource, next) {
      var _this = this;
      if (cache2[resource.url]) {
        resource.data = cache2[resource.url];
        resource.complete();
      } else {
        resource.onComplete.once(function() {
          return cache2[_this.url] = _this.data;
        });
      }
      next();
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var useXdr = !!(window.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
    var tempAnchor = null;
    var STATUS_NONE = 0;
    var STATUS_OK = 200;
    var STATUS_EMPTY = 204;
    var STATUS_IE_BUG_EMPTY = 1223;
    var STATUS_TYPE_OK = 2;
    function _noop$1() {
    }
    var Resource = /* @__PURE__ */ function() {
      Resource2.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
        setExtMap(Resource2._loadTypeMap, extname, loadType);
      };
      Resource2.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
        setExtMap(Resource2._xhrTypeMap, extname, xhrType);
      };
      function Resource2(name, url, options) {
        if (typeof name !== "string" || typeof url !== "string") {
          throw new Error("Both name and url are required for constructing a resource.");
        }
        options = options || {};
        this._flags = 0;
        this._setFlag(Resource2.STATUS_FLAGS.DATA_URL, url.indexOf("data:") === 0);
        this.name = name;
        this.url = url;
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
        this.timeout = options.timeout || 0;
        this.loadType = options.loadType || this._determineLoadType();
        this.xhrType = options.xhrType;
        this.metadata = options.metadata || {};
        this.error = null;
        this.xhr = null;
        this.children = [];
        this.type = Resource2.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._dequeue = _noop$1;
        this._onLoadBinding = null;
        this._elementTimer = 0;
        this._boundComplete = this.complete.bind(this);
        this._boundOnError = this._onError.bind(this);
        this._boundOnProgress = this._onProgress.bind(this);
        this._boundOnTimeout = this._onTimeout.bind(this);
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
        this.onStart = new Signal();
        this.onProgress = new Signal();
        this.onComplete = new Signal();
        this.onAfterMiddleware = new Signal();
      }
      var _proto = Resource2.prototype;
      _proto.complete = function complete() {
        this._clearEvents();
        this._finish();
      };
      _proto.abort = function abort(message) {
        if (this.error) {
          return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
          this.xhr.abort();
        } else if (this.xdr) {
          this.xdr.abort();
        } else if (this.data) {
          if (this.data.src) {
            this.data.src = Resource2.EMPTY_GIF;
          } else {
            while (this.data.firstChild) {
              this.data.removeChild(this.data.firstChild);
            }
          }
        }
        this._finish();
      };
      _proto.load = function load(cb) {
        var _this = this;
        if (this.isLoading) {
          return;
        }
        if (this.isComplete) {
          if (cb) {
            setTimeout(function() {
              return cb(_this);
            }, 1);
          }
          return;
        } else if (cb) {
          this.onComplete.once(cb);
        }
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, true);
        this.onStart.dispatch(this);
        if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
          this.crossOrigin = this._determineCrossOrigin(this.url);
        }
        switch (this.loadType) {
          case Resource2.LOAD_TYPE.IMAGE:
            this.type = Resource2.TYPE.IMAGE;
            this._loadElement("image");
            break;
          case Resource2.LOAD_TYPE.AUDIO:
            this.type = Resource2.TYPE.AUDIO;
            this._loadSourceElement("audio");
            break;
          case Resource2.LOAD_TYPE.VIDEO:
            this.type = Resource2.TYPE.VIDEO;
            this._loadSourceElement("video");
            break;
          case Resource2.LOAD_TYPE.XHR:
          default:
            if (useXdr && this.crossOrigin) {
              this._loadXdr();
            } else {
              this._loadXhr();
            }
            break;
        }
      };
      _proto._hasFlag = function _hasFlag(flag) {
        return (this._flags & flag) !== 0;
      };
      _proto._setFlag = function _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
      };
      _proto._clearEvents = function _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this.data && this.data.removeEventListener) {
          this.data.removeEventListener("error", this._boundOnError, false);
          this.data.removeEventListener("load", this._boundComplete, false);
          this.data.removeEventListener("progress", this._boundOnProgress, false);
          this.data.removeEventListener("canplaythrough", this._boundComplete, false);
        }
        if (this.xhr) {
          if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener("error", this._boundXhrOnError, false);
            this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
            this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
            this.xhr.removeEventListener("progress", this._boundOnProgress, false);
            this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
          } else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
          }
        }
      };
      _proto._finish = function _finish() {
        if (this.isComplete) {
          throw new Error("Complete called again for an already completed resource.");
        }
        this._setFlag(Resource2.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, false);
        this.onComplete.dispatch(this);
      };
      _proto._loadElement = function _loadElement(type2) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type2 === "image" && typeof window.Image !== "undefined") {
          this.data = new Image();
        } else {
          this.data = document.createElement(type2);
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          this.data.src = this.url;
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadSourceElement = function _loadSourceElement(type2) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type2 === "audio" && typeof window.Audio !== "undefined") {
          this.data = new Audio();
        } else {
          this.data = document.createElement(type2);
        }
        if (this.data === null) {
          this.abort("Unsupported element: " + type2);
          return;
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          if (navigator.isCocoonJS) {
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          } else if (Array.isArray(this.url)) {
            var mimeTypes = this.metadata.mimeType;
            for (var i2 = 0; i2 < this.url.length; ++i2) {
              this.data.appendChild(this._createSource(type2, this.url[i2], Array.isArray(mimeTypes) ? mimeTypes[i2] : mimeTypes));
            }
          } else {
            var _mimeTypes = this.metadata.mimeType;
            this.data.appendChild(this._createSource(type2, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
          }
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        this.data.addEventListener("canplaythrough", this._boundComplete, false);
        this.data.load();
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadXhr = function _loadXhr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xhr = this.xhr = new XMLHttpRequest();
        xhr.open("GET", this.url, true);
        xhr.timeout = this.timeout;
        if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          xhr.responseType = Resource2.XHR_RESPONSE_TYPE.TEXT;
        } else {
          xhr.responseType = this.xhrType;
        }
        xhr.addEventListener("error", this._boundXhrOnError, false);
        xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
        xhr.addEventListener("abort", this._boundXhrOnAbort, false);
        xhr.addEventListener("progress", this._boundOnProgress, false);
        xhr.addEventListener("load", this._boundXhrOnLoad, false);
        xhr.send();
      };
      _proto._loadXdr = function _loadXdr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xdr = this.xhr = new XDomainRequest();
        xdr.timeout = this.timeout || 5e3;
        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXhrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;
        xdr.open("GET", this.url, true);
        setTimeout(function() {
          return xdr.send();
        }, 1);
      };
      _proto._createSource = function _createSource(type2, url, mime) {
        if (!mime) {
          mime = type2 + "/" + this._getExtension(url);
        }
        var source = document.createElement("source");
        source.src = url;
        source.type = mime;
        return source;
      };
      _proto._onError = function _onError(event) {
        this.abort("Failed to load element using: " + event.target.nodeName);
      };
      _proto._onProgress = function _onProgress(event) {
        if (event && event.lengthComputable) {
          this.onProgress.dispatch(this, event.loaded / event.total);
        }
      };
      _proto._onTimeout = function _onTimeout() {
        this.abort("Load timed out.");
      };
      _proto._xhrOnError = function _xhrOnError() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
      };
      _proto._xhrOnTimeout = function _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request timed out.");
      };
      _proto._xhrOnAbort = function _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request was aborted by the user.");
      };
      _proto._xhrOnLoad = function _xhrOnLoad() {
        var xhr = this.xhr;
        var text = "";
        var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
        if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
          text = xhr.responseText;
        }
        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource2.XHR_RESPONSE_TYPE.BUFFER)) {
          status = STATUS_OK;
        } else if (status === STATUS_IE_BUG_EMPTY) {
          status = STATUS_EMPTY;
        }
        var statusType = status / 100 | 0;
        if (statusType === STATUS_TYPE_OK) {
          if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.TEXT) {
            this.data = text;
            this.type = Resource2.TYPE.TEXT;
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON) {
            try {
              this.data = JSON.parse(text);
              this.type = Resource2.TYPE.JSON;
            } catch (e2) {
              this.abort("Error trying to parse loaded json: " + e2);
              return;
            }
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
              if (window.DOMParser) {
                var domparser = new DOMParser();
                this.data = domparser.parseFromString(text, "text/xml");
              } else {
                var div = document.createElement("div");
                div.innerHTML = text;
                this.data = div;
              }
              this.type = Resource2.TYPE.XML;
            } catch (e2) {
              this.abort("Error trying to parse loaded xml: " + e2);
              return;
            }
          } else {
            this.data = xhr.response || text;
          }
        } else {
          this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
          return;
        }
        this.complete();
      };
      _proto._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
        if (url.indexOf("data:") === 0) {
          return "";
        }
        if (window.origin !== window.location.origin) {
          return "anonymous";
        }
        loc = loc || window.location;
        if (!tempAnchor) {
          tempAnchor = document.createElement("a");
        }
        tempAnchor.href = url;
        url = parseUri(tempAnchor.href, {
          strictMode: true
        });
        var samePort = !url.port && loc.port === "" || url.port === loc.port;
        var protocol = url.protocol ? url.protocol + ":" : "";
        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
          return "anonymous";
        }
        return "";
      };
      _proto._determineXhrType = function _determineXhrType() {
        return Resource2._xhrTypeMap[this.extension] || Resource2.XHR_RESPONSE_TYPE.TEXT;
      };
      _proto._determineLoadType = function _determineLoadType() {
        return Resource2._loadTypeMap[this.extension] || Resource2.LOAD_TYPE.XHR;
      };
      _proto._getExtension = function _getExtension() {
        var url = this.url;
        var ext = "";
        if (this.isDataUrl) {
          var slashIndex = url.indexOf("/");
          ext = url.substring(slashIndex + 1, url.indexOf(";", slashIndex));
        } else {
          var queryStart = url.indexOf("?");
          var hashStart = url.indexOf("#");
          var index2 = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
          url = url.substring(0, index2);
          ext = url.substring(url.lastIndexOf(".") + 1);
        }
        return ext.toLowerCase();
      };
      _proto._getMimeFromXhrType = function _getMimeFromXhrType(type2) {
        switch (type2) {
          case Resource2.XHR_RESPONSE_TYPE.BUFFER:
            return "application/octet-binary";
          case Resource2.XHR_RESPONSE_TYPE.BLOB:
            return "application/blob";
          case Resource2.XHR_RESPONSE_TYPE.DOCUMENT:
            return "application/xml";
          case Resource2.XHR_RESPONSE_TYPE.JSON:
            return "application/json";
          case Resource2.XHR_RESPONSE_TYPE.DEFAULT:
          case Resource2.XHR_RESPONSE_TYPE.TEXT:
          default:
            return "text/plain";
        }
      };
      _createClass(Resource2, [{
        key: "isDataUrl",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.DATA_URL);
        }
      }, {
        key: "isComplete",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.COMPLETE);
        }
      }, {
        key: "isLoading",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.LOADING);
        }
      }]);
      return Resource2;
    }();
    Resource.STATUS_FLAGS = {
      NONE: 0,
      DATA_URL: 1 << 0,
      COMPLETE: 1 << 1,
      LOADING: 1 << 2
    };
    Resource.TYPE = {
      UNKNOWN: 0,
      JSON: 1,
      XML: 2,
      IMAGE: 3,
      AUDIO: 4,
      VIDEO: 5,
      TEXT: 6
    };
    Resource.LOAD_TYPE = {
      XHR: 1,
      IMAGE: 2,
      AUDIO: 3,
      VIDEO: 4
    };
    Resource.XHR_RESPONSE_TYPE = {
      DEFAULT: "text",
      BUFFER: "arraybuffer",
      BLOB: "blob",
      DOCUMENT: "document",
      JSON: "json",
      TEXT: "text"
    };
    Resource._loadTypeMap = {
      gif: Resource.LOAD_TYPE.IMAGE,
      png: Resource.LOAD_TYPE.IMAGE,
      bmp: Resource.LOAD_TYPE.IMAGE,
      jpg: Resource.LOAD_TYPE.IMAGE,
      jpeg: Resource.LOAD_TYPE.IMAGE,
      tif: Resource.LOAD_TYPE.IMAGE,
      tiff: Resource.LOAD_TYPE.IMAGE,
      webp: Resource.LOAD_TYPE.IMAGE,
      tga: Resource.LOAD_TYPE.IMAGE,
      svg: Resource.LOAD_TYPE.IMAGE,
      "svg+xml": Resource.LOAD_TYPE.IMAGE,
      mp3: Resource.LOAD_TYPE.AUDIO,
      ogg: Resource.LOAD_TYPE.AUDIO,
      wav: Resource.LOAD_TYPE.AUDIO,
      mp4: Resource.LOAD_TYPE.VIDEO,
      webm: Resource.LOAD_TYPE.VIDEO
    };
    Resource._xhrTypeMap = {
      xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      gif: Resource.XHR_RESPONSE_TYPE.BLOB,
      png: Resource.XHR_RESPONSE_TYPE.BLOB,
      bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
      tif: Resource.XHR_RESPONSE_TYPE.BLOB,
      tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
      webp: Resource.XHR_RESPONSE_TYPE.BLOB,
      tga: Resource.XHR_RESPONSE_TYPE.BLOB,
      json: Resource.XHR_RESPONSE_TYPE.JSON,
      text: Resource.XHR_RESPONSE_TYPE.TEXT,
      txt: Resource.XHR_RESPONSE_TYPE.TEXT,
      ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
      otf: Resource.XHR_RESPONSE_TYPE.BUFFER
    };
    Resource.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
    function setExtMap(map, extname, val) {
      if (extname && extname.indexOf(".") === 0) {
        extname = extname.substring(1);
      }
      if (!extname) {
        return;
      }
      map[extname] = val;
    }
    function reqType(xhr) {
      return xhr.toString().replace("object ", "");
    }
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function encodeBinary(input) {
      var output = "";
      var inx = 0;
      while (inx < input.length) {
        var bytebuffer = [0, 0, 0];
        var encodedCharIndexes = [0, 0, 0, 0];
        for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
          if (inx < input.length) {
            bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
          } else {
            bytebuffer[jnx] = 0;
          }
        }
        encodedCharIndexes[0] = bytebuffer[0] >> 2;
        encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
        encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
        encodedCharIndexes[3] = bytebuffer[2] & 63;
        var paddingBytes = inx - (input.length - 1);
        switch (paddingBytes) {
          case 2:
            encodedCharIndexes[3] = 64;
            encodedCharIndexes[2] = 64;
            break;
          case 1:
            encodedCharIndexes[3] = 64;
            break;
          default:
            break;
        }
        for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
          output += _keyStr.charAt(encodedCharIndexes[_jnx]);
        }
      }
      return output;
    }
    var Url = window.URL || window.webkitURL;
    function parsing(resource, next) {
      if (!resource.data) {
        next();
        return;
      }
      if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
        if (!window.Blob || typeof resource.data === "string") {
          var type2 = resource.xhr.getResponseHeader("content-type");
          if (type2 && type2.indexOf("image") === 0) {
            resource.data = new Image();
            resource.data.src = "data:" + type2 + ";base64," + encodeBinary(resource.xhr.responseText);
            resource.type = Resource.TYPE.IMAGE;
            resource.data.onload = function() {
              resource.data.onload = null;
              next();
            };
            return;
          }
        } else if (resource.data.type.indexOf("image") === 0) {
          var src = Url.createObjectURL(resource.data);
          resource.blob = resource.data;
          resource.data = new Image();
          resource.data.src = src;
          resource.type = Resource.TYPE.IMAGE;
          resource.data.onload = function() {
            Url.revokeObjectURL(src);
            resource.data.onload = null;
            next();
          };
          return;
        }
      }
      next();
    }
    var index = {
      caching,
      parsing
    };
    var MAX_PROGRESS = 100;
    var rgxExtractUrlHash = /(#[\w-]+)?$/;
    var Loader = /* @__PURE__ */ function() {
      function Loader2(baseUrl, concurrency) {
        var _this = this;
        if (baseUrl === void 0) {
          baseUrl = "";
        }
        if (concurrency === void 0) {
          concurrency = 10;
        }
        this.baseUrl = baseUrl;
        this.progress = 0;
        this.loading = false;
        this.defaultQueryString = "";
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._resourcesParsing = [];
        this._boundLoadResource = function(r2, d2) {
          return _this._loadResource(r2, d2);
        };
        this._queue = queue(this._boundLoadResource, concurrency);
        this._queue.pause();
        this.resources = {};
        this.onProgress = new Signal();
        this.onError = new Signal();
        this.onLoad = new Signal();
        this.onStart = new Signal();
        this.onComplete = new Signal();
        for (var i2 = 0; i2 < Loader2._defaultBeforeMiddleware.length; ++i2) {
          this.pre(Loader2._defaultBeforeMiddleware[i2]);
        }
        for (var _i = 0; _i < Loader2._defaultAfterMiddleware.length; ++_i) {
          this.use(Loader2._defaultAfterMiddleware[_i]);
        }
      }
      var _proto = Loader2.prototype;
      _proto.add = function add(name, url, options, cb) {
        if (Array.isArray(name)) {
          for (var i2 = 0; i2 < name.length; ++i2) {
            this.add(name[i2]);
          }
          return this;
        }
        if (typeof name === "object") {
          cb = url || name.callback || name.onComplete;
          options = name;
          url = name.url;
          name = name.name || name.key || name.url;
        }
        if (typeof url !== "string") {
          cb = options;
          options = url;
          url = name;
        }
        if (typeof url !== "string") {
          throw new Error("No url passed to add resource to loader.");
        }
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        if (this.loading && (!options || !options.parentResource)) {
          throw new Error("Cannot add resources while the loader is running.");
        }
        if (this.resources[name]) {
          throw new Error('Resource named "' + name + '" already exists.');
        }
        url = this._prepareUrl(url);
        this.resources[name] = new Resource(name, url, options);
        if (typeof cb === "function") {
          this.resources[name].onAfterMiddleware.once(cb);
        }
        if (this.loading) {
          var parent = options.parentResource;
          var incompleteChildren = [];
          for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {
            if (!parent.children[_i2].isComplete) {
              incompleteChildren.push(parent.children[_i2]);
            }
          }
          var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
          var eachChunk = fullChunk / (incompleteChildren.length + 2);
          parent.children.push(this.resources[name]);
          parent.progressChunk = eachChunk;
          for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {
            incompleteChildren[_i3].progressChunk = eachChunk;
          }
          this.resources[name].progressChunk = eachChunk;
        }
        this._queue.push(this.resources[name]);
        return this;
      };
      _proto.pre = function pre(fn) {
        this._beforeMiddleware.push(fn);
        return this;
      };
      _proto.use = function use(fn) {
        this._afterMiddleware.push(fn);
        return this;
      };
      _proto.reset = function reset() {
        this.progress = 0;
        this.loading = false;
        this._queue.kill();
        this._queue.pause();
        for (var k2 in this.resources) {
          var res = this.resources[k2];
          if (res._onLoadBinding) {
            res._onLoadBinding.detach();
          }
          if (res.isLoading) {
            res.abort();
          }
        }
        this.resources = {};
        return this;
      };
      _proto.load = function load(cb) {
        if (typeof cb === "function") {
          this.onComplete.once(cb);
        }
        if (this.loading) {
          return this;
        }
        if (this._queue.idle()) {
          this._onStart();
          this._onComplete();
        } else {
          var numTasks = this._queue._tasks.length;
          var chunk = MAX_PROGRESS / numTasks;
          for (var i2 = 0; i2 < this._queue._tasks.length; ++i2) {
            this._queue._tasks[i2].data.progressChunk = chunk;
          }
          this._onStart();
          this._queue.resume();
        }
        return this;
      };
      _proto._prepareUrl = function _prepareUrl(url) {
        var parsedUrl = parseUri(url, {
          strictMode: true
        });
        var result;
        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf("//") === 0) {
          result = url;
        } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url.charAt(0) !== "/") {
          result = this.baseUrl + "/" + url;
        } else {
          result = this.baseUrl + url;
        }
        if (this.defaultQueryString) {
          var hash = rgxExtractUrlHash.exec(result)[0];
          result = result.substr(0, result.length - hash.length);
          if (result.indexOf("?") !== -1) {
            result += "&" + this.defaultQueryString;
          } else {
            result += "?" + this.defaultQueryString;
          }
          result += hash;
        }
        return result;
      };
      _proto._loadResource = function _loadResource(resource, dequeue) {
        var _this2 = this;
        resource._dequeue = dequeue;
        eachSeries(this._beforeMiddleware, function(fn, next) {
          fn.call(_this2, resource, function() {
            next(resource.isComplete ? {} : null);
          });
        }, function() {
          if (resource.isComplete) {
            _this2._onLoad(resource);
          } else {
            resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
            resource.load();
          }
        }, true);
      };
      _proto._onStart = function _onStart() {
        this.progress = 0;
        this.loading = true;
        this.onStart.dispatch(this);
      };
      _proto._onComplete = function _onComplete() {
        this.progress = MAX_PROGRESS;
        this.loading = false;
        this.onComplete.dispatch(this, this.resources);
      };
      _proto._onLoad = function _onLoad(resource) {
        var _this3 = this;
        resource._onLoadBinding = null;
        this._resourcesParsing.push(resource);
        resource._dequeue();
        eachSeries(this._afterMiddleware, function(fn, next) {
          fn.call(_this3, resource, next);
        }, function() {
          resource.onAfterMiddleware.dispatch(resource);
          _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);
          _this3.onProgress.dispatch(_this3, resource);
          if (resource.error) {
            _this3.onError.dispatch(resource.error, _this3, resource);
          } else {
            _this3.onLoad.dispatch(_this3, resource);
          }
          _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
          if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
            _this3._onComplete();
          }
        }, true);
      };
      _createClass(Loader2, [{
        key: "concurrency",
        get: function get2() {
          return this._queue.concurrency;
        },
        set: function set2(concurrency) {
          this._queue.concurrency = concurrency;
        }
      }]);
      return Loader2;
    }();
    Loader._defaultBeforeMiddleware = [];
    Loader._defaultAfterMiddleware = [];
    Loader.pre = function LoaderPreStatic(fn) {
      Loader._defaultBeforeMiddleware.push(fn);
      return Loader;
    };
    Loader.use = function LoaderUseStatic(fn) {
      Loader._defaultAfterMiddleware.push(fn);
      return Loader;
    };
    exports.Loader = Loader;
    exports.Resource = Resource;
    exports.async = async;
    exports.encodeBinary = encodeBinary;
    exports.middleware = index;
  });

  // node_modules/ismobilejs/cjs/isMobile.js
  var require_isMobile = __commonJS((exports) => {
    "use strict";
    exports.__esModule = true;
    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
    function createMatch(userAgent) {
      return function(regex) {
        return regex.test(userAgent);
      };
    }
    function isMobile(param) {
      var nav = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
      };
      if (!param && typeof navigator !== "undefined") {
        nav = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0
        };
      } else if (typeof param === "string") {
        nav.userAgent = param;
      } else if (param && param.userAgent) {
        nav = {
          userAgent: param.userAgent,
          platform: param.platform,
          maxTouchPoints: param.maxTouchPoints || 0
        };
      }
      var userAgent = nav.userAgent;
      var tmp = userAgent.split("[FBAN");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      tmp = userAgent.split("Twitter");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      var match = createMatch(userAgent);
      var result = {
        apple: {
          phone: match(appleIphone) && !match(windowsPhone),
          ipod: match(appleIpod),
          tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
          universal: match(appleUniversal),
          device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
        },
        amazon: {
          phone: match(amazonPhone),
          tablet: !match(amazonPhone) && match(amazonTablet),
          device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
          phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
          tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
          device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
        },
        windows: {
          phone: match(windowsPhone),
          tablet: match(windowsTablet),
          device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
          blackberry: match(otherBlackBerry),
          blackberry10: match(otherBlackBerry10),
          opera: match(otherOpera),
          firefox: match(otherFirefox),
          chrome: match(otherChrome),
          device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
      };
      result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
      result.phone = result.apple.phone || result.android.phone || result.windows.phone;
      result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
      return result;
    }
    exports["default"] = isMobile;
  });

  // node_modules/ismobilejs/cjs/index.js
  var require_cjs = __commonJS((exports) => {
    "use strict";
    function __export2(m2) {
      for (var p2 in m2)
        if (!exports.hasOwnProperty(p2))
          exports[p2] = m2[p2];
    }
    exports.__esModule = true;
    __export2(require_isMobile());
    var isMobile_1 = require_isMobile();
    exports["default"] = isMobile_1["default"];
  });

  // node_modules/@pixi/settings/dist/cjs/settings.js
  var require_settings = __commonJS((exports) => {
    /*!
     * @pixi/settings - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/settings is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var isMobileCall = _interopDefault(require_cjs());
    var isMobile = isMobileCall(self.navigator);
    function maxRecommendedTextures(max) {
      var allowMax = true;
      if (isMobile.tablet || isMobile.phone) {
        if (isMobile.apple.device) {
          var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 11) {
              allowMax = false;
            }
          }
        }
        if (isMobile.android.device) {
          var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 7) {
              allowMax = false;
            }
          }
        }
      }
      return allowMax ? max : 4;
    }
    function canUploadSameBuffer() {
      return !isMobile.apple.device;
    }
    var settings2 = {
      MIPMAP_TEXTURES: 1,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: false,
        autoDensity: false,
        backgroundColor: 0,
        backgroundAlpha: 1,
        useContextAlpha: true,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        width: 800,
        height: 600,
        legacy: false
      },
      GC_MODE: 0,
      GC_MAX_IDLE: 60 * 60,
      GC_MAX_CHECK_COUNT: 60 * 10,
      WRAP_MODE: 33071,
      SCALE_MODE: 1,
      PRECISION_VERTEX: "highp",
      PRECISION_FRAGMENT: isMobile.apple.device ? "highp" : "mediump",
      CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
      CREATE_IMAGE_BITMAP: false,
      ROUND_PIXELS: false
    };
    exports.isMobile = isMobile;
    exports.settings = settings2;
  });

  // node_modules/@pixi/constants/dist/cjs/constants.js
  var require_constants = __commonJS((exports) => {
    /*!
     * @pixi/constants - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/constants is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    (function(ENV) {
      ENV[ENV["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV[ENV["WEBGL"] = 1] = "WEBGL";
      ENV[ENV["WEBGL2"] = 2] = "WEBGL2";
    })(exports.ENV || (exports.ENV = {}));
    (function(RENDERER_TYPE) {
      RENDERER_TYPE[RENDERER_TYPE["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE[RENDERER_TYPE["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE[RENDERER_TYPE["CANVAS"] = 2] = "CANVAS";
    })(exports.RENDERER_TYPE || (exports.RENDERER_TYPE = {}));
    (function(BUFFER_BITS) {
      BUFFER_BITS[BUFFER_BITS["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS[BUFFER_BITS["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS[BUFFER_BITS["STENCIL"] = 1024] = "STENCIL";
    })(exports.BUFFER_BITS || (exports.BUFFER_BITS = {}));
    (function(BLEND_MODES) {
      BLEND_MODES[BLEND_MODES["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES[BLEND_MODES["ADD"] = 1] = "ADD";
      BLEND_MODES[BLEND_MODES["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES[BLEND_MODES["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES[BLEND_MODES["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES[BLEND_MODES["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES[BLEND_MODES["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES[BLEND_MODES["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES[BLEND_MODES["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES[BLEND_MODES["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES[BLEND_MODES["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES[BLEND_MODES["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES[BLEND_MODES["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES[BLEND_MODES["HUE"] = 13] = "HUE";
      BLEND_MODES[BLEND_MODES["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES[BLEND_MODES["COLOR"] = 15] = "COLOR";
      BLEND_MODES[BLEND_MODES["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES[BLEND_MODES["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES[BLEND_MODES["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES[BLEND_MODES["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES[BLEND_MODES["NONE"] = 20] = "NONE";
      BLEND_MODES[BLEND_MODES["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES[BLEND_MODES["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES[BLEND_MODES["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES[BLEND_MODES["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES[BLEND_MODES["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES[BLEND_MODES["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES[BLEND_MODES["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES[BLEND_MODES["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES[BLEND_MODES["ERASE"] = 26] = "ERASE";
      BLEND_MODES[BLEND_MODES["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES[BLEND_MODES["XOR"] = 29] = "XOR";
    })(exports.BLEND_MODES || (exports.BLEND_MODES = {}));
    (function(DRAW_MODES) {
      DRAW_MODES[DRAW_MODES["POINTS"] = 0] = "POINTS";
      DRAW_MODES[DRAW_MODES["LINES"] = 1] = "LINES";
      DRAW_MODES[DRAW_MODES["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES[DRAW_MODES["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES[DRAW_MODES["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES[DRAW_MODES["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES[DRAW_MODES["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(exports.DRAW_MODES || (exports.DRAW_MODES = {}));
    (function(FORMATS) {
      FORMATS[FORMATS["RGBA"] = 6408] = "RGBA";
      FORMATS[FORMATS["RGB"] = 6407] = "RGB";
      FORMATS[FORMATS["ALPHA"] = 6406] = "ALPHA";
      FORMATS[FORMATS["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS[FORMATS["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS[FORMATS["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS[FORMATS["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(exports.FORMATS || (exports.FORMATS = {}));
    (function(TARGETS) {
      TARGETS[TARGETS["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS[TARGETS["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS[TARGETS["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(exports.TARGETS || (exports.TARGETS = {}));
    (function(TYPES) {
      TYPES[TYPES["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES[TYPES["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES[TYPES["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES[TYPES["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES[TYPES["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES[TYPES["FLOAT"] = 5126] = "FLOAT";
      TYPES[TYPES["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(exports.TYPES || (exports.TYPES = {}));
    (function(SCALE_MODES3) {
      SCALE_MODES3[SCALE_MODES3["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES3[SCALE_MODES3["LINEAR"] = 1] = "LINEAR";
    })(exports.SCALE_MODES || (exports.SCALE_MODES = {}));
    (function(WRAP_MODES) {
      WRAP_MODES[WRAP_MODES["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES[WRAP_MODES["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES[WRAP_MODES["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(exports.WRAP_MODES || (exports.WRAP_MODES = {}));
    (function(MIPMAP_MODES) {
      MIPMAP_MODES[MIPMAP_MODES["OFF"] = 0] = "OFF";
      MIPMAP_MODES[MIPMAP_MODES["POW2"] = 1] = "POW2";
      MIPMAP_MODES[MIPMAP_MODES["ON"] = 2] = "ON";
      MIPMAP_MODES[MIPMAP_MODES["ON_MANUAL"] = 3] = "ON_MANUAL";
    })(exports.MIPMAP_MODES || (exports.MIPMAP_MODES = {}));
    (function(ALPHA_MODES) {
      ALPHA_MODES[ALPHA_MODES["NPM"] = 0] = "NPM";
      ALPHA_MODES[ALPHA_MODES["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES[ALPHA_MODES["PMA"] = 2] = "PMA";
      ALPHA_MODES[ALPHA_MODES["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES[ALPHA_MODES["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES[ALPHA_MODES["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(exports.ALPHA_MODES || (exports.ALPHA_MODES = {}));
    (function(CLEAR_MODES) {
      CLEAR_MODES[CLEAR_MODES["NO"] = 0] = "NO";
      CLEAR_MODES[CLEAR_MODES["YES"] = 1] = "YES";
      CLEAR_MODES[CLEAR_MODES["AUTO"] = 2] = "AUTO";
      CLEAR_MODES[CLEAR_MODES["BLEND"] = 0] = "BLEND";
      CLEAR_MODES[CLEAR_MODES["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES[CLEAR_MODES["BLIT"] = 2] = "BLIT";
    })(exports.CLEAR_MODES || (exports.CLEAR_MODES = {}));
    (function(GC_MODES) {
      GC_MODES[GC_MODES["AUTO"] = 0] = "AUTO";
      GC_MODES[GC_MODES["MANUAL"] = 1] = "MANUAL";
    })(exports.GC_MODES || (exports.GC_MODES = {}));
    (function(PRECISION) {
      PRECISION["LOW"] = "lowp";
      PRECISION["MEDIUM"] = "mediump";
      PRECISION["HIGH"] = "highp";
    })(exports.PRECISION || (exports.PRECISION = {}));
    (function(MASK_TYPES) {
      MASK_TYPES[MASK_TYPES["NONE"] = 0] = "NONE";
      MASK_TYPES[MASK_TYPES["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES[MASK_TYPES["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES[MASK_TYPES["SPRITE"] = 3] = "SPRITE";
    })(exports.MASK_TYPES || (exports.MASK_TYPES = {}));
    (function(MSAA_QUALITY) {
      MSAA_QUALITY[MSAA_QUALITY["NONE"] = 0] = "NONE";
      MSAA_QUALITY[MSAA_QUALITY["LOW"] = 2] = "LOW";
      MSAA_QUALITY[MSAA_QUALITY["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY[MSAA_QUALITY["HIGH"] = 8] = "HIGH";
    })(exports.MSAA_QUALITY || (exports.MSAA_QUALITY = {}));
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS((exports, module) => {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (typeof module !== "undefined") {
      module.exports = EventEmitter;
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS((exports, module) => {
    "use strict";
    module.exports = earcut;
    module.exports.default = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x2 = data[i2];
          y2 = data[i2 + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i2, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var p2 = ear.next.next;
      while (p2 !== ear.prev) {
        if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
      var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b2 = p2.next.next;
        if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
          triangles.push(a2.i / dim);
          triangles.push(p2.i / dim);
          triangles.push(b2.i / dim);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b2;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
            var c2 = splitPolygon(a2, b2);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize);
            earcutLinked(c2, triangles, dim, minX, minY, invSize);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        eliminateHole(queue[i2], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b2 = splitPolygon(outerNode, hole);
        filterPoints(outerNode, outerNode.next);
        filterPoints(b2, b2.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            if (x2 === hx) {
              if (hy === p2.y)
                return p2;
              if (hy === p2.next.y)
                return p2.next;
            }
            m2 = p2.x < p2.next.x ? p2 : p2.next;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2)
        return null;
      if (hx === qx)
        return m2;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === null)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q = p2;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e2;
            else
              list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = 32767 * (x2 - minX) * invSize;
      y2 = 32767 * (y2 - minY) * invSize;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p2, q, r2) {
      return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q, r2) {
      return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b2) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
          return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b2) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
    }
    function middleInside(a2, b2) {
      var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b2) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i2, x2, y2, last) {
      var p2 = new Node(i2, x2, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i2, x2, y2) {
      this.i = i2;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          var start = holeIndices[i2] * dim;
          var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a2 = triangles[i2] * dim;
        var b2 = triangles[i2 + 1] * dim;
        var c2 = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs((data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1]));
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
        sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
        j2 = i2;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result = {vertices: [], holes: [], dimensions: dim}, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j2 = 0; j2 < data[i2].length; j2++) {
          for (var d2 = 0; d2 < dim; d2++)
            result.vertices.push(data[i2][j2][d2]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  });

  // node_modules/punycode/punycode.js
  var require_punycode = __commonJS((exports, module) => {
    /*! https://mths.be/punycode v1.3.2 by @mathias */
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type2) {
        throw RangeError(errors[type2]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k2 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j2 = 0; j2 < basic; ++j2) {
          if (input.charCodeAt(j2) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j2));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i2) / w2)) {
              error("overflow");
            }
            i2 += digit * w2;
            t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
            if (digit < t2) {
              break;
            }
            baseMinusT = base - t2;
            if (w2 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w2 *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor(i2 / out) > maxInt - n2) {
            error("overflow");
          }
          n2 += floor(i2 / out);
          i2 %= out;
          output.splice(i2++, 0, n2);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n2, delta, handledCPCount, basicLength, bias, j2, m2, q, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n2 = initialN;
        delta = 0;
        bias = initialBias;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue >= n2 && currentValue < m2) {
              m2 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m2 - n2) * handledCPCountPlusOne;
          n2 = m2;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < n2 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n2) {
              for (q = delta, k2 = base; ; k2 += base) {
                t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                if (q < t2) {
                  break;
                }
                qMinusT = q - t2;
                baseMinusT = base - t2;
                output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        version: "1.3.2",
        ucs2: {
          decode: ucs2decode,
          encode: ucs2encode
        },
        decode,
        encode,
        toASCII,
        toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  });

  // node_modules/url/util.js
  var require_util = __commonJS((exports, module) => {
    "use strict";
    module.exports = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
  });

  // node_modules/querystring/decode.js
  var require_decode = __commonJS((exports, module) => {
    "use strict";
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i2 = 0; i2 < len; ++i2) {
        var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v2;
        if (idx >= 0) {
          kstr = x2.substr(0, idx);
          vstr = x2.substr(idx + 1);
        } else {
          kstr = x2;
          vstr = "";
        }
        k2 = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k2)) {
          obj[k2] = v2;
        } else if (Array.isArray(obj[k2])) {
          obj[k2].push(v2);
        } else {
          obj[k2] = [obj[k2], v2];
        }
      }
      return obj;
    };
  });

  // node_modules/querystring/encode.js
  var require_encode = __commonJS((exports, module) => {
    "use strict";
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k2) {
          var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq;
          if (Array.isArray(obj[k2])) {
            return obj[k2].map(function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
  });

  // node_modules/querystring/index.js
  var require_querystring = __commonJS((exports) => {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  });

  // node_modules/url/url.js
  var require_url = __commonJS((exports) => {
    "use strict";
    var punycode = require_punycode();
    var util = require_util();
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_querystring();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url)
        return url;
      var u2 = new Url();
      u2.parse(url, parseQueryString, slashesDenoteHost);
      return u2;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
          var hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i2 = 0; i2 < nonHostChars.length; i2++) {
          var hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
                if (part.charCodeAt(j2) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j2];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p2 = this.port ? ":" + this.port : "";
        var h2 = this.hostname || "";
        this.host = h2 + p2;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
          var ae = autoEscape[i2];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p2 = this.pathname || "";
        var s3 = this.search || "";
        this.path = p2 + s3;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url))
        return Url.prototype.format.call(obj);
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v2 = 0; v2 < keys.length; v2++) {
            var k2 = keys[v2];
            result[k2] = relative[k2];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p2 = result.pathname || "";
          var s3 = result.search || "";
          result.path = p2 + s3;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i2 = srcPath.length; i2 >= 0; i2--) {
        last = srcPath[i2];
        if (last === ".") {
          srcPath.splice(i2, 1);
        } else if (last === "..") {
          srcPath.splice(i2, 1);
          up++;
        } else if (up) {
          srcPath.splice(i2, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
  });

  // node_modules/@pixi/utils/dist/cjs/utils.js
  var require_utils = __commonJS((exports) => {
    /*!
     * @pixi/utils - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/utils is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var settings2 = require_settings();
    var eventemitter3 = _interopDefault(require_eventemitter3());
    var earcut = _interopDefault(require_earcut());
    var url$1 = require_url();
    var constants = require_constants();
    var url = {
      parse: url$1.parse,
      format: url$1.format,
      resolve: url$1.resolve
    };
    settings2.settings.RETINA_PREFIX = /@([0-9\.]+)x/;
    settings2.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
    var saidHello = false;
    var VERSION2 = "6.0.2";
    function skipHello() {
      saidHello = true;
    }
    function sayHello(type2) {
      var _a;
      if (saidHello) {
        return;
      }
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        var args = [
          "\n %c %c %c PixiJS " + VERSION2 + " - \u2730 " + type2 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
          "background: #ff66a5; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff66a5; background: #030307; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "background: #ffc3dc; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;"
        ];
        (_a = self.console).log.apply(_a, args);
      } else if (self.console) {
        self.console.log("PixiJS " + VERSION2 + " - " + type2 + " - http://www.pixijs.com/");
      }
      saidHello = true;
    }
    var supported;
    function isWebGLSupported() {
      if (typeof supported === "undefined") {
        supported = function supported2() {
          var contextOptions = {
            stencil: true,
            failIfMajorPerformanceCaveat: settings2.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
          };
          try {
            if (!self.WebGLRenderingContext) {
              return false;
            }
            var canvas = document.createElement("canvas");
            var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
              var loseContext = gl.getExtension("WEBGL_lose_context");
              if (loseContext) {
                loseContext.loseContext();
              }
            }
            gl = null;
            return success;
          } catch (e2) {
            return false;
          }
        }();
      }
      return supported;
    }
    var aliceblue = "#f0f8ff";
    var antiquewhite = "#faebd7";
    var aqua = "#00ffff";
    var aquamarine = "#7fffd4";
    var azure = "#f0ffff";
    var beige = "#f5f5dc";
    var bisque = "#ffe4c4";
    var black = "#000000";
    var blanchedalmond = "#ffebcd";
    var blue = "#0000ff";
    var blueviolet = "#8a2be2";
    var brown = "#a52a2a";
    var burlywood = "#deb887";
    var cadetblue = "#5f9ea0";
    var chartreuse = "#7fff00";
    var chocolate = "#d2691e";
    var coral = "#ff7f50";
    var cornflowerblue = "#6495ed";
    var cornsilk = "#fff8dc";
    var crimson = "#dc143c";
    var cyan = "#00ffff";
    var darkblue = "#00008b";
    var darkcyan = "#008b8b";
    var darkgoldenrod = "#b8860b";
    var darkgray = "#a9a9a9";
    var darkgreen = "#006400";
    var darkgrey = "#a9a9a9";
    var darkkhaki = "#bdb76b";
    var darkmagenta = "#8b008b";
    var darkolivegreen = "#556b2f";
    var darkorange = "#ff8c00";
    var darkorchid = "#9932cc";
    var darkred = "#8b0000";
    var darksalmon = "#e9967a";
    var darkseagreen = "#8fbc8f";
    var darkslateblue = "#483d8b";
    var darkslategray = "#2f4f4f";
    var darkslategrey = "#2f4f4f";
    var darkturquoise = "#00ced1";
    var darkviolet = "#9400d3";
    var deeppink = "#ff1493";
    var deepskyblue = "#00bfff";
    var dimgray = "#696969";
    var dimgrey = "#696969";
    var dodgerblue = "#1e90ff";
    var firebrick = "#b22222";
    var floralwhite = "#fffaf0";
    var forestgreen = "#228b22";
    var fuchsia = "#ff00ff";
    var gainsboro = "#dcdcdc";
    var ghostwhite = "#f8f8ff";
    var goldenrod = "#daa520";
    var gold = "#ffd700";
    var gray = "#808080";
    var green = "#008000";
    var greenyellow = "#adff2f";
    var grey = "#808080";
    var honeydew = "#f0fff0";
    var hotpink = "#ff69b4";
    var indianred = "#cd5c5c";
    var indigo = "#4b0082";
    var ivory = "#fffff0";
    var khaki = "#f0e68c";
    var lavenderblush = "#fff0f5";
    var lavender = "#e6e6fa";
    var lawngreen = "#7cfc00";
    var lemonchiffon = "#fffacd";
    var lightblue = "#add8e6";
    var lightcoral = "#f08080";
    var lightcyan = "#e0ffff";
    var lightgoldenrodyellow = "#fafad2";
    var lightgray = "#d3d3d3";
    var lightgreen = "#90ee90";
    var lightgrey = "#d3d3d3";
    var lightpink = "#ffb6c1";
    var lightsalmon = "#ffa07a";
    var lightseagreen = "#20b2aa";
    var lightskyblue = "#87cefa";
    var lightslategray = "#778899";
    var lightslategrey = "#778899";
    var lightsteelblue = "#b0c4de";
    var lightyellow = "#ffffe0";
    var lime = "#00ff00";
    var limegreen = "#32cd32";
    var linen = "#faf0e6";
    var magenta = "#ff00ff";
    var maroon = "#800000";
    var mediumaquamarine = "#66cdaa";
    var mediumblue = "#0000cd";
    var mediumorchid = "#ba55d3";
    var mediumpurple = "#9370db";
    var mediumseagreen = "#3cb371";
    var mediumslateblue = "#7b68ee";
    var mediumspringgreen = "#00fa9a";
    var mediumturquoise = "#48d1cc";
    var mediumvioletred = "#c71585";
    var midnightblue = "#191970";
    var mintcream = "#f5fffa";
    var mistyrose = "#ffe4e1";
    var moccasin = "#ffe4b5";
    var navajowhite = "#ffdead";
    var navy = "#000080";
    var oldlace = "#fdf5e6";
    var olive = "#808000";
    var olivedrab = "#6b8e23";
    var orange = "#ffa500";
    var orangered = "#ff4500";
    var orchid = "#da70d6";
    var palegoldenrod = "#eee8aa";
    var palegreen = "#98fb98";
    var paleturquoise = "#afeeee";
    var palevioletred = "#db7093";
    var papayawhip = "#ffefd5";
    var peachpuff = "#ffdab9";
    var peru = "#cd853f";
    var pink = "#ffc0cb";
    var plum = "#dda0dd";
    var powderblue = "#b0e0e6";
    var purple = "#800080";
    var rebeccapurple = "#663399";
    var red = "#ff0000";
    var rosybrown = "#bc8f8f";
    var royalblue = "#4169e1";
    var saddlebrown = "#8b4513";
    var salmon = "#fa8072";
    var sandybrown = "#f4a460";
    var seagreen = "#2e8b57";
    var seashell = "#fff5ee";
    var sienna = "#a0522d";
    var silver = "#c0c0c0";
    var skyblue = "#87ceeb";
    var slateblue = "#6a5acd";
    var slategray = "#708090";
    var slategrey = "#708090";
    var snow = "#fffafa";
    var springgreen = "#00ff7f";
    var steelblue = "#4682b4";
    var tan = "#d2b48c";
    var teal = "#008080";
    var thistle = "#d8bfd8";
    var tomato = "#ff6347";
    var turquoise = "#40e0d0";
    var violet = "#ee82ee";
    var wheat = "#f5deb3";
    var white = "#ffffff";
    var whitesmoke = "#f5f5f5";
    var yellow = "#ffff00";
    var yellowgreen = "#9acd32";
    var cssColorNames = {
      aliceblue,
      antiquewhite,
      aqua,
      aquamarine,
      azure,
      beige,
      bisque,
      black,
      blanchedalmond,
      blue,
      blueviolet,
      brown,
      burlywood,
      cadetblue,
      chartreuse,
      chocolate,
      coral,
      cornflowerblue,
      cornsilk,
      crimson,
      cyan,
      darkblue,
      darkcyan,
      darkgoldenrod,
      darkgray,
      darkgreen,
      darkgrey,
      darkkhaki,
      darkmagenta,
      darkolivegreen,
      darkorange,
      darkorchid,
      darkred,
      darksalmon,
      darkseagreen,
      darkslateblue,
      darkslategray,
      darkslategrey,
      darkturquoise,
      darkviolet,
      deeppink,
      deepskyblue,
      dimgray,
      dimgrey,
      dodgerblue,
      firebrick,
      floralwhite,
      forestgreen,
      fuchsia,
      gainsboro,
      ghostwhite,
      goldenrod,
      gold,
      gray,
      green,
      greenyellow,
      grey,
      honeydew,
      hotpink,
      indianred,
      indigo,
      ivory,
      khaki,
      lavenderblush,
      lavender,
      lawngreen,
      lemonchiffon,
      lightblue,
      lightcoral,
      lightcyan,
      lightgoldenrodyellow,
      lightgray,
      lightgreen,
      lightgrey,
      lightpink,
      lightsalmon,
      lightseagreen,
      lightskyblue,
      lightslategray,
      lightslategrey,
      lightsteelblue,
      lightyellow,
      lime,
      limegreen,
      linen,
      magenta,
      maroon,
      mediumaquamarine,
      mediumblue,
      mediumorchid,
      mediumpurple,
      mediumseagreen,
      mediumslateblue,
      mediumspringgreen,
      mediumturquoise,
      mediumvioletred,
      midnightblue,
      mintcream,
      mistyrose,
      moccasin,
      navajowhite,
      navy,
      oldlace,
      olive,
      olivedrab,
      orange,
      orangered,
      orchid,
      palegoldenrod,
      palegreen,
      paleturquoise,
      palevioletred,
      papayawhip,
      peachpuff,
      peru,
      pink,
      plum,
      powderblue,
      purple,
      rebeccapurple,
      red,
      rosybrown,
      royalblue,
      saddlebrown,
      salmon,
      sandybrown,
      seagreen,
      seashell,
      sienna,
      silver,
      skyblue,
      slateblue,
      slategray,
      slategrey,
      snow,
      springgreen,
      steelblue,
      tan,
      teal,
      thistle,
      tomato,
      turquoise,
      violet,
      wheat,
      white,
      whitesmoke,
      yellow,
      yellowgreen
    };
    function hex2rgb(hex, out) {
      if (out === void 0) {
        out = [];
      }
      out[0] = (hex >> 16 & 255) / 255;
      out[1] = (hex >> 8 & 255) / 255;
      out[2] = (hex & 255) / 255;
      return out;
    }
    function hex2string(hex) {
      var hexString = hex.toString(16);
      hexString = "000000".substr(0, 6 - hexString.length) + hexString;
      return "#" + hexString;
    }
    function string2hex(string) {
      if (typeof string === "string") {
        string = cssColorNames[string.toLowerCase()] || string;
        if (string[0] === "#") {
          string = string.substr(1);
        }
      }
      return parseInt(string, 16);
    }
    function rgb2hex(rgb) {
      return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
    }
    function mapPremultipliedBlendModes() {
      var pm = [];
      var npm = [];
      for (var i2 = 0; i2 < 32; i2++) {
        pm[i2] = i2;
        npm[i2] = i2;
      }
      pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL;
      pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD;
      pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN;
      npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM;
      npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM;
      npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;
      var array = [];
      array.push(npm);
      array.push(pm);
      return array;
    }
    var premultiplyBlendMode = mapPremultipliedBlendModes();
    function correctBlendMode(blendMode, premultiplied) {
      return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    function premultiplyRgba(rgb, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      if (premultiply || premultiply === void 0) {
        out[0] = rgb[0] * alpha;
        out[1] = rgb[1] * alpha;
        out[2] = rgb[2] * alpha;
      } else {
        out[0] = rgb[0];
        out[1] = rgb[1];
        out[2] = rgb[2];
      }
      out[3] = alpha;
      return out;
    }
    function premultiplyTint(tint, alpha) {
      if (alpha === 1) {
        return (alpha * 255 << 24) + tint;
      }
      if (alpha === 0) {
        return 0;
      }
      var R = tint >> 16 & 255;
      var G = tint >> 8 & 255;
      var B = tint & 255;
      R = R * alpha + 0.5 | 0;
      G = G * alpha + 0.5 | 0;
      B = B * alpha + 0.5 | 0;
      return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
    }
    function premultiplyTintToRgba(tint, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      out[0] = (tint >> 16 & 255) / 255;
      out[1] = (tint >> 8 & 255) / 255;
      out[2] = (tint & 255) / 255;
      if (premultiply || premultiply === void 0) {
        out[0] *= alpha;
        out[1] *= alpha;
        out[2] *= alpha;
      }
      out[3] = alpha;
      return out;
    }
    function createIndicesForQuads(size, outBuffer) {
      if (outBuffer === void 0) {
        outBuffer = null;
      }
      var totalIndices = size * 6;
      outBuffer = outBuffer || new Uint16Array(totalIndices);
      if (outBuffer.length !== totalIndices) {
        throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
      }
      for (var i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
        outBuffer[i2 + 0] = j2 + 0;
        outBuffer[i2 + 1] = j2 + 1;
        outBuffer[i2 + 2] = j2 + 2;
        outBuffer[i2 + 3] = j2 + 0;
        outBuffer[i2 + 4] = j2 + 2;
        outBuffer[i2 + 5] = j2 + 3;
      }
      return outBuffer;
    }
    function getBufferType(array) {
      if (array.BYTES_PER_ELEMENT === 4) {
        if (array instanceof Float32Array) {
          return "Float32Array";
        } else if (array instanceof Uint32Array) {
          return "Uint32Array";
        }
        return "Int32Array";
      } else if (array.BYTES_PER_ELEMENT === 2) {
        if (array instanceof Uint16Array) {
          return "Uint16Array";
        }
      } else if (array.BYTES_PER_ELEMENT === 1) {
        if (array instanceof Uint8Array) {
          return "Uint8Array";
        }
      }
      return null;
    }
    var map = {Float32Array, Uint32Array, Int32Array, Uint8Array};
    function interleaveTypedArrays(arrays, sizes) {
      var outSize = 0;
      var stride = 0;
      var views = {};
      for (var i2 = 0; i2 < arrays.length; i2++) {
        stride += sizes[i2];
        outSize += arrays[i2].length;
      }
      var buffer = new ArrayBuffer(outSize * 4);
      var out = null;
      var littleOffset = 0;
      for (var i2 = 0; i2 < arrays.length; i2++) {
        var size = sizes[i2];
        var array = arrays[i2];
        var type2 = getBufferType(array);
        if (!views[type2]) {
          views[type2] = new map[type2](buffer);
        }
        out = views[type2];
        for (var j2 = 0; j2 < array.length; j2++) {
          var indexStart = (j2 / size | 0) * stride + littleOffset;
          var index = j2 % size;
          out[indexStart + index] = array[j2];
        }
        littleOffset += size;
      }
      return new Float32Array(buffer);
    }
    function nextPow2(v2) {
      v2 += v2 === 0 ? 1 : 0;
      --v2;
      v2 |= v2 >>> 1;
      v2 |= v2 >>> 2;
      v2 |= v2 >>> 4;
      v2 |= v2 >>> 8;
      v2 |= v2 >>> 16;
      return v2 + 1;
    }
    function isPow2(v2) {
      return !(v2 & v2 - 1) && !!v2;
    }
    function log2(v2) {
      var r2 = (v2 > 65535 ? 1 : 0) << 4;
      v2 >>>= r2;
      var shift = (v2 > 255 ? 1 : 0) << 3;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 15 ? 1 : 0) << 2;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 3 ? 1 : 0) << 1;
      v2 >>>= shift;
      r2 |= shift;
      return r2 | v2 >> 1;
    }
    function removeItems(arr, startIdx, removeCount) {
      var length = arr.length;
      var i2;
      if (startIdx >= length || removeCount === 0) {
        return;
      }
      removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
      var len = length - removeCount;
      for (i2 = startIdx; i2 < len; ++i2) {
        arr[i2] = arr[i2 + removeCount];
      }
      arr.length = len;
    }
    function sign(n2) {
      if (n2 === 0) {
        return 0;
      }
      return n2 < 0 ? -1 : 1;
    }
    var nextUid = 0;
    function uid() {
      return ++nextUid;
    }
    var warnings = {};
    function deprecation(version, message, ignoreDepth) {
      if (ignoreDepth === void 0) {
        ignoreDepth = 3;
      }
      if (warnings[message]) {
        return;
      }
      var stack = new Error().stack;
      if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (console.groupCollapsed) {
          console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
          console.warn(stack);
          console.groupEnd();
        } else {
          console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
          console.warn(stack);
        }
      }
      warnings[message] = true;
    }
    var ProgramCache = {};
    var TextureCache = Object.create(null);
    var BaseTextureCache = Object.create(null);
    function destroyTextureCache() {
      var key;
      for (key in TextureCache) {
        TextureCache[key].destroy();
      }
      for (key in BaseTextureCache) {
        BaseTextureCache[key].destroy();
      }
    }
    function clearTextureCache() {
      var key;
      for (key in TextureCache) {
        delete TextureCache[key];
      }
      for (key in BaseTextureCache) {
        delete BaseTextureCache[key];
      }
    }
    var CanvasRenderTarget = function() {
      function CanvasRenderTarget2(width, height, resolution) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.resolution = resolution || settings2.settings.RESOLUTION;
        this.resize(width, height);
      }
      CanvasRenderTarget2.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderTarget2.prototype.resize = function(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
      };
      CanvasRenderTarget2.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
      Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
        get: function() {
          return this.canvas.width;
        },
        set: function(val) {
          this.canvas.width = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
        get: function() {
          return this.canvas.height;
        },
        set: function(val) {
          this.canvas.height = val;
        },
        enumerable: false,
        configurable: true
      });
      return CanvasRenderTarget2;
    }();
    function trimCanvas(canvas) {
      var width = canvas.width;
      var height = canvas.height;
      var context = canvas.getContext("2d");
      var imageData = context.getImageData(0, 0, width, height);
      var pixels = imageData.data;
      var len = pixels.length;
      var bound = {
        top: null,
        left: null,
        right: null,
        bottom: null
      };
      var data = null;
      var i2;
      var x2;
      var y2;
      for (i2 = 0; i2 < len; i2 += 4) {
        if (pixels[i2 + 3] !== 0) {
          x2 = i2 / 4 % width;
          y2 = ~~(i2 / 4 / width);
          if (bound.top === null) {
            bound.top = y2;
          }
          if (bound.left === null) {
            bound.left = x2;
          } else if (x2 < bound.left) {
            bound.left = x2;
          }
          if (bound.right === null) {
            bound.right = x2 + 1;
          } else if (bound.right < x2) {
            bound.right = x2 + 1;
          }
          if (bound.bottom === null) {
            bound.bottom = y2;
          } else if (bound.bottom < y2) {
            bound.bottom = y2;
          }
        }
      }
      if (bound.top !== null) {
        width = bound.right - bound.left;
        height = bound.bottom - bound.top + 1;
        data = context.getImageData(bound.left, bound.top, width, height);
      }
      return {
        height,
        width,
        data
      };
    }
    var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
    function decomposeDataUri(dataUri) {
      var dataUriMatch = DATA_URI.exec(dataUri);
      if (dataUriMatch) {
        return {
          mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
          subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
          charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
          encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
          data: dataUriMatch[5]
        };
      }
      return void 0;
    }
    var tempAnchor;
    function determineCrossOrigin(url$12, loc) {
      if (loc === void 0) {
        loc = self.location;
      }
      if (url$12.indexOf("data:") === 0) {
        return "";
      }
      loc = loc || self.location;
      if (!tempAnchor) {
        tempAnchor = document.createElement("a");
      }
      tempAnchor.href = url$12;
      var parsedUrl = url.parse(tempAnchor.href);
      var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
      if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
        return "anonymous";
      }
      return "";
    }
    function getResolutionOfUrl(url2, defaultValue) {
      var resolution = settings2.settings.RETINA_PREFIX.exec(url2);
      if (resolution) {
        return parseFloat(resolution[1]);
      }
      return defaultValue !== void 0 ? defaultValue : 1;
    }
    Object.defineProperty(exports, "isMobile", {
      enumerable: true,
      get: function() {
        return settings2.isMobile;
      }
    });
    exports.EventEmitter = eventemitter3;
    exports.earcut = earcut;
    exports.BaseTextureCache = BaseTextureCache;
    exports.CanvasRenderTarget = CanvasRenderTarget;
    exports.DATA_URI = DATA_URI;
    exports.ProgramCache = ProgramCache;
    exports.TextureCache = TextureCache;
    exports.clearTextureCache = clearTextureCache;
    exports.correctBlendMode = correctBlendMode;
    exports.createIndicesForQuads = createIndicesForQuads;
    exports.decomposeDataUri = decomposeDataUri;
    exports.deprecation = deprecation;
    exports.destroyTextureCache = destroyTextureCache;
    exports.determineCrossOrigin = determineCrossOrigin;
    exports.getBufferType = getBufferType;
    exports.getResolutionOfUrl = getResolutionOfUrl;
    exports.hex2rgb = hex2rgb;
    exports.hex2string = hex2string;
    exports.interleaveTypedArrays = interleaveTypedArrays;
    exports.isPow2 = isPow2;
    exports.isWebGLSupported = isWebGLSupported;
    exports.log2 = log2;
    exports.nextPow2 = nextPow2;
    exports.premultiplyBlendMode = premultiplyBlendMode;
    exports.premultiplyRgba = premultiplyRgba;
    exports.premultiplyTint = premultiplyTint;
    exports.premultiplyTintToRgba = premultiplyTintToRgba;
    exports.removeItems = removeItems;
    exports.rgb2hex = rgb2hex;
    exports.sayHello = sayHello;
    exports.sign = sign;
    exports.skipHello = skipHello;
    exports.string2hex = string2hex;
    exports.trimCanvas = trimCanvas;
    exports.uid = uid;
    exports.url = url;
  });

  // node_modules/@pixi/runner/dist/cjs/runner.js
  var require_runner = __commonJS((exports) => {
    /*!
     * @pixi/runner - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/runner is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var Runner = function() {
      function Runner2(name) {
        this.items = [];
        this._name = name;
        this._aliasCount = 0;
      }
      Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
          throw new Error("max arguments reached");
        }
        var _a = this, name = _a.name, items = _a.items;
        this._aliasCount++;
        for (var i2 = 0, len = items.length; i2 < len; i2++) {
          items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        if (items === this.items) {
          this._aliasCount--;
        }
        return this;
      };
      Runner2.prototype.ensureNonAliasedItems = function() {
        if (this._aliasCount > 0 && this.items.length > 1) {
          this._aliasCount = 0;
          this.items = this.items.slice(0);
        }
      };
      Runner2.prototype.add = function(item) {
        if (item[this._name]) {
          this.ensureNonAliasedItems();
          this.remove(item);
          this.items.push(item);
        }
        return this;
      };
      Runner2.prototype.remove = function(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
          this.ensureNonAliasedItems();
          this.items.splice(index, 1);
        }
        return this;
      };
      Runner2.prototype.contains = function(item) {
        return this.items.indexOf(item) !== -1;
      };
      Runner2.prototype.removeAll = function() {
        this.ensureNonAliasedItems();
        this.items.length = 0;
        return this;
      };
      Runner2.prototype.destroy = function() {
        this.removeAll();
        this.items = null;
        this._name = null;
      };
      Object.defineProperty(Runner2.prototype, "empty", {
        get: function() {
          return this.items.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Runner2.prototype, "name", {
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      return Runner2;
    }();
    Object.defineProperties(Runner.prototype, {
      dispatch: {value: Runner.prototype.emit},
      run: {value: Runner.prototype.emit}
    });
    exports.Runner = Runner;
  });

  // node_modules/@pixi/ticker/dist/cjs/ticker.js
  var require_ticker = __commonJS((exports) => {
    /*!
     * @pixi/ticker - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/ticker is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var settings2 = require_settings();
    settings2.settings.TARGET_FPMS = 0.06;
    (function(UPDATE_PRIORITY) {
      UPDATE_PRIORITY[UPDATE_PRIORITY["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY[UPDATE_PRIORITY["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY[UPDATE_PRIORITY["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY[UPDATE_PRIORITY["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY[UPDATE_PRIORITY["UTILITY"] = -50] = "UTILITY";
    })(exports.UPDATE_PRIORITY || (exports.UPDATE_PRIORITY = {}));
    var TickerListener = function() {
      function TickerListener2(fn, context, priority, once) {
        if (context === void 0) {
          context = null;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (once === void 0) {
          once = false;
        }
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this.fn = fn;
        this.context = context;
        this.priority = priority;
        this.once = once;
      }
      TickerListener2.prototype.match = function(fn, context) {
        if (context === void 0) {
          context = null;
        }
        return this.fn === fn && this.context === context;
      };
      TickerListener2.prototype.emit = function(deltaTime) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, deltaTime);
          } else {
            this.fn(deltaTime);
          }
        }
        var redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      };
      TickerListener2.prototype.connect = function(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
      TickerListener2.prototype.destroy = function(hard) {
        if (hard === void 0) {
          hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        var redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      };
      return TickerListener2;
    }();
    var Ticker = function() {
      function Ticker2() {
        var _this = this;
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / settings2.settings.TARGET_FPMS;
        this.elapsedMS = 1 / settings2.settings.TARGET_FPMS;
        this._tick = function(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._head.next) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
      }
      Ticker2.prototype._requestIfNeeded = function() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker2.prototype._cancelIfNeeded = function() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker2.prototype._startIfPossible = function() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker2.prototype.add = function(fn, context, priority) {
        if (priority === void 0) {
          priority = exports.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context, priority));
      };
      Ticker2.prototype.addOnce = function(fn, context, priority) {
        if (priority === void 0) {
          priority = exports.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context, priority, true));
      };
      Ticker2.prototype._addListener = function(listener) {
        var current = this._head.next;
        var previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      };
      Ticker2.prototype.remove = function(fn, context) {
        var listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Object.defineProperty(Ticker2.prototype, "count", {
        get: function() {
          if (!this._head) {
            return 0;
          }
          var count = 0;
          var current = this._head;
          while (current = current.next) {
            count++;
          }
          return count;
        },
        enumerable: false,
        configurable: true
      });
      Ticker2.prototype.start = function() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker2.prototype.stop = function() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker2.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          var listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      };
      Ticker2.prototype.update = function(currentTime) {
        if (currentTime === void 0) {
          currentTime = performance.now();
        }
        var elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            var delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * settings2.settings.TARGET_FPMS;
          var head = this._head;
          var listener = head.next;
          while (listener) {
            listener = listener.emit(this.deltaTime);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      };
      Object.defineProperty(Ticker2.prototype, "FPS", {
        get: function() {
          return 1e3 / this.elapsedMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "minFPS", {
        get: function() {
          return 1e3 / this._maxElapsedMS;
        },
        set: function(fps) {
          var minFPS = Math.min(this.maxFPS, fps);
          var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings2.settings.TARGET_FPMS);
          this._maxElapsedMS = 1 / minFPMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "maxFPS", {
        get: function() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        },
        set: function(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            var maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "shared", {
        get: function() {
          if (!Ticker2._shared) {
            var shared = Ticker2._shared = new Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return Ticker2._shared;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "system", {
        get: function() {
          if (!Ticker2._system) {
            var system = Ticker2._system = new Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return Ticker2._system;
        },
        enumerable: false,
        configurable: true
      });
      return Ticker2;
    }();
    var TickerPlugin = function() {
      function TickerPlugin2() {
      }
      TickerPlugin2.init = function(options) {
        var _this = this;
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
          set: function(ticker) {
            if (this._ticker) {
              this._ticker.remove(this.render, this);
            }
            this._ticker = ticker;
            if (ticker) {
              ticker.add(this.render, this, exports.UPDATE_PRIORITY.LOW);
            }
          },
          get: function() {
            return this._ticker;
          }
        });
        this.stop = function() {
          _this._ticker.stop();
        };
        this.start = function() {
          _this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      };
      TickerPlugin2.destroy = function() {
        if (this._ticker) {
          var oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      };
      return TickerPlugin2;
    }();
    exports.Ticker = Ticker;
    exports.TickerPlugin = TickerPlugin;
  });

  // node_modules/@pixi/math/dist/cjs/math.js
  var require_math = __commonJS((exports) => {
    /*!
     * @pixi/math - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/math is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var PI_2 = Math.PI * 2;
    var RAD_TO_DEG = 180 / Math.PI;
    var DEG_TO_RAD = Math.PI / 180;
    (function(SHAPES) {
      SHAPES[SHAPES["POLY"] = 0] = "POLY";
      SHAPES[SHAPES["RECT"] = 1] = "RECT";
      SHAPES[SHAPES["CIRC"] = 2] = "CIRC";
      SHAPES[SHAPES["ELIP"] = 3] = "ELIP";
      SHAPES[SHAPES["RREC"] = 4] = "RREC";
    })(exports.SHAPES || (exports.SHAPES = {}));
    var Rectangle3 = function() {
      function Rectangle4(x2, y2, width, height) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = Number(x2);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
        this.type = exports.SHAPES.RECT;
      }
      Object.defineProperty(Rectangle4.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle4.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle4.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle4.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle4, "EMPTY", {
        get: function() {
          return new Rectangle4(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
      });
      Rectangle4.prototype.clone = function() {
        return new Rectangle4(this.x, this.y, this.width, this.height);
      };
      Rectangle4.prototype.copyFrom = function(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      };
      Rectangle4.prototype.copyTo = function(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
      };
      Rectangle4.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
      Rectangle4.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      };
      Rectangle4.prototype.fit = function(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      };
      Rectangle4.prototype.ceil = function(resolution, eps) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (eps === void 0) {
          eps = 1e-3;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      };
      Rectangle4.prototype.enlarge = function(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      };
      Rectangle4.prototype.toString = function() {
        return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      };
      return Rectangle4;
    }();
    var Circle = function() {
      function Circle2(x2, y2, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (radius === void 0) {
          radius = 0;
        }
        this.x = x2;
        this.y = y2;
        this.radius = radius;
        this.type = exports.SHAPES.CIRC;
      }
      Circle2.prototype.clone = function() {
        return new Circle2(this.x, this.y, this.radius);
      };
      Circle2.prototype.contains = function(x2, y2) {
        if (this.radius <= 0) {
          return false;
        }
        var r2 = this.radius * this.radius;
        var dx = this.x - x2;
        var dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      };
      Circle2.prototype.getBounds = function() {
        return new Rectangle3(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
      Circle2.prototype.toString = function() {
        return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
      };
      return Circle2;
    }();
    var Ellipse = function() {
      function Ellipse2(x2, y2, halfWidth, halfHeight) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (halfWidth === void 0) {
          halfWidth = 0;
        }
        if (halfHeight === void 0) {
          halfHeight = 0;
        }
        this.x = x2;
        this.y = y2;
        this.width = halfWidth;
        this.height = halfHeight;
        this.type = exports.SHAPES.ELIP;
      }
      Ellipse2.prototype.clone = function() {
        return new Ellipse2(this.x, this.y, this.width, this.height);
      };
      Ellipse2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var normx = (x2 - this.x) / this.width;
        var normy = (y2 - this.y) / this.height;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      };
      Ellipse2.prototype.getBounds = function() {
        return new Rectangle3(this.x - this.width, this.y - this.height, this.width, this.height);
      };
      Ellipse2.prototype.toString = function() {
        return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      };
      return Ellipse2;
    }();
    var Polygon = function() {
      function Polygon2() {
        var arguments$1 = arguments;
        var points = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          points[_i] = arguments$1[_i];
        }
        var flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          var p2 = [];
          for (var i2 = 0, il = flat.length; i2 < il; i2++) {
            p2.push(flat[i2].x, flat[i2].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.type = exports.SHAPES.POLY;
        this.closeStroke = true;
      }
      Polygon2.prototype.clone = function() {
        var points = this.points.slice();
        var polygon = new Polygon2(points);
        polygon.closeStroke = this.closeStroke;
        return polygon;
      };
      Polygon2.prototype.contains = function(x2, y2) {
        var inside = false;
        var length = this.points.length / 2;
        for (var i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
          var xi = this.points[i2 * 2];
          var yi = this.points[i2 * 2 + 1];
          var xj = this.points[j2 * 2];
          var yj = this.points[j2 * 2 + 1];
          var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      };
      Polygon2.prototype.toString = function() {
        return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
          return pointsDesc + ", " + currentPoint;
        }, "") + "]");
      };
      return Polygon2;
    }();
    var RoundedRectangle = function() {
      function RoundedRectangle2(x2, y2, width, height, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        if (radius === void 0) {
          radius = 20;
        }
        this.x = x2;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
        this.type = exports.SHAPES.RREC;
      }
      RoundedRectangle2.prototype.clone = function() {
        return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
      };
      RoundedRectangle2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            if (y2 >= this.y + this.radius && y2 <= this.y + this.height - this.radius || x2 >= this.x + this.radius && x2 <= this.x + this.width - this.radius) {
              return true;
            }
            var dx = x2 - (this.x + this.radius);
            var dy = y2 - (this.y + this.radius);
            var radius2 = this.radius * this.radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      };
      RoundedRectangle2.prototype.toString = function() {
        return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
      };
      return RoundedRectangle2;
    }();
    var Point2 = function() {
      function Point3(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this.x = x2;
        this.y = y2;
      }
      Point3.prototype.clone = function() {
        return new Point3(this.x, this.y);
      };
      Point3.prototype.copyFrom = function(p2) {
        this.set(p2.x, p2.y);
        return this;
      };
      Point3.prototype.copyTo = function(p2) {
        p2.set(this.x, this.y);
        return p2;
      };
      Point3.prototype.equals = function(p2) {
        return p2.x === this.x && p2.y === this.y;
      };
      Point3.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        this.x = x2;
        this.y = y2;
        return this;
      };
      Point3.prototype.toString = function() {
        return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
      };
      return Point3;
    }();
    var ObservablePoint = function() {
      function ObservablePoint2(cb, scope, x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this._x = x2;
        this._y = y2;
        this.cb = cb;
        this.scope = scope;
      }
      ObservablePoint2.prototype.clone = function(cb, scope) {
        if (cb === void 0) {
          cb = this.cb;
        }
        if (scope === void 0) {
          scope = this.scope;
        }
        return new ObservablePoint2(cb, scope, this._x, this._y);
      };
      ObservablePoint2.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        if (this._x !== x2 || this._y !== y2) {
          this._x = x2;
          this._y = y2;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyFrom = function(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyTo = function(p2) {
        p2.set(this._x, this._y);
        return p2;
      };
      ObservablePoint2.prototype.equals = function(p2) {
        return p2.x === this._x && p2.y === this._y;
      };
      ObservablePoint2.prototype.toString = function() {
        return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
      };
      Object.defineProperty(ObservablePoint2.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(value) {
          if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservablePoint2.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(value) {
          if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      return ObservablePoint2;
    }();
    var Matrix = function() {
      function Matrix2(a2, b2, c2, d2, tx, ty) {
        if (a2 === void 0) {
          a2 = 1;
        }
        if (b2 === void 0) {
          b2 = 0;
        }
        if (c2 === void 0) {
          c2 = 0;
        }
        if (d2 === void 0) {
          d2 = 1;
        }
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.array = null;
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
      }
      Matrix2.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix2.prototype.set = function(a2, b2, c2, d2, tx, ty) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
        return this;
      };
      Matrix2.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix2.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point2();
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.a * x2 + this.c * y2 + this.tx;
        newPos.y = this.b * x2 + this.d * y2 + this.ty;
        return newPos;
      };
      Matrix2.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point2();
        var id = 1 / (this.a * this.d + this.c * -this.b);
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
        return newPos;
      };
      Matrix2.prototype.translate = function(x2, y2) {
        this.tx += x2;
        this.ty += y2;
        return this;
      };
      Matrix2.prototype.scale = function(x2, y2) {
        this.a *= x2;
        this.d *= y2;
        this.c *= x2;
        this.b *= y2;
        this.tx *= x2;
        this.ty *= y2;
        return this;
      };
      Matrix2.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix2.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      };
      Matrix2.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix2.prototype.decompose = function(transform) {
        var a2 = this.a;
        var b2 = this.b;
        var c2 = this.c;
        var d2 = this.d;
        var pivot = transform.pivot;
        var skewX = -Math.atan2(-c2, d2);
        var skewY = Math.atan2(b2, a2);
        var delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
        transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
        transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
        return transform;
      };
      Matrix2.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      };
      Matrix2.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix2.prototype.clone = function() {
        var matrix = new Matrix2();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyTo = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyFrom = function(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      };
      Matrix2.prototype.toString = function() {
        return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
      };
      Object.defineProperty(Matrix2, "IDENTITY", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix2, "TEMP_MATRIX", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      return Matrix2;
    }();
    var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    var rotationCayley = [];
    var rotationMatrices = [];
    var signum = Math.sign;
    function init() {
      for (var i2 = 0; i2 < 16; i2++) {
        var row = [];
        rotationCayley.push(row);
        for (var j2 = 0; j2 < 16; j2++) {
          var _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
          var _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
          var _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
          var _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
          for (var k2 = 0; k2 < 16; k2++) {
            if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
              row.push(k2);
              break;
            }
          }
        }
      }
      for (var i2 = 0; i2 < 16; i2++) {
        var mat = new Matrix();
        mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
        rotationMatrices.push(mat);
      }
    }
    init();
    var groupD8 = {
      E: 0,
      SE: 1,
      S: 2,
      SW: 3,
      W: 4,
      NW: 5,
      N: 6,
      NE: 7,
      MIRROR_VERTICAL: 8,
      MAIN_DIAGONAL: 10,
      MIRROR_HORIZONTAL: 12,
      REVERSE_DIAGONAL: 14,
      uX: function(ind) {
        return ux[ind];
      },
      uY: function(ind) {
        return uy[ind];
      },
      vX: function(ind) {
        return vx[ind];
      },
      vY: function(ind) {
        return vy[ind];
      },
      inv: function(rotation) {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      add: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][rotationFirst];
      },
      sub: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
      },
      rotate180: function(rotation) {
        return rotation ^ 4;
      },
      isVertical: function(rotation) {
        return (rotation & 3) === 2;
      },
      byDirection: function(dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        var mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
    var Transform = function() {
      function Transform2() {
        this.worldTransform = new Matrix();
        this.localTransform = new Matrix();
        this.position = new ObservablePoint(this.onChange, this, 0, 0);
        this.scale = new ObservablePoint(this.onChange, this, 1, 1);
        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
      }
      Transform2.prototype.onChange = function() {
        this._localID++;
      };
      Transform2.prototype.updateSkew = function() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this._localID++;
      };
      Transform2.prototype.toString = function() {
        return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
      };
      Transform2.prototype.updateLocalTransform = function() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
      };
      Transform2.prototype.updateTransform = function(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
          var pt = parentTransform.worldTransform;
          var wt = this.worldTransform;
          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
          this._parentID = parentTransform._worldID;
          this._worldID++;
        }
      };
      Transform2.prototype.setFromMatrix = function(matrix) {
        matrix.decompose(this);
        this._localID++;
      };
      Object.defineProperty(Transform2.prototype, "rotation", {
        get: function() {
          return this._rotation;
        },
        set: function(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
          }
        },
        enumerable: false,
        configurable: true
      });
      Transform2.IDENTITY = new Transform2();
      return Transform2;
    }();
    exports.Circle = Circle;
    exports.DEG_TO_RAD = DEG_TO_RAD;
    exports.Ellipse = Ellipse;
    exports.Matrix = Matrix;
    exports.ObservablePoint = ObservablePoint;
    exports.PI_2 = PI_2;
    exports.Point = Point2;
    exports.Polygon = Polygon;
    exports.RAD_TO_DEG = RAD_TO_DEG;
    exports.Rectangle = Rectangle3;
    exports.RoundedRectangle = RoundedRectangle;
    exports.Transform = Transform;
    exports.groupD8 = groupD8;
  });

  // node_modules/@pixi/core/dist/cjs/core.js
  var require_core = __commonJS((exports) => {
    /*!
     * @pixi/core - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/core is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var settings2 = require_settings();
    var constants = require_constants();
    var utils6 = require_utils();
    var runner = require_runner();
    var ticker = require_ticker();
    var math = require_math();
    settings2.settings.PREFER_ENV = utils6.isMobile.any ? constants.ENV.WEBGL : constants.ENV.WEBGL2;
    settings2.settings.STRICT_TEXTURE_CACHE = false;
    var INSTALLED = [];
    function autoDetectResource(source, options) {
      if (!source) {
        return null;
      }
      var extension = "";
      if (typeof source === "string") {
        var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
        if (result) {
          extension = result[1].toLowerCase();
        }
      }
      for (var i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
        var ResourcePlugin = INSTALLED[i2];
        if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
          return new ResourcePlugin(source, options);
        }
      }
      throw new Error("Unrecognized source type to auto-detect Resource");
    }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var Resource = function() {
      function Resource2(width, height) {
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this._width = width;
        this._height = height;
        this.destroyed = false;
        this.internal = false;
        this.onResize = new runner.Runner("setRealSize");
        this.onUpdate = new runner.Runner("update");
        this.onError = new runner.Runner("onError");
      }
      Resource2.prototype.bind = function(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        this.onError.add(baseTexture);
        if (this._width || this._height) {
          this.onResize.emit(this._width, this._height);
        }
      };
      Resource2.prototype.unbind = function(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        this.onError.remove(baseTexture);
      };
      Resource2.prototype.resize = function(width, height) {
        if (width !== this._width || height !== this._height) {
          this._width = width;
          this._height = height;
          this.onResize.emit(width, height);
        }
      };
      Object.defineProperty(Resource2.prototype, "valid", {
        get: function() {
          return !!this._width && !!this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.update = function() {
        if (!this.destroyed) {
          this.onUpdate.emit();
        }
      };
      Resource2.prototype.load = function() {
        return Promise.resolve(this);
      };
      Object.defineProperty(Resource2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resource2.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
        return false;
      };
      Resource2.prototype.dispose = function() {
      };
      Resource2.prototype.destroy = function() {
        if (!this.destroyed) {
          this.destroyed = true;
          this.dispose();
          this.onError.removeAll();
          this.onError = null;
          this.onResize.removeAll();
          this.onResize = null;
          this.onUpdate.removeAll();
          this.onUpdate = null;
        }
      };
      Resource2.test = function(_source, _extension) {
        return false;
      };
      return Resource2;
    }();
    var BufferResource = function(_super) {
      __extends(BufferResource2, _super);
      function BufferResource2(source, options) {
        var _this = this;
        var _a = options || {}, width = _a.width, height = _a.height;
        if (!width || !height) {
          throw new Error("BufferResource width or height invalid");
        }
        _this = _super.call(this, width, height) || this;
        _this.data = source;
        return _this;
      }
      BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      BufferResource2.prototype.dispose = function() {
        this.data = null;
      };
      BufferResource2.test = function(source) {
        return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
      };
      return BufferResource2;
    }(Resource);
    var defaultBufferOptions = {
      scaleMode: constants.SCALE_MODES.NEAREST,
      format: constants.FORMATS.RGBA,
      alphaMode: constants.ALPHA_MODES.NPM
    };
    var BaseTexture = function(_super) {
      __extends(BaseTexture2, _super);
      function BaseTexture2(resource, options) {
        if (resource === void 0) {
          resource = null;
        }
        if (options === void 0) {
          options = null;
        }
        var _this = _super.call(this) || this;
        options = options || {};
        var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format = options.format, type2 = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
        if (resource && !(resource instanceof Resource)) {
          resource = autoDetectResource(resource, resourceOptions);
          resource.internal = true;
        }
        _this.width = width || 0;
        _this.height = height || 0;
        _this.resolution = resolution || settings2.settings.RESOLUTION;
        _this.mipmap = mipmap !== void 0 ? mipmap : settings2.settings.MIPMAP_TEXTURES;
        _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings2.settings.ANISOTROPIC_LEVEL;
        _this.wrapMode = wrapMode || settings2.settings.WRAP_MODE;
        _this.scaleMode = scaleMode !== void 0 ? scaleMode : settings2.settings.SCALE_MODE;
        _this.format = format || constants.FORMATS.RGBA;
        _this.type = type2 || constants.TYPES.UNSIGNED_BYTE;
        _this.target = target || constants.TARGETS.TEXTURE_2D;
        _this.alphaMode = alphaMode !== void 0 ? alphaMode : constants.ALPHA_MODES.UNPACK;
        _this.uid = utils6.uid();
        _this.touched = 0;
        _this.isPowerOfTwo = false;
        _this._refreshPOT();
        _this._glTextures = {};
        _this.dirtyId = 0;
        _this.dirtyStyleId = 0;
        _this.cacheId = null;
        _this.valid = width > 0 && height > 0;
        _this.textureCacheIds = [];
        _this.destroyed = false;
        _this.resource = null;
        _this._batchEnabled = 0;
        _this._batchLocation = 0;
        _this.parentTextureArray = null;
        _this.setResource(resource);
        return _this;
      }
      Object.defineProperty(BaseTexture2.prototype, "realWidth", {
        get: function() {
          return Math.ceil(this.width * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "realHeight", {
        get: function() {
          return Math.ceil(this.height * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
          this.scaleMode = scaleMode;
          dirty = true;
        }
        if (mipmap !== void 0 && mipmap !== this.mipmap) {
          this.mipmap = mipmap;
          dirty = true;
        }
        if (dirty) {
          this.dirtyStyleId++;
        }
        return this;
      };
      BaseTexture2.prototype.setSize = function(width, height, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype._refreshPOT = function() {
        this.isPowerOfTwo = utils6.isPow2(this.realWidth) && utils6.isPow2(this.realHeight);
      };
      BaseTexture2.prototype.setResolution = function(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
          return this;
        }
        this.resolution = resolution;
        if (this.valid) {
          this.width = this.width * oldResolution / resolution;
          this.height = this.height * oldResolution / resolution;
          this.emit("update", this);
        }
        this._refreshPOT();
        return this;
      };
      BaseTexture2.prototype.setResource = function(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw new Error("Resource can be set only once");
        }
        resource.bind(this);
        this.resource = resource;
        return this;
      };
      BaseTexture2.prototype.update = function() {
        if (!this.valid) {
          if (this.width > 0 && this.height > 0) {
            this.valid = true;
            this.emit("loaded", this);
            this.emit("update", this);
          }
        } else {
          this.dirtyId++;
          this.dirtyStyleId++;
          this.emit("update", this);
        }
      };
      BaseTexture2.prototype.onError = function(event) {
        this.emit("error", this, event);
      };
      BaseTexture2.prototype.destroy = function() {
        if (this.resource) {
          this.resource.unbind(this);
          if (this.resource.internal) {
            this.resource.destroy();
          }
          this.resource = null;
        }
        if (this.cacheId) {
          delete utils6.BaseTextureCache[this.cacheId];
          delete utils6.TextureCache[this.cacheId];
          this.cacheId = null;
        }
        this.dispose();
        BaseTexture2.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
      };
      BaseTexture2.prototype.dispose = function() {
        this.emit("dispose", this);
      };
      BaseTexture2.prototype.castToBaseTexture = function() {
        return this;
      };
      BaseTexture2.from = function(source, options, strict) {
        if (strict === void 0) {
          strict = settings2.settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + utils6.uid();
          }
          cacheId = source._pixiId;
        }
        var baseTexture = utils6.BaseTextureCache[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
        }
        if (!baseTexture) {
          baseTexture = new BaseTexture2(source, options);
          baseTexture.cacheId = cacheId;
          BaseTexture2.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
      };
      BaseTexture2.fromBuffer = function(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource(buffer, {width, height});
        var type2 = buffer instanceof Float32Array ? constants.TYPES.FLOAT : constants.TYPES.UNSIGNED_BYTE;
        return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || {width, height, type: type2}));
      };
      BaseTexture2.addToCache = function(baseTexture, id) {
        if (id) {
          if (baseTexture.textureCacheIds.indexOf(id) === -1) {
            baseTexture.textureCacheIds.push(id);
          }
          if (utils6.BaseTextureCache[id]) {
            console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
          }
          utils6.BaseTextureCache[id] = baseTexture;
        }
      };
      BaseTexture2.removeFromCache = function(baseTexture) {
        if (typeof baseTexture === "string") {
          var baseTextureFromCache = utils6.BaseTextureCache[baseTexture];
          if (baseTextureFromCache) {
            var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            if (index > -1) {
              baseTextureFromCache.textureCacheIds.splice(index, 1);
            }
            delete utils6.BaseTextureCache[baseTexture];
            return baseTextureFromCache;
          }
        } else if (baseTexture && baseTexture.textureCacheIds) {
          for (var i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
            delete utils6.BaseTextureCache[baseTexture.textureCacheIds[i2]];
          }
          baseTexture.textureCacheIds.length = 0;
          return baseTexture;
        }
        return null;
      };
      BaseTexture2._globalBatch = 0;
      return BaseTexture2;
    }(utils6.EventEmitter);
    var AbstractMultiResource = function(_super) {
      __extends(AbstractMultiResource2, _super);
      function AbstractMultiResource2(length, options) {
        var _this = this;
        var _a = options || {}, width = _a.width, height = _a.height;
        _this = _super.call(this, width, height) || this;
        _this.items = [];
        _this.itemDirtyIds = [];
        for (var i2 = 0; i2 < length; i2++) {
          var partTexture = new BaseTexture();
          _this.items.push(partTexture);
          _this.itemDirtyIds.push(-2);
        }
        _this.length = length;
        _this._load = null;
        _this.baseTexture = null;
        return _this;
      }
      AbstractMultiResource2.prototype.initFromArray = function(resources2, options) {
        for (var i2 = 0; i2 < this.length; i2++) {
          if (!resources2[i2]) {
            continue;
          }
          if (resources2[i2].castToBaseTexture) {
            this.addBaseTextureAt(resources2[i2].castToBaseTexture(), i2);
          } else if (resources2[i2] instanceof Resource) {
            this.addResourceAt(resources2[i2], i2);
          } else {
            this.addResourceAt(autoDetectResource(resources2[i2], options), i2);
          }
        }
      };
      AbstractMultiResource2.prototype.dispose = function() {
        for (var i2 = 0, len = this.length; i2 < len; i2++) {
          this.items[i2].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
      };
      AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (resource.valid && !this.valid) {
          this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
      };
      AbstractMultiResource2.prototype.bind = function(baseTexture) {
        if (this.baseTexture !== null) {
          throw new Error("Only one base texture per TextureArray is allowed");
        }
        _super.prototype.bind.call(this, baseTexture);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.items[i2].parentTextureArray = baseTexture;
          this.items[i2].on("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.unbind = function(baseTexture) {
        _super.prototype.unbind.call(this, baseTexture);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.items[i2].parentTextureArray = null;
          this.items[i2].off("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var resources2 = this.items.map(function(item) {
          return item.resource;
        }).filter(function(item) {
          return item;
        });
        var promises = resources2.map(function(item) {
          return item.load();
        });
        this._load = Promise.all(promises).then(function() {
          var _a = _this.items[0], realWidth = _a.realWidth, realHeight = _a.realHeight;
          _this.resize(realWidth, realHeight);
          return Promise.resolve(_this);
        });
        return this._load;
      };
      return AbstractMultiResource2;
    }(Resource);
    var ArrayResource = function(_super) {
      __extends(ArrayResource2, _super);
      function ArrayResource2(source, options) {
        var _this = this;
        var _a = options || {}, width = _a.width, height = _a.height;
        var urls;
        var length;
        if (Array.isArray(source)) {
          urls = source;
          length = source.length;
        } else {
          length = source;
        }
        _this = _super.call(this, length, {width, height}) || this;
        if (urls) {
          _this.initFromArray(urls, options);
        }
        return _this;
      }
      ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index);
        } else {
          throw new Error("ArrayResource does not support RenderTexture");
        }
        return this;
      };
      ArrayResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;
      };
      ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
        var _a = this, length = _a.length, itemDirtyIds = _a.itemDirtyIds, items = _a.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
          gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i2 = 0; i2 < length; i2++) {
          var item = items[i2];
          if (itemDirtyIds[i2] < item.dirtyId) {
            itemDirtyIds[i2] = item.dirtyId;
            if (item.valid) {
              gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i2, item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source);
            }
          }
        }
        return true;
      };
      return ArrayResource2;
    }(AbstractMultiResource);
    var BaseImageResource = function(_super) {
      __extends(BaseImageResource2, _super);
      function BaseImageResource2(source) {
        var _this = this;
        var sourceAny = source;
        var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
        var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
        _this = _super.call(this, width, height) || this;
        _this.source = source;
        _this.noSubImage = false;
        return _this;
      }
      BaseImageResource2.crossOrigin = function(element, url, crossorigin) {
        if (crossorigin === void 0 && url.indexOf("data:") !== 0) {
          element.crossOrigin = utils6.determineCrossOrigin(url);
        } else if (crossorigin !== false) {
          element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
        }
      };
      BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
        if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
      };
      BaseImageResource2.prototype.update = function() {
        if (this.destroyed) {
          return;
        }
        var source = this.source;
        var width = source.naturalWidth || source.videoWidth || source.width;
        var height = source.naturalHeight || source.videoHeight || source.height;
        this.resize(width, height);
        _super.prototype.update.call(this);
      };
      BaseImageResource2.prototype.dispose = function() {
        this.source = null;
      };
      return BaseImageResource2;
    }(Resource);
    var CanvasResource = function(_super) {
      __extends(CanvasResource2, _super);
      function CanvasResource2(source) {
        return _super.call(this, source) || this;
      }
      CanvasResource2.test = function(source) {
        var OffscreenCanvas2 = self.OffscreenCanvas;
        if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
          return true;
        }
        return self.HTMLCanvasElement && source instanceof HTMLCanvasElement;
      };
      return CanvasResource2;
    }(BaseImageResource);
    var CubeResource = function(_super) {
      __extends(CubeResource2, _super);
      function CubeResource2(source, options) {
        var _this = this;
        var _a = options || {}, width = _a.width, height = _a.height, autoLoad = _a.autoLoad, linkBaseTexture = _a.linkBaseTexture;
        if (source && source.length !== CubeResource2.SIDES) {
          throw new Error("Invalid length. Got " + source.length + ", expected 6");
        }
        _this = _super.call(this, 6, {width, height}) || this;
        for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
          _this.items[i2].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
        }
        _this.linkBaseTexture = linkBaseTexture !== false;
        if (source) {
          _this.initFromArray(source, options);
        }
        if (autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      CubeResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;
      };
      CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
        if (linkBaseTexture === void 0) {
          linkBaseTexture = this.linkBaseTexture;
        }
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
          if (baseTexture.resource) {
            this.addResourceAt(baseTexture.resource, index);
          } else {
            throw new Error("CubeResource does not support copying of renderTexture.");
          }
        } else {
          baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
          baseTexture.parentTextureArray = this.baseTexture;
          this.items[index] = baseTexture;
        }
        if (baseTexture.valid && !this.valid) {
          this.resize(baseTexture.realWidth, baseTexture.realHeight);
        }
        this.items[index] = baseTexture;
        return this;
      };
      CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
          var side = this.items[i2];
          if (dirty[i2] < side.dirtyId) {
            if (side.valid && side.resource) {
              side.resource.upload(renderer, side, glTexture);
              dirty[i2] = side.dirtyId;
            } else if (dirty[i2] < -1) {
              renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
              dirty[i2] = -1;
            }
          }
        }
        return true;
      };
      CubeResource2.test = function(source) {
        return Array.isArray(source) && source.length === CubeResource2.SIDES;
      };
      CubeResource2.SIDES = 6;
      return CubeResource2;
    }(AbstractMultiResource);
    var ImageResource = function(_super) {
      __extends(ImageResource2, _super);
      function ImageResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLImageElement)) {
          var imageElement = new Image();
          BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
          imageElement.src = source;
          source = imageElement;
        }
        _this = _super.call(this, source) || this;
        if (!source.complete && !!_this._width && !!_this._height) {
          _this._width = 0;
          _this._height = 0;
        }
        _this.url = source.src;
        _this._process = null;
        _this.preserveBitmap = false;
        _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings2.settings.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap;
        _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
        _this.bitmap = null;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      ImageResource2.prototype.load = function(createBitmap) {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        if (createBitmap !== void 0) {
          this.createBitmap = createBitmap;
        }
        this._load = new Promise(function(resolve, reject) {
          var source = _this.source;
          _this.url = source.src;
          var completed = function() {
            if (_this.destroyed) {
              return;
            }
            source.onload = null;
            source.onerror = null;
            _this.resize(source.width, source.height);
            _this._load = null;
            if (_this.createBitmap) {
              resolve(_this.process());
            } else {
              resolve(_this);
            }
          };
          if (source.complete && source.src) {
            completed();
          } else {
            source.onload = completed;
            source.onerror = function(event) {
              reject(event);
              _this.onError.emit(event);
            };
          }
        });
        return this._load;
      };
      ImageResource2.prototype.process = function() {
        var _this = this;
        var source = this.source;
        if (this._process !== null) {
          return this._process;
        }
        if (this.bitmap !== null || !self.createImageBitmap) {
          return Promise.resolve(this);
        }
        this._process = self.createImageBitmap(source, 0, 0, source.width, source.height, {
          premultiplyAlpha: this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
        }).then(function(bitmap) {
          if (_this.destroyed) {
            return Promise.reject();
          }
          _this.bitmap = bitmap;
          _this.update();
          _this._process = null;
          return Promise.resolve(_this);
        });
        return this._process;
      };
      ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        if (typeof this.alphaMode === "number") {
          baseTexture.alphaMode = this.alphaMode;
        }
        if (!this.createBitmap) {
          return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
          this.process();
          if (!this.bitmap) {
            return false;
          }
        }
        _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
          var flag = true;
          var glTextures = baseTexture._glTextures;
          for (var key in glTextures) {
            var otherTex = glTextures[key];
            if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
              flag = false;
              break;
            }
          }
          if (flag) {
            if (this.bitmap.close) {
              this.bitmap.close();
            }
            this.bitmap = null;
          }
        }
        return true;
      };
      ImageResource2.prototype.dispose = function() {
        this.source.onload = null;
        this.source.onerror = null;
        _super.prototype.dispose.call(this);
        if (this.bitmap) {
          this.bitmap.close();
          this.bitmap = null;
        }
        this._process = null;
        this._load = null;
      };
      ImageResource2.test = function(source) {
        return typeof source === "string" || source instanceof HTMLImageElement;
      };
      return ImageResource2;
    }(BaseImageResource);
    var SVGResource = function(_super) {
      __extends(SVGResource2, _super);
      function SVGResource2(sourceBase64, options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, document.createElement("canvas")) || this;
        _this._width = 0;
        _this._height = 0;
        _this.svg = sourceBase64;
        _this.scale = options.scale || 1;
        _this._overrideWidth = options.width;
        _this._overrideHeight = options.height;
        _this._resolve = null;
        _this._crossorigin = options.crossorigin;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      SVGResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        this._load = new Promise(function(resolve) {
          _this._resolve = function() {
            _this.resize(_this.source.width, _this.source.height);
            resolve(_this);
          };
          if (/^\<svg/.test(_this.svg.trim())) {
            if (!btoa) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
          }
          _this._loadSvg();
        });
        return this._load;
      };
      SVGResource2.prototype._loadSvg = function() {
        var _this = this;
        var tempImage = new Image();
        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;
        tempImage.onerror = function(event) {
          if (!_this._resolve) {
            return;
          }
          tempImage.onerror = null;
          _this.onError.emit(event);
        };
        tempImage.onload = function() {
          if (!_this._resolve) {
            return;
          }
          var svgWidth = tempImage.width;
          var svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width = svgWidth * _this.scale;
          var height = svgHeight * _this.scale;
          if (_this._overrideWidth || _this._overrideHeight) {
            width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
            height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
          }
          width = Math.round(width);
          height = Math.round(height);
          var canvas = _this.source;
          canvas.width = width;
          canvas.height = height;
          canvas._pixiId = "canvas_" + utils6.uid();
          canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
          _this._resolve();
          _this._resolve = null;
        };
      };
      SVGResource2.getSize = function(svgString) {
        var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
          size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
      };
      SVGResource2.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
      };
      SVGResource2.test = function(source, extension) {
        return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && source.indexOf("<svg") === 0;
      };
      SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      return SVGResource2;
    }(BaseImageResource);
    var VideoResource = function(_super) {
      __extends(VideoResource2, _super);
      function VideoResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLVideoElement)) {
          var videoElement = document.createElement("video");
          videoElement.setAttribute("preload", "auto");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("playsinline", "");
          if (typeof source === "string") {
            source = [source];
          }
          var firstSrc = source[0].src || source[0];
          BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
          for (var i2 = 0; i2 < source.length; ++i2) {
            var sourceElement = document.createElement("source");
            var _a = source[i2], src = _a.src, mime = _a.mime;
            src = src || source[i2];
            var baseSrc = src.split("?").shift().toLowerCase();
            var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
            mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
            sourceElement.src = src;
            sourceElement.type = mime;
            videoElement.appendChild(sourceElement);
          }
          source = videoElement;
        }
        _this = _super.call(this, source) || this;
        _this.noSubImage = true;
        _this._autoUpdate = true;
        _this._isConnectedToTicker = false;
        _this._updateFPS = options.updateFPS || 0;
        _this._msToNextUpdate = 0;
        _this.autoPlay = options.autoPlay !== false;
        _this._load = null;
        _this._resolve = null;
        _this._onCanPlay = _this._onCanPlay.bind(_this);
        _this._onError = _this._onError.bind(_this);
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      VideoResource2.prototype.update = function(_deltaTime) {
        if (!this.destroyed) {
          var elapsedMS = ticker.Ticker.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            _super.prototype.update.call(this);
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
        }
      };
      VideoResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        source.addEventListener("play", this._onPlayStart.bind(this));
        source.addEventListener("pause", this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
          source.addEventListener("canplay", this._onCanPlay);
          source.addEventListener("canplaythrough", this._onCanPlay);
          source.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this._load = new Promise(function(resolve) {
          if (_this.valid) {
            resolve(_this);
          } else {
            _this._resolve = resolve;
            source.load();
          }
        });
        return this._load;
      };
      VideoResource2.prototype._onError = function(event) {
        this.source.removeEventListener("error", this._onError, true);
        this.onError.emit(event);
      };
      VideoResource2.prototype._isSourcePlaying = function() {
        var source = this.source;
        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
      };
      VideoResource2.prototype._isSourceReady = function() {
        var source = this.source;
        return source.readyState === 3 || source.readyState === 4;
      };
      VideoResource2.prototype._onPlayStart = function() {
        if (!this.valid) {
          this._onCanPlay();
        }
        if (this.autoUpdate && !this._isConnectedToTicker) {
          ticker.Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      };
      VideoResource2.prototype._onPlayStop = function() {
        if (this._isConnectedToTicker) {
          ticker.Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      VideoResource2.prototype._onCanPlay = function() {
        var source = this.source;
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        if (!valid && this._resolve) {
          this._resolve(this);
          this._resolve = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          source.play();
        }
      };
      VideoResource2.prototype.dispose = function() {
        if (this._isConnectedToTicker) {
          ticker.Ticker.shared.remove(this.update, this);
        }
        var source = this.source;
        if (source) {
          source.removeEventListener("error", this._onError, true);
          source.pause();
          source.src = "";
          source.load();
        }
        _super.prototype.dispose.call(this);
      };
      Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              ticker.Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
              ticker.Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(VideoResource2.prototype, "updateFPS", {
        get: function() {
          return this._updateFPS;
        },
        set: function(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      VideoResource2.test = function(source, extension) {
        return self.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
      };
      VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
      VideoResource2.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      return VideoResource2;
    }(BaseImageResource);
    var ImageBitmapResource = function(_super) {
      __extends(ImageBitmapResource2, _super);
      function ImageBitmapResource2(source) {
        return _super.call(this, source) || this;
      }
      ImageBitmapResource2.test = function(source) {
        return !!self.createImageBitmap && source instanceof ImageBitmap;
      };
      return ImageBitmapResource2;
    }(BaseImageResource);
    INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
    var _resources = {
      __proto__: null,
      Resource,
      BaseImageResource,
      INSTALLED,
      autoDetectResource,
      AbstractMultiResource,
      ArrayResource,
      BufferResource,
      CanvasResource,
      CubeResource,
      ImageResource,
      SVGResource,
      VideoResource,
      ImageBitmapResource
    };
    var System = function() {
      function System2(renderer) {
        this.renderer = renderer;
      }
      System2.prototype.destroy = function() {
        this.renderer = null;
      };
      return System2;
    }();
    var DepthResource = function(_super) {
      __extends(DepthResource2, _super);
      function DepthResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, renderer.context.webGLVersion === 1 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16, width, height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
      };
      return DepthResource2;
    }(BufferResource);
    var Framebuffer = function() {
      function Framebuffer2(width, height) {
        this.width = Math.ceil(width || 100);
        this.height = Math.ceil(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new runner.Runner("disposeFramebuffer");
        this.multisample = constants.MSAA_QUALITY.NONE;
      }
      Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
        get: function() {
          return this.colorTextures[0];
        },
        enumerable: false,
        configurable: true
      });
      Framebuffer2.prototype.addColorTexture = function(index, texture) {
        if (index === void 0) {
          index = 0;
        }
        this.colorTextures[index] = texture || new BaseTexture(null, {
          scaleMode: constants.SCALE_MODES.NEAREST,
          resolution: 1,
          mipmap: constants.MIPMAP_MODES.OFF,
          width: this.width,
          height: this.height
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.addDepthTexture = function(texture) {
        this.depthTexture = texture || new BaseTexture(new DepthResource(null, {width: this.width, height: this.height}), {
          scaleMode: constants.SCALE_MODES.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: constants.MIPMAP_MODES.OFF,
          format: constants.FORMATS.DEPTH_COMPONENT,
          type: constants.TYPES.UNSIGNED_SHORT
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableDepth = function() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableStencil = function() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.resize = function(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        if (width === this.width && height === this.height) {
          return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
          var texture = this.colorTextures[i2];
          var resolution = texture.resolution;
          texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
          var resolution = this.depthTexture.resolution;
          this.depthTexture.setSize(width / resolution, height / resolution);
        }
      };
      Framebuffer2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Framebuffer2.prototype.destroyDepthTexture = function() {
        if (this.depthTexture) {
          this.depthTexture.destroy();
          this.depthTexture = null;
          ++this.dirtyId;
          ++this.dirtyFormat;
        }
      };
      return Framebuffer2;
    }();
    var BaseRenderTexture = function(_super) {
      __extends(BaseRenderTexture2, _super);
      function BaseRenderTexture2(options) {
        var _this = this;
        if (typeof options === "number") {
          var width_1 = arguments[0];
          var height_1 = arguments[1];
          var scaleMode = arguments[2];
          var resolution = arguments[3];
          options = {width: width_1, height: height_1, scaleMode, resolution};
        }
        _this = _super.call(this, null, options) || this;
        var _a = options || {}, width = _a.width, height = _a.height;
        _this.mipmap = 0;
        _this.width = Math.ceil(width) || 100;
        _this.height = Math.ceil(height) || 100;
        _this.valid = true;
        _this.clearColor = [0, 0, 0, 0];
        _this.framebuffer = new Framebuffer(_this.width * _this.resolution, _this.height * _this.resolution).addColorTexture(0, _this);
        _this.maskStack = [];
        _this.filterStack = [{}];
        return _this;
      }
      BaseRenderTexture2.prototype.resize = function(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
      };
      BaseRenderTexture2.prototype.dispose = function() {
        this.framebuffer.dispose();
        _super.prototype.dispose.call(this);
      };
      BaseRenderTexture2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.framebuffer.destroyDepthTexture();
        this.framebuffer = null;
      };
      return BaseRenderTexture2;
    }(BaseTexture);
    var TextureUvs = function() {
      function TextureUvs2() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
          var w2 = frame.width / 2 / tw;
          var h2 = frame.height / 2 / th;
          var cX = frame.x / tw + w2;
          var cY = frame.y / th + h2;
          rotate = math.groupD8.add(rotate, math.groupD8.NW);
          this.x0 = cX + w2 * math.groupD8.uX(rotate);
          this.y0 = cY + h2 * math.groupD8.uY(rotate);
          rotate = math.groupD8.add(rotate, 2);
          this.x1 = cX + w2 * math.groupD8.uX(rotate);
          this.y1 = cY + h2 * math.groupD8.uY(rotate);
          rotate = math.groupD8.add(rotate, 2);
          this.x2 = cX + w2 * math.groupD8.uX(rotate);
          this.y2 = cY + h2 * math.groupD8.uY(rotate);
          rotate = math.groupD8.add(rotate, 2);
          this.x3 = cX + w2 * math.groupD8.uX(rotate);
          this.y3 = cY + h2 * math.groupD8.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      };
      TextureUvs2.prototype.toString = function() {
        return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
      };
      return TextureUvs2;
    }();
    var DEFAULT_UVS = new TextureUvs();
    var Texture2 = function(_super) {
      __extends(Texture3, _super);
      function Texture3(baseTexture, frame, orig, trim, rotate, anchor) {
        var _this = _super.call(this) || this;
        _this.noFrame = false;
        if (!frame) {
          _this.noFrame = true;
          frame = new math.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture3) {
          baseTexture = baseTexture.baseTexture;
        }
        _this.baseTexture = baseTexture;
        _this._frame = frame;
        _this.trim = trim;
        _this.valid = false;
        _this._uvs = DEFAULT_UVS;
        _this.uvMatrix = null;
        _this.orig = orig || frame;
        _this._rotate = Number(rotate || 0);
        if (rotate === true) {
          _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        }
        _this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0);
        _this._updateID = 0;
        _this.textureCacheIds = [];
        if (!baseTexture.valid) {
          baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
        } else if (_this.noFrame) {
          if (baseTexture.valid) {
            _this.onBaseTextureUpdated(baseTexture);
          }
        } else {
          _this.frame = frame;
        }
        if (_this.noFrame) {
          baseTexture.on("update", _this.onBaseTextureUpdated, _this);
        }
        return _this;
      }
      Texture3.prototype.update = function() {
        if (this.baseTexture.resource) {
          this.baseTexture.resource.update();
        }
      };
      Texture3.prototype.onBaseTextureUpdated = function(baseTexture) {
        if (this.noFrame) {
          if (!this.baseTexture.valid) {
            return;
          }
          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;
          this.valid = true;
          this.updateUvs();
        } else {
          this.frame = this._frame;
        }
        this.emit("update", this);
      };
      Texture3.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            var resource = this.baseTexture.resource;
            if (resource && resource.url && utils6.TextureCache[resource.url]) {
              Texture3.removeFromCache(resource.url);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
          this.baseTexture.off("update", this.onBaseTextureUpdated, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture3.removeFromCache(this);
        this.textureCacheIds = null;
      };
      Texture3.prototype.clone = function() {
        var clonedFrame = this._frame.clone();
        var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
        var clonedTexture = new Texture3(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
        if (this.noFrame) {
          clonedTexture._frame = clonedFrame;
        }
        return clonedTexture;
      };
      Texture3.prototype.updateUvs = function() {
        if (this._uvs === DEFAULT_UVS) {
          this._uvs = new TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
      };
      Texture3.from = function(source, options, strict) {
        if (options === void 0) {
          options = {};
        }
        if (strict === void 0) {
          strict = settings2.settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + utils6.uid();
          }
          cacheId = source._pixiId;
        }
        var texture = utils6.TextureCache[cacheId];
        if (isFrame && strict && !texture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
        }
        if (!texture) {
          if (!options.resolution) {
            options.resolution = utils6.getResolutionOfUrl(source);
          }
          texture = new Texture3(new BaseTexture(source, options));
          texture.baseTexture.cacheId = cacheId;
          BaseTexture.addToCache(texture.baseTexture, cacheId);
          Texture3.addToCache(texture, cacheId);
        }
        return texture;
      };
      Texture3.fromURL = function(url, options) {
        var resourceOptions = Object.assign({autoLoad: false}, options === null || options === void 0 ? void 0 : options.resourceOptions);
        var texture = Texture3.from(url, Object.assign({resourceOptions}, options), false);
        var resource = texture.baseTexture.resource;
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return resource.load().then(function() {
          return Promise.resolve(texture);
        });
      };
      Texture3.fromBuffer = function(buffer, width, height, options) {
        return new Texture3(BaseTexture.fromBuffer(buffer, width, height, options));
      };
      Texture3.fromLoader = function(source, imageUrl, name2, options) {
        var baseTexture = new BaseTexture(source, Object.assign({
          scaleMode: settings2.settings.SCALE_MODE,
          resolution: utils6.getResolutionOfUrl(imageUrl)
        }, options));
        var resource = baseTexture.resource;
        if (resource instanceof ImageResource) {
          resource.url = imageUrl;
        }
        var texture = new Texture3(baseTexture);
        if (!name2) {
          name2 = imageUrl;
        }
        BaseTexture.addToCache(texture.baseTexture, name2);
        Texture3.addToCache(texture, name2);
        if (name2 !== imageUrl) {
          BaseTexture.addToCache(texture.baseTexture, imageUrl);
          Texture3.addToCache(texture, imageUrl);
        }
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return new Promise(function(resolve) {
          texture.baseTexture.once("loaded", function() {
            return resolve(texture);
          });
        });
      };
      Texture3.addToCache = function(texture, id) {
        if (id) {
          if (texture.textureCacheIds.indexOf(id) === -1) {
            texture.textureCacheIds.push(id);
          }
          if (utils6.TextureCache[id]) {
            console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
          }
          utils6.TextureCache[id] = texture;
        }
      };
      Texture3.removeFromCache = function(texture) {
        if (typeof texture === "string") {
          var textureFromCache = utils6.TextureCache[texture];
          if (textureFromCache) {
            var index = textureFromCache.textureCacheIds.indexOf(texture);
            if (index > -1) {
              textureFromCache.textureCacheIds.splice(index, 1);
            }
            delete utils6.TextureCache[texture];
            return textureFromCache;
          }
        } else if (texture && texture.textureCacheIds) {
          for (var i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
            if (utils6.TextureCache[texture.textureCacheIds[i2]] === texture) {
              delete utils6.TextureCache[texture.textureCacheIds[i2]];
            }
          }
          texture.textureCacheIds.length = 0;
          return texture;
        }
        return null;
      };
      Object.defineProperty(Texture3.prototype, "resolution", {
        get: function() {
          return this.baseTexture.resolution;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "frame", {
        get: function() {
          return this._frame;
        },
        set: function(frame) {
          this._frame = frame;
          this.noFrame = false;
          var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;
          var xNotFit = x2 + width > this.baseTexture.width;
          var yNotFit = y2 + height > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? "and" : "or";
            var errorX = "X: " + x2 + " + " + width + " = " + (x2 + width) + " > " + this.baseTexture.width;
            var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
          }
          this.valid = width && height && this.baseTexture.valid;
          if (!this.trim && !this.rotate) {
            this.orig = frame;
          }
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "rotate", {
        get: function() {
          return this._rotate;
        },
        set: function(rotate) {
          this._rotate = rotate;
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "width", {
        get: function() {
          return this.orig.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "height", {
        get: function() {
          return this.orig.height;
        },
        enumerable: false,
        configurable: true
      });
      Texture3.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      };
      return Texture3;
    }(utils6.EventEmitter);
    function createWhiteTexture() {
      var canvas = document.createElement("canvas");
      canvas.width = 16;
      canvas.height = 16;
      var context2 = canvas.getContext("2d");
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      return new Texture2(new BaseTexture(new CanvasResource(canvas)));
    }
    function removeAllHandlers(tex) {
      tex.destroy = function _emptyDestroy() {
      };
      tex.on = function _emptyOn() {
      };
      tex.once = function _emptyOnce() {
      };
      tex.emit = function _emptyEmit() {
      };
    }
    Texture2.EMPTY = new Texture2(new BaseTexture());
    removeAllHandlers(Texture2.EMPTY);
    removeAllHandlers(Texture2.EMPTY.baseTexture);
    Texture2.WHITE = createWhiteTexture();
    removeAllHandlers(Texture2.WHITE);
    removeAllHandlers(Texture2.WHITE.baseTexture);
    var RenderTexture = function(_super) {
      __extends(RenderTexture2, _super);
      function RenderTexture2(baseRenderTexture, frame) {
        var _this = _super.call(this, baseRenderTexture, frame) || this;
        _this.valid = true;
        _this.filterFrame = null;
        _this.filterPoolKey = null;
        _this.updateUvs();
        return _this;
      }
      Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
        get: function() {
          return this.baseTexture.framebuffer;
        },
        enumerable: false,
        configurable: true
      });
      RenderTexture2.prototype.resize = function(width, height, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
          resizeBaseTexture = true;
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.valid = width > 0 && height > 0;
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
          this.baseTexture.resize(width, height);
        }
        this.updateUvs();
      };
      RenderTexture2.prototype.setResolution = function(resolution) {
        var baseTexture = this.baseTexture;
        if (baseTexture.resolution === resolution) {
          return;
        }
        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
      };
      RenderTexture2.create = function(options) {
        var arguments$1 = arguments;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments$1[_i];
        }
        if (typeof options === "number") {
          utils6.deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
          options = {
            width: options,
            height: rest[0],
            scaleMode: rest[1],
            resolution: rest[2]
          };
        }
        return new RenderTexture2(new BaseRenderTexture(options));
      };
      return RenderTexture2;
    }(Texture2);
    var RenderTexturePool = function() {
      function RenderTexturePool2(textureOptions) {
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this._pixelsWidth = 0;
        this._pixelsHeight = 0;
      }
      RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight) {
        var baseRenderTexture = new BaseRenderTexture(Object.assign({
          width: realWidth,
          height: realHeight,
          resolution: 1
        }, this.textureOptions));
        return new RenderTexture(baseRenderTexture);
      };
      RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        var key = RenderTexturePool2.SCREEN_KEY;
        minWidth *= resolution;
        minHeight *= resolution;
        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
          minWidth = utils6.nextPow2(minWidth);
          minHeight = utils6.nextPow2(minHeight);
          key = (minWidth & 65535) << 16 | minHeight & 65535;
        }
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
          renderTexture = this.createTexture(minWidth, minHeight);
        }
        renderTexture.filterPoolKey = key;
        renderTexture.setResolution(resolution);
        return renderTexture;
      };
      RenderTexturePool2.prototype.getFilterTexture = function(input, resolution) {
        var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
      };
      RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
        this.returnTexture(renderTexture);
      };
      RenderTexturePool2.prototype.clear = function(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (var i2 in this.texturePool) {
            var textures = this.texturePool[i2];
            if (textures) {
              for (var j2 = 0; j2 < textures.length; j2++) {
                textures[j2].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      };
      RenderTexturePool2.prototype.setScreenSize = function(size) {
        if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
          return;
        }
        var screenKey = RenderTexturePool2.SCREEN_KEY;
        var textures = this.texturePool[screenKey];
        this.enableFullScreen = size.width > 0 && size.height > 0;
        if (textures) {
          for (var j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
        this.texturePool[screenKey] = [];
        this._pixelsWidth = size.width;
        this._pixelsHeight = size.height;
      };
      RenderTexturePool2.SCREEN_KEY = "screen";
      return RenderTexturePool2;
    }();
    var Attribute = function() {
      function Attribute2(buffer, size, normalized, type2, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (type2 === void 0) {
          type2 = 5126;
        }
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type2;
        this.stride = stride;
        this.start = start;
        this.instance = instance;
      }
      Attribute2.prototype.destroy = function() {
        this.buffer = null;
      };
      Attribute2.from = function(buffer, size, normalized, type2, stride) {
        return new Attribute2(buffer, size, normalized, type2, stride);
      };
      return Attribute2;
    }();
    var UID = 0;
    var Buffer2 = function() {
      function Buffer3(data, _static, index) {
        if (_static === void 0) {
          _static = true;
        }
        if (index === void 0) {
          index = false;
        }
        this.data = data || new Float32Array(1);
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = UID++;
        this.disposeRunner = new runner.Runner("disposeBuffer");
      }
      Buffer3.prototype.update = function(data) {
        this.data = data || this.data;
        this._updateID++;
      };
      Buffer3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Buffer3.prototype.destroy = function() {
        this.dispose();
        this.data = null;
      };
      Buffer3.from = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        return new Buffer3(data);
      };
      return Buffer3;
    }();
    function getBufferType(array) {
      if (array.BYTES_PER_ELEMENT === 4) {
        if (array instanceof Float32Array) {
          return "Float32Array";
        } else if (array instanceof Uint32Array) {
          return "Uint32Array";
        }
        return "Int32Array";
      } else if (array.BYTES_PER_ELEMENT === 2) {
        if (array instanceof Uint16Array) {
          return "Uint16Array";
        }
      } else if (array.BYTES_PER_ELEMENT === 1) {
        if (array instanceof Uint8Array) {
          return "Uint8Array";
        }
      }
      return null;
    }
    var map = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array
    };
    function interleaveTypedArrays(arrays, sizes) {
      var outSize = 0;
      var stride = 0;
      var views = {};
      for (var i2 = 0; i2 < arrays.length; i2++) {
        stride += sizes[i2];
        outSize += arrays[i2].length;
      }
      var buffer = new ArrayBuffer(outSize * 4);
      var out = null;
      var littleOffset = 0;
      for (var i2 = 0; i2 < arrays.length; i2++) {
        var size = sizes[i2];
        var array = arrays[i2];
        var type2 = getBufferType(array);
        if (!views[type2]) {
          views[type2] = new map[type2](buffer);
        }
        out = views[type2];
        for (var j2 = 0; j2 < array.length; j2++) {
          var indexStart = (j2 / size | 0) * stride + littleOffset;
          var index = j2 % size;
          out[indexStart + index] = array[j2];
        }
        littleOffset += size;
      }
      return new Float32Array(buffer);
    }
    var byteSizeMap = {5126: 4, 5123: 2, 5121: 1};
    var UID$1 = 0;
    var map$1 = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array,
      Uint16Array
    };
    var Geometry = function() {
      function Geometry2(buffers, attributes) {
        if (buffers === void 0) {
          buffers = [];
        }
        if (attributes === void 0) {
          attributes = {};
        }
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        this.glVertexArrayObjects = {};
        this.id = UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this.disposeRunner = new runner.Runner("disposeGeometry");
        this.refCount = 0;
      }
      Geometry2.prototype.addAttribute = function(id, buffer, size, normalized, type2, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (instance === void 0) {
          instance = false;
        }
        if (!buffer) {
          throw new Error("You must pass a buffer when creating an attribute");
        }
        if (!(buffer instanceof Buffer2)) {
          if (buffer instanceof Array) {
            buffer = new Float32Array(buffer);
          }
          buffer = new Buffer2(buffer);
        }
        var ids = id.split("|");
        if (ids.length > 1) {
          for (var i2 = 0; i2 < ids.length; i2++) {
            this.addAttribute(ids[i2], buffer, size, normalized, type2);
          }
          return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
          this.buffers.push(buffer);
          bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute(bufferIndex, size, normalized, type2, stride, start, instance);
        this.instanced = this.instanced || instance;
        return this;
      };
      Geometry2.prototype.getAttribute = function(id) {
        return this.attributes[id];
      };
      Geometry2.prototype.getBuffer = function(id) {
        return this.buffers[this.getAttribute(id).buffer];
      };
      Geometry2.prototype.addIndex = function(buffer) {
        if (!(buffer instanceof Buffer2)) {
          if (buffer instanceof Array) {
            buffer = new Uint16Array(buffer);
          }
          buffer = new Buffer2(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
          this.buffers.push(buffer);
        }
        return this;
      };
      Geometry2.prototype.getIndex = function() {
        return this.indexBuffer;
      };
      Geometry2.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
          return this;
        }
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer2();
        var i2;
        for (i2 in this.attributes) {
          var attribute = this.attributes[i2];
          var buffer = this.buffers[attribute.buffer];
          arrays.push(buffer.data);
          sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
          attribute.buffer = 0;
        }
        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
        for (i2 = 0; i2 < this.buffers.length; i2++) {
          if (this.buffers[i2] !== this.indexBuffer) {
            this.buffers[i2].destroy();
          }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
          this.buffers.push(this.indexBuffer);
        }
        return this;
      };
      Geometry2.prototype.getSize = function() {
        for (var i2 in this.attributes) {
          var attribute = this.attributes[i2];
          var buffer = this.buffers[attribute.buffer];
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      };
      Geometry2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Geometry2.prototype.destroy = function() {
        this.dispose();
        this.buffers = null;
        this.indexBuffer = null;
        this.attributes = null;
      };
      Geometry2.prototype.clone = function() {
        var geometry = new Geometry2();
        for (var i2 = 0; i2 < this.buffers.length; i2++) {
          geometry.buffers[i2] = new Buffer2(this.buffers[i2].data.slice(0));
        }
        for (var i2 in this.attributes) {
          var attrib = this.attributes[i2];
          geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
          geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
          geometry.indexBuffer.index = true;
        }
        return geometry;
      };
      Geometry2.merge = function(geometries) {
        var geometryOut = new Geometry2();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        for (var i2 = 0; i2 < geometries.length; i2++) {
          geometry = geometries[i2];
          for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
            sizes[j2] = sizes[j2] || 0;
            sizes[j2] += geometry.buffers[j2].data.length;
            offsets[j2] = 0;
          }
        }
        for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
          arrays[i2] = new map$1[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
          geometryOut.buffers[i2] = new Buffer2(arrays[i2]);
        }
        for (var i2 = 0; i2 < geometries.length; i2++) {
          geometry = geometries[i2];
          for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
            arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
            offsets[j2] += geometry.buffers[j2].data.length;
          }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
          geometryOut.indexBuffer.index = true;
          var offset = 0;
          var stride = 0;
          var offset2 = 0;
          var bufferIndexToCount = 0;
          for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
            if (geometry.buffers[i2] !== geometry.indexBuffer) {
              bufferIndexToCount = i2;
              break;
            }
          }
          for (var i2 in geometry.attributes) {
            var attribute = geometry.attributes[i2];
            if ((attribute.buffer | 0) === bufferIndexToCount) {
              stride += attribute.size * byteSizeMap[attribute.type] / 4;
            }
          }
          for (var i2 = 0; i2 < geometries.length; i2++) {
            var indexBufferData = geometries[i2].indexBuffer.data;
            for (var j2 = 0; j2 < indexBufferData.length; j2++) {
              geometryOut.indexBuffer.data[j2 + offset2] += offset;
            }
            offset += geometry.buffers[bufferIndexToCount].data.length / stride;
            offset2 += indexBufferData.length;
          }
        }
        return geometryOut;
      };
      return Geometry2;
    }();
    var Quad = function(_super) {
      __extends(Quad2, _super);
      function Quad2() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aVertexPosition", new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ])).addIndex([0, 1, 3, 2]);
        return _this;
      }
      return Quad2;
    }(Geometry);
    var QuadUv = function(_super) {
      __extends(QuadUv2, _super);
      function QuadUv2() {
        var _this = _super.call(this) || this;
        _this.vertices = new Float32Array([
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1
        ]);
        _this.uvs = new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]);
        _this.vertexBuffer = new Buffer2(_this.vertices);
        _this.uvBuffer = new Buffer2(_this.uvs);
        _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        return _this;
      }
      QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
        var x2 = 0;
        var y2 = 0;
        this.uvs[0] = x2;
        this.uvs[1] = y2;
        this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y2;
        this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
        this.uvs[6] = x2;
        this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
        x2 = destinationFrame.x;
        y2 = destinationFrame.y;
        this.vertices[0] = x2;
        this.vertices[1] = y2;
        this.vertices[2] = x2 + destinationFrame.width;
        this.vertices[3] = y2;
        this.vertices[4] = x2 + destinationFrame.width;
        this.vertices[5] = y2 + destinationFrame.height;
        this.vertices[6] = x2;
        this.vertices[7] = y2 + destinationFrame.height;
        this.invalidate();
        return this;
      };
      QuadUv2.prototype.invalidate = function() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
      };
      return QuadUv2;
    }(Geometry);
    var UID$2 = 0;
    var UniformGroup = function() {
      function UniformGroup2(uniforms, _static) {
        this.uniforms = uniforms;
        this.group = true;
        this.syncUniforms = {};
        this.dirtyId = 0;
        this.id = UID$2++;
        this.static = !!_static;
      }
      UniformGroup2.prototype.update = function() {
        this.dirtyId++;
      };
      UniformGroup2.prototype.add = function(name2, uniforms, _static) {
        this.uniforms[name2] = new UniformGroup2(uniforms, _static);
      };
      UniformGroup2.from = function(uniforms, _static) {
        return new UniformGroup2(uniforms, _static);
      };
      return UniformGroup2;
    }();
    var FilterState = function() {
      function FilterState2() {
        this.renderTexture = null;
        this.target = null;
        this.legacy = false;
        this.resolution = 1;
        this.sourceFrame = new math.Rectangle();
        this.destinationFrame = new math.Rectangle();
        this.bindingSourceFrame = new math.Rectangle();
        this.bindingDestinationFrame = new math.Rectangle();
        this.filters = [];
        this.transform = null;
      }
      FilterState2.prototype.clear = function() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
      };
      return FilterState2;
    }();
    var tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()];
    var tempMatrix = new math.Matrix();
    var FilterSystem = function(_super) {
      __extends(FilterSystem2, _super);
      function FilterSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.defaultFilterStack = [{}];
        _this.texturePool = new RenderTexturePool();
        _this.texturePool.setScreenSize(renderer.view);
        _this.statePool = [];
        _this.quad = new Quad();
        _this.quadUv = new QuadUv();
        _this.tempRect = new math.Rectangle();
        _this.activeState = {};
        _this.globalUniforms = new UniformGroup({
          outputFrame: new math.Rectangle(),
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4)
        }, true);
        _this.forceClear = false;
        _this.useMaxPadding = false;
        return _this;
      }
      FilterSystem2.prototype.push = function(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState();
        var renderTextureSystem = this.renderer.renderTexture;
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i2 = 1; i2 < filters.length; i2++) {
          var filter = filters[i2];
          resolution = Math.min(resolution, filter.resolution);
          padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
          autoFit = autoFit && filter.autoFit;
          legacy = legacy || filter.legacy;
        }
        if (filterStack.length === 1) {
          this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
          var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
          if (renderer.projection.transform) {
            this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
          }
          state.sourceFrame.fit(sourceFrameProjected);
        }
        this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        var destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = state.sourceFrame.width;
        destinationFrame.height = state.sourceFrame.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
        state.transform = renderer.projection.transform;
        renderer.projection.transform = null;
        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
        renderer.framebuffer.clear(0, 0, 0, 0);
      };
      FilterSystem2.prototype.pop = function() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
        if (state.legacy) {
          var filterArea = globalUniforms.filterArea;
          filterArea[0] = state.destinationFrame.width;
          filterArea[1] = state.destinationFrame.height;
          filterArea[2] = state.sourceFrame.x;
          filterArea[3] = state.sourceFrame.y;
          globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (state.renderTexture.framebuffer.multisample > 1) {
          this.renderer.framebuffer.blit();
        }
        if (filters.length === 1) {
          filters[0].apply(this, state.renderTexture, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
          this.returnFilterTexture(state.renderTexture);
        } else {
          var flip = state.renderTexture;
          var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
          var i2 = 0;
          for (i2 = 0; i2 < filters.length - 1; ++i2) {
            filters[i2].apply(this, flip, flop, constants.CLEAR_MODES.CLEAR, state);
            var t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i2].apply(this, flip, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
          this.returnFilterTexture(flip);
          this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
      };
      FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
        if (clearMode === void 0) {
          clearMode = constants.CLEAR_MODES.CLEAR;
        }
        var _a = this.renderer, renderTextureSystem = _a.renderTexture, stateSystem = _a.state;
        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          this.renderer.projection.transform = this.activeState.transform;
        } else {
          this.renderer.projection.transform = null;
        }
        if (filterTexture && filterTexture.filterFrame) {
          var destinationFrame = this.tempRect;
          destinationFrame.x = 0;
          destinationFrame.y = 0;
          destinationFrame.width = filterTexture.filterFrame.width;
          destinationFrame.height = filterTexture.filterFrame.height;
          renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
        } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          renderTextureSystem.bind(filterTexture);
        } else {
          this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        }
        var autoClear = stateSystem.stateId & 1 || this.forceClear;
        if (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && autoClear) {
          this.renderer.framebuffer.clear(0, 0, 0, 0);
        }
      };
      FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {
        var renderer = this.renderer;
        renderer.state.set(filter.state);
        this.bindAndClear(output, clearMode);
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        renderer.shader.bind(filter);
        if (filter.legacy) {
          this.quadUv.map(input._frame, input.filterFrame);
          renderer.geometry.bind(this.quadUv);
          renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES);
        } else {
          renderer.geometry.bind(this.quad);
          renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP);
        }
      };
      FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
        var _a = this.activeState, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / orig.width, 1 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterSystem2.prototype.destroy = function() {
        this.texturePool.clear(false);
      };
      FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
      };
      FilterSystem2.prototype.getFilterTexture = function(input, resolution) {
        if (typeof input === "number") {
          var swap = input;
          input = resolution;
          resolution = swap;
        }
        input = input || this.activeState.renderTexture;
        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
        this.texturePool.returnTexture(renderTexture);
      };
      FilterSystem2.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      };
      FilterSystem2.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      };
      FilterSystem2.prototype.transformAABB = function(matrix, rect) {
        var lt = tempPoints[0];
        var lb = tempPoints[1];
        var rt = tempPoints[2];
        var rb = tempPoints[3];
        lt.set(rect.left, rect.top);
        lb.set(rect.left, rect.bottom);
        rt.set(rect.right, rect.top);
        rb.set(rect.right, rect.bottom);
        matrix.apply(lt, lt);
        matrix.apply(lb, lb);
        matrix.apply(rt, rt);
        matrix.apply(rb, rb);
        var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
        var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
        var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
        var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
        rect.x = x0;
        rect.y = y0;
        rect.width = x1 - x0;
        rect.height = y1 - y0;
      };
      FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        if (transform) {
          var a2 = transform.a, b2 = transform.b, c2 = transform.c, d2 = transform.d;
          if ((b2 !== 0 || c2 !== 0) && (a2 !== 0 || d2 !== 0)) {
            return;
          }
        }
        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.transformAABB(transform, frame);
        frame.ceil(resolution);
        this.transformAABB(transform.invert(), frame);
      };
      return FilterSystem2;
    }(System);
    var ObjectRenderer = function() {
      function ObjectRenderer2(renderer) {
        this.renderer = renderer;
      }
      ObjectRenderer2.prototype.flush = function() {
      };
      ObjectRenderer2.prototype.destroy = function() {
        this.renderer = null;
      };
      ObjectRenderer2.prototype.start = function() {
      };
      ObjectRenderer2.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer2.prototype.render = function(_object) {
      };
      return ObjectRenderer2;
    }();
    var BatchSystem = function(_super) {
      __extends(BatchSystem2, _super);
      function BatchSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.emptyRenderer = new ObjectRenderer(renderer);
        _this.currentRenderer = _this.emptyRenderer;
        return _this;
      }
      BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      BatchSystem2.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
        var boundTextures = this.renderer.texture.boundTextures;
        for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
          arr[i2] = boundTextures[i2] || null;
          if (arr[i2]) {
            arr[i2]._batchLocation = i2;
          }
        }
      };
      BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
        var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
        var j2 = 0;
        for (var i2 = 0; i2 < count; i2++) {
          var tex = elements[i2];
          var loc = tex._batchLocation;
          if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
            ids[i2] = loc;
            continue;
          }
          while (j2 < maxTextures) {
            var bound = boundTextures[j2];
            if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
              j2++;
              continue;
            }
            ids[i2] = j2;
            tex._batchLocation = j2;
            boundTextures[j2] = tex;
            break;
          }
        }
      };
      return BatchSystem2;
    }(System);
    var CONTEXT_UID_COUNTER = 0;
    var ContextSystem = function(_super) {
      __extends(ContextSystem2, _super);
      function ContextSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.webGLVersion = 1;
        _this.extensions = {};
        _this.supports = {
          uint32Indices: false
        };
        _this.handleContextLost = _this.handleContextLost.bind(_this);
        _this.handleContextRestored = _this.handleContextRestored.bind(_this);
        renderer.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
        renderer.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);
        return _this;
      }
      Object.defineProperty(ContextSystem2.prototype, "isLost", {
        get: function() {
          return !this.gl || this.gl.isContextLost();
        },
        enumerable: false,
        configurable: true
      });
      ContextSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      };
      ContextSystem2.prototype.initFromContext = function(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        this.renderer.runners.contextChange.emit(gl);
      };
      ContextSystem2.prototype.initFromOptions = function(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
      };
      ContextSystem2.prototype.createContext = function(canvas, options) {
        var gl;
        if (settings2.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (gl) {
          this.webGLVersion = 2;
        } else {
          this.webGLVersion = 1;
          gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      };
      ContextSystem2.prototype.getExtensions = function() {
        var gl = this.gl;
        var common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        if (this.webGLVersion === 1) {
          Object.assign(this.extensions, common, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            loseContext: gl.getExtension("WEBGL_lose_context"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          });
        } else if (this.webGLVersion === 2) {
          Object.assign(this.extensions, common, {
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          });
        }
      };
      ContextSystem2.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      ContextSystem2.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      };
      ContextSystem2.prototype.destroy = function() {
        var view = this.renderer.view;
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      };
      ContextSystem2.prototype.postrender = function() {
        if (this.renderer.renderingToScreen) {
          this.gl.flush();
        }
      };
      ContextSystem2.prototype.validateContext = function(gl) {
        var attributes = gl.getContextAttributes();
        var isWebGl2 = "WebGL2RenderingContext" in self && gl instanceof self.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (!attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasuint32;
        if (!hasuint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      return ContextSystem2;
    }(System);
    var GLFramebuffer = function() {
      function GLFramebuffer2(framebuffer) {
        this.framebuffer = framebuffer;
        this.stencil = null;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.multisample = constants.MSAA_QUALITY.NONE;
        this.msaaBuffer = null;
        this.blitFramebuffer = null;
      }
      return GLFramebuffer2;
    }();
    var tempRectangle = new math.Rectangle();
    var FramebufferSystem = function(_super) {
      __extends(FramebufferSystem2, _super);
      function FramebufferSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.managedFramebuffers = [];
        _this.unknownFramebuffer = new Framebuffer(10, 10);
        _this.msaaSamples = null;
        return _this;
      }
      FramebufferSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new math.Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        if (this.renderer.context.webGLVersion === 1) {
          var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
          var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
          if (settings2.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
            nativeDrawBuffersExtension_1 = null;
            nativeDepthTextureExtension = null;
          }
          if (nativeDrawBuffersExtension_1) {
            gl.drawBuffers = function(activeTextures) {
              return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
            };
          } else {
            this.hasMRT = false;
            gl.drawBuffers = function() {
            };
          }
          if (!nativeDepthTextureExtension) {
            this.writeDepthTexture = false;
          }
        } else {
          this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
      };
      FramebufferSystem2.prototype.bind = function(framebuffer, frame) {
        var gl = this.gl;
        if (framebuffer) {
          var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
          if (this.current !== framebuffer) {
            this.current = framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
          }
          if (fbo.dirtyId !== framebuffer.dirtyId) {
            fbo.dirtyId = framebuffer.dirtyId;
            if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
              fbo.dirtyFormat = framebuffer.dirtyFormat;
              this.updateFramebuffer(framebuffer);
            } else if (fbo.dirtySize !== framebuffer.dirtySize) {
              fbo.dirtySize = framebuffer.dirtySize;
              this.resizeFramebuffer(framebuffer);
            }
          }
          for (var i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
            var tex = framebuffer.colorTextures[i2];
            this.renderer.texture.unbind(tex.parentTextureArray || tex);
          }
          if (framebuffer.depthTexture) {
            this.renderer.texture.unbind(framebuffer.depthTexture);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, framebuffer.width, framebuffer.height);
          }
        } else {
          if (this.current) {
            this.current = null;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }
        }
      };
      FramebufferSystem2.prototype.setViewport = function(x2, y2, width, height) {
        var v2 = this.viewport;
        if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
          v2.x = x2;
          v2.y = y2;
          v2.width = width;
          v2.height = height;
          this.gl.viewport(x2, y2, width, height);
        }
      };
      Object.defineProperty(FramebufferSystem2.prototype, "size", {
        get: function() {
          if (this.current) {
            return {x: 0, y: 0, width: this.current.width, height: this.current.height};
          }
          return {x: 0, y: 0, width: this.renderer.width, height: this.renderer.height};
        },
        enumerable: false,
        configurable: true
      });
      FramebufferSystem2.prototype.clear = function(r2, g2, b2, a2, mask) {
        if (mask === void 0) {
          mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH;
        }
        var gl = this.gl;
        gl.clearColor(r2, g2, b2, a2);
        gl.clear(mask);
      };
      FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = new GLFramebuffer(gl.createFramebuffer());
        fbo.multisample = this.detectSamples(framebuffer.multisample);
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
      };
      FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i2 = 0; i2 < colorTextures.length; i2++) {
          this.renderer.texture.bind(colorTextures[i2], 0);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
      };
      FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        if (fbo.multisample > 1) {
          fbo.msaaBuffer = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        }
        var activeTextures = [];
        for (var i2 = 0; i2 < count; i2++) {
          if (i2 === 0 && fbo.multisample > 1) {
            continue;
          }
          var texture = framebuffer.colorTextures[i2];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, 0);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
        }
        if (activeTextures.length > 1) {
          gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
          var writeDepthTexture = this.writeDepthTexture;
          if (writeDepthTexture) {
            var depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
          }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
          fbo.stencil = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          if (!framebuffer.depthTexture) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.detectSamples = function(samples) {
        var msaaSamples = this.msaaSamples;
        var res = constants.MSAA_QUALITY.NONE;
        if (samples <= 1 || msaaSamples === null) {
          return res;
        }
        for (var i2 = 0; i2 < msaaSamples.length; i2++) {
          if (msaaSamples[i2] <= samples) {
            res = msaaSamples[i2];
            break;
          }
        }
        if (res === 1) {
          res = constants.MSAA_QUALITY.NONE;
        }
        return res;
      };
      FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
        var _a = this, current = _a.current, renderer = _a.renderer, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
        if (renderer.context.webGLVersion !== 2) {
          return;
        }
        if (!current) {
          return;
        }
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (!fbo) {
          return;
        }
        if (!framebuffer) {
          if (fbo.multisample <= 1) {
            return;
          }
          if (!fbo.blitFramebuffer) {
            fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
            fbo.blitFramebuffer.addColorTexture(0, current.colorTextures[0]);
          }
          framebuffer = fbo.blitFramebuffer;
          framebuffer.width = current.width;
          framebuffer.height = current.height;
        }
        if (!sourcePixels) {
          sourcePixels = tempRectangle;
          sourcePixels.width = current.width;
          sourcePixels.height = current.height;
        }
        if (!destPixels) {
          destPixels = sourcePixels;
        }
        var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
        this.bind(framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
        gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
      };
      FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
          return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
          this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
          gl.deleteFramebuffer(fbo.framebuffer);
          if (fbo.stencil) {
            gl.deleteRenderbuffer(fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.disposeAll = function(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i2 = 0; i2 < list.length; i2++) {
          this.disposeFramebuffer(list[i2], contextLost);
        }
      };
      FramebufferSystem2.prototype.forceStencil = function() {
        var framebuffer = this.current;
        if (!framebuffer) {
          return;
        }
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!fbo || fbo.stencil) {
          return;
        }
        framebuffer.enableStencil();
        var w2 = framebuffer.width;
        var h2 = framebuffer.height;
        var gl = this.gl;
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
        fbo.stencil = stencil;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
      };
      FramebufferSystem2.prototype.reset = function() {
        this.current = this.unknownFramebuffer;
        this.viewport = new math.Rectangle();
      };
      return FramebufferSystem2;
    }(System);
    var GLBuffer = function() {
      function GLBuffer2(buffer) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
      }
      return GLBuffer2;
    }();
    var byteSizeMap$1 = {5126: 4, 5123: 2, 5121: 1};
    var GeometrySystem = function(_super) {
      __extends(GeometrySystem2, _super);
      function GeometrySystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this._activeGeometry = null;
        _this._activeVao = null;
        _this.hasVao = true;
        _this.hasInstance = true;
        _this.canUseUInt32ElementIndex = false;
        _this.managedGeometries = {};
        _this.managedBuffers = {};
        return _this;
      }
      GeometrySystem2.prototype.contextChange = function() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        var context2 = this.renderer.context;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        if (context2.webGLVersion !== 2) {
          var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
          if (settings2.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
            nativeVaoExtension_1 = null;
          }
          if (nativeVaoExtension_1) {
            gl.createVertexArray = function() {
              return nativeVaoExtension_1.createVertexArrayOES();
            };
            gl.bindVertexArray = function(vao) {
              return nativeVaoExtension_1.bindVertexArrayOES(vao);
            };
            gl.deleteVertexArray = function(vao) {
              return nativeVaoExtension_1.deleteVertexArrayOES(vao);
            };
          } else {
            this.hasVao = false;
            gl.createVertexArray = function() {
              return null;
            };
            gl.bindVertexArray = function() {
              return null;
            };
            gl.deleteVertexArray = function() {
              return null;
            };
          }
        }
        if (context2.webGLVersion !== 2) {
          var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExt_1) {
            gl.vertexAttribDivisor = function(a2, b2) {
              return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
            };
            gl.drawElementsInstanced = function(a2, b2, c2, d2, e2) {
              return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.drawArraysInstanced = function(a2, b2, c2, d2) {
              return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
          } else {
            this.hasInstance = false;
          }
        }
        this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
      };
      GeometrySystem2.prototype.bind = function(geometry, shader) {
        shader = shader || this.renderer.shader.shader;
        var gl = this.gl;
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var incRefCount = false;
        if (!vaos) {
          this.managedGeometries[geometry.id] = geometry;
          geometry.disposeRunner.add(this);
          geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
          incRefCount = true;
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program, incRefCount);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          if (this.hasVao) {
            gl.bindVertexArray(vao);
          } else {
            this.activateVao(geometry, shader.program);
          }
        }
        this.updateBuffers();
      };
      GeometrySystem2.prototype.reset = function() {
        this.unbind();
      };
      GeometrySystem2.prototype.updateBuffers = function() {
        var geometry = this._activeGeometry;
        var gl = this.gl;
        for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
          var buffer = geometry.buffers[i2];
          var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
          if (buffer._updateID !== glBuffer.updateID) {
            glBuffer.updateID = buffer._updateID;
            var type2 = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
            gl.bindBuffer(type2, glBuffer.buffer);
            this._boundBuffer = glBuffer;
            if (glBuffer.byteLength >= buffer.data.byteLength) {
              gl.bufferSubData(type2, 0, buffer.data);
            } else {
              var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
              glBuffer.byteLength = buffer.data.byteLength;
              gl.bufferData(type2, buffer.data, drawType);
            }
          }
        }
      };
      GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j2 in shaderAttributes) {
          if (!geometryAttributes[j2]) {
            throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
          }
        }
      };
      GeometrySystem2.prototype.getSignature = function(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ["g", geometry.id];
        for (var i2 in attribs) {
          if (shaderAttributes[i2]) {
            strings.push(i2);
          }
        }
        return strings.join("-");
      };
      GeometrySystem2.prototype.initGeometryVao = function(geometry, program, incRefCount) {
        if (incRefCount === void 0) {
          incRefCount = true;
        }
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.id] = vao;
          return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j2 in buffers) {
          tempStride[j2] = 0;
          tempStart[j2] = 0;
        }
        for (var j2 in attributes) {
          if (!attributes[j2].size && program.attributeData[j2]) {
            attributes[j2].size = program.attributeData[j2].size;
          } else if (!attributes[j2].size) {
            console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
          }
          tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap$1[attributes[j2].type];
        }
        for (var j2 in attributes) {
          var attribute = attributes[j2];
          var attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer];
            tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (var i2 = 0; i2 < buffers.length; i2++) {
          var buffer = buffers[i2];
          if (!buffer._glBuffers[CONTEXT_UID]) {
            buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
            this.managedBuffers[buffer.id] = buffer;
            buffer.disposeRunner.add(this);
          }
          if (incRefCount) {
            buffer._glBuffers[CONTEXT_UID].refCount++;
          }
        }
        this.activateVao(geometry, program);
        this._activeVao = vao;
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
      };
      GeometrySystem2.prototype.disposeBuffer = function(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
          return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        buffer.disposeRunner.remove(this);
        if (!glBuffer) {
          return;
        }
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
          return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
          return;
        }
        for (var i2 = 0; i2 < buffers.length; i2++) {
          var buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            this.disposeBuffer(buffers[i2], contextLost);
          }
        }
        if (!contextLost) {
          for (var vaoId in vaos) {
            if (vaoId[0] === "g") {
              var vao = vaos[vaoId];
              if (this._activeVao === vao) {
                this.unbind();
              }
              gl.deleteVertexArray(vao);
            }
          }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i2 = 0; i2 < all.length; i2++) {
          this.disposeGeometry(this.managedGeometries[all[i2]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i2 = 0; i2 < all.length; i2++) {
          this.disposeBuffer(this.managedBuffers[all[i2]], contextLost);
        }
      };
      GeometrySystem2.prototype.activateVao = function(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        for (var j2 in attributes) {
          var attribute = attributes[j2];
          var buffer = buffers[attribute.buffer];
          var glBuffer = buffer._glBuffers[CONTEXT_UID];
          if (program.attributeData[j2]) {
            if (lastBuffer !== glBuffer) {
              gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
              lastBuffer = glBuffer;
            }
            var location = program.attributeData[j2].location;
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      };
      GeometrySystem2.prototype.draw = function(type2, size, start, instanceCount) {
        var gl = this.gl;
        var geometry = this._activeGeometry;
        if (geometry.indexBuffer) {
          var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
            if (geometry.instanced) {
              gl.drawElementsInstanced(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
            } else {
              gl.drawElements(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else {
            console.warn("unsupported index buffer type: uint32");
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(type2, start, size || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(type2, start, size || geometry.getSize());
        }
        return this;
      };
      GeometrySystem2.prototype.unbind = function() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      };
      return GeometrySystem2;
    }(System);
    var MaskData = function() {
      function MaskData2(maskObject) {
        if (maskObject === void 0) {
          maskObject = null;
        }
        this.type = constants.MASK_TYPES.NONE;
        this.autoDetect = true;
        this.maskObject = maskObject || null;
        this.pooled = false;
        this.isMaskData = true;
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
        this._target = null;
      }
      MaskData2.prototype.reset = function() {
        if (this.pooled) {
          this.maskObject = null;
          this.type = constants.MASK_TYPES.NONE;
          this.autoDetect = true;
        }
        this._target = null;
      };
      MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
        if (maskAbove) {
          this._stencilCounter = maskAbove._stencilCounter;
          this._scissorCounter = maskAbove._scissorCounter;
          this._scissorRect = maskAbove._scissorRect;
        } else {
          this._stencilCounter = 0;
          this._scissorCounter = 0;
          this._scissorRect = null;
        }
      };
      return MaskData2;
    }();
    function compileShader(gl, type2, src) {
      var shader = gl.createShader(type2);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      return shader;
    }
    function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations) {
      var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
      var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
      var program = gl.createProgram();
      gl.attachShader(program, glVertShader);
      gl.attachShader(program, glFragShader);
      if (attributeLocations) {
        for (var i2 in attributeLocations) {
          gl.bindAttribLocation(program, attributeLocations[i2], i2);
        }
      }
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        if (!gl.getShaderParameter(glVertShader, gl.COMPILE_STATUS)) {
          console.warn(vertexSrc);
          console.error(gl.getShaderInfoLog(glVertShader));
        }
        if (!gl.getShaderParameter(glFragShader, gl.COMPILE_STATUS)) {
          console.warn(fragmentSrc);
          console.error(gl.getShaderInfoLog(glFragShader));
        }
        console.error("Pixi.js Error: Could not initialize shader.");
        console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error("gl.getError()", gl.getError());
        if (gl.getProgramInfoLog(program) !== "") {
          console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
        }
        gl.deleteProgram(program);
        program = null;
      }
      gl.deleteShader(glVertShader);
      gl.deleteShader(glFragShader);
      return program;
    }
    function booleanArray(size) {
      var array = new Array(size);
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = false;
      }
      return array;
    }
    function defaultValue(type2, size) {
      switch (type2) {
        case "float":
          return 0;
        case "vec2":
          return new Float32Array(2 * size);
        case "vec3":
          return new Float32Array(3 * size);
        case "vec4":
          return new Float32Array(4 * size);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
          return 0;
        case "ivec2":
          return new Int32Array(2 * size);
        case "ivec3":
          return new Int32Array(3 * size);
        case "ivec4":
          return new Int32Array(4 * size);
        case "uvec2":
          return new Uint32Array(2 * size);
        case "uvec3":
          return new Uint32Array(3 * size);
        case "uvec4":
          return new Uint32Array(4 * size);
        case "bool":
          return false;
        case "bvec2":
          return booleanArray(2 * size);
        case "bvec3":
          return booleanArray(3 * size);
        case "bvec4":
          return booleanArray(4 * size);
        case "mat2":
          return new Float32Array([
            1,
            0,
            0,
            1
          ]);
        case "mat3":
          return new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
        case "mat4":
          return new Float32Array([
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ]);
      }
      return null;
    }
    var unknownContext = {};
    var context = unknownContext;
    function getTestContext() {
      if (context === unknownContext || context && context.isContextLost()) {
        var canvas = document.createElement("canvas");
        var gl = void 0;
        if (settings2.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
          gl = canvas.getContext("webgl2", {});
        }
        if (!gl) {
          gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
          if (!gl) {
            gl = null;
          } else {
            gl.getExtension("WEBGL_draw_buffers");
          }
        }
        context = gl;
      }
      return context;
    }
    var maxFragmentPrecision;
    function getMaxFragmentPrecision() {
      if (!maxFragmentPrecision) {
        maxFragmentPrecision = constants.PRECISION.MEDIUM;
        var gl = getTestContext();
        if (gl) {
          if (gl.getShaderPrecisionFormat) {
            var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
            maxFragmentPrecision = shaderFragment.precision ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;
          }
        }
      }
      return maxFragmentPrecision;
    }
    function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
      if (src.substring(0, 9) !== "precision") {
        var precision = requestedPrecision;
        if (requestedPrecision === constants.PRECISION.HIGH && maxSupportedPrecision !== constants.PRECISION.HIGH) {
          precision = constants.PRECISION.MEDIUM;
        }
        return "precision " + precision + " float;\n" + src;
      } else if (maxSupportedPrecision !== constants.PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
        return src.replace("precision highp", "precision mediump");
      }
      return src;
    }
    var GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      uint: 1,
      uvec2: 2,
      uvec3: 3,
      uvec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
    function mapSize(type2) {
      return GLSL_TO_SIZE[type2];
    }
    var GL_TABLE = null;
    var GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    function mapType(gl, type2) {
      if (!GL_TABLE) {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);
        GL_TABLE = {};
        for (var i2 = 0; i2 < typeNames.length; ++i2) {
          var tn = typeNames[i2];
          GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
        }
      }
      return GL_TABLE[type2];
    }
    var uniformParsers = [
      {
        test: function(data) {
          return data.type === "float" && data.size === 1;
        },
        code: function(name2) {
          return '\n            if(uv["' + name2 + '"] !== ud["' + name2 + '"].value)\n            {\n                ud["' + name2 + '"].value = uv["' + name2 + '"]\n                gl.uniform1f(ud["' + name2 + '"].location, uv["' + name2 + '"])\n            }\n            ';
        }
      },
      {
        test: function(data) {
          return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
        },
        code: function(name2) {
          return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name2 + '"], t);\n\n            if(ud["' + name2 + '"].value !== t)\n            {\n                ud["' + name2 + '"].value = t;\n                gl.uniform1i(ud["' + name2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
        },
        code: function(name2) {
          return '\n            gl.uniformMatrix3fv(ud["' + name2 + '"].location, false, uv["' + name2 + '"].toArray(true));\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name2 + '"].location, v.x, v.y);\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec2" && data.size === 1;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name2 + '"].location, v[0], v[1]);\n                }\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec4" && data.size === 1;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
        }
      }
    ];
    var GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
      vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
      vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
      vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
      int: "gl.uniform1i(location, v)",
      ivec2: "gl.uniform2i(location, v[0], v[1])",
      ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      uint: "gl.uniform1ui(location, v)",
      uvec2: "gl.uniform2ui(location, v[0], v[1])",
      uvec3: "gl.uniform3ui(location, v[0], v[1], v[2])",
      uvec4: "gl.uniform4ui(location, v[0], v[1], v[2], v[3])",
      bool: "gl.uniform1i(location, v)",
      bvec2: "gl.uniform2i(location, v[0], v[1])",
      bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: "gl.uniform1i(location, v)",
      samplerCube: "gl.uniform1i(location, v)",
      sampler2DArray: "gl.uniform1i(location, v)"
    };
    var GLSL_TO_ARRAY_SETTERS = {
      float: "gl.uniform1fv(location, v)",
      vec2: "gl.uniform2fv(location, v)",
      vec3: "gl.uniform3fv(location, v)",
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
    function generateUniformsSync(group, uniformData) {
      var funcFragments = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
      for (var i2 in group.uniforms) {
        var data = uniformData[i2];
        if (!data) {
          if (group.uniforms[i2].group) {
            funcFragments.push('\n                    renderer.shader.syncUniformGroup(uv["' + i2 + '"], syncData);\n                ');
          }
          continue;
        }
        var uniform = group.uniforms[i2];
        var parsed = false;
        for (var j2 = 0; j2 < uniformParsers.length; j2++) {
          if (uniformParsers[j2].test(data, uniform)) {
            funcFragments.push(uniformParsers[j2].code(i2, uniform));
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
          var template = templateType[data.type].replace("location", 'ud["' + i2 + '"].location');
          funcFragments.push('\n            cv = ud["' + i2 + '"].value;\n            v = uv["' + i2 + '"];\n            ' + template + ";");
        }
      }
      return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
    }
    var fragTemplate = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
    function generateIfTestSrc(maxIfs) {
      var src = "";
      for (var i2 = 0; i2 < maxIfs; ++i2) {
        if (i2 > 0) {
          src += "\nelse ";
        }
        if (i2 < maxIfs - 1) {
          src += "if(test == " + i2 + ".0){}";
        }
      }
      return src;
    }
    function checkMaxIfStatementsInShader(maxIfs, gl) {
      if (maxIfs === 0) {
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
      }
      var shader = gl.createShader(gl.FRAGMENT_SHADER);
      while (true) {
        var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
      return maxIfs;
    }
    var unsafeEval;
    function unsafeEvalSupported() {
      if (typeof unsafeEval === "boolean") {
        return unsafeEval;
      }
      try {
        var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
        unsafeEval = func({a: "b"}, "a", "b") === true;
      } catch (e2) {
        unsafeEval = false;
      }
      return unsafeEval;
    }
    var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
    var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
    var UID$3 = 0;
    var nameCache = {};
    var Program = function() {
      function Program2(vertexSrc, fragmentSrc, name2) {
        if (name2 === void 0) {
          name2 = "pixi-shader";
        }
        this.id = UID$3++;
        this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== "#version") {
          name2 = name2.replace(/\s+/g, "-");
          if (nameCache[name2]) {
            nameCache[name2]++;
            name2 += "-" + nameCache[name2];
          } else {
            nameCache[name2] = 1;
          }
          this.vertexSrc = "#define SHADER_NAME " + name2 + "\n" + this.vertexSrc;
          this.fragmentSrc = "#define SHADER_NAME " + name2 + "\n" + this.fragmentSrc;
          this.vertexSrc = setPrecision(this.vertexSrc, settings2.settings.PRECISION_VERTEX, constants.PRECISION.HIGH);
          this.fragmentSrc = setPrecision(this.fragmentSrc, settings2.settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
        }
        this.extractData(this.vertexSrc, this.fragmentSrc);
        this.glPrograms = {};
        this.syncUniforms = null;
      }
      Program2.prototype.extractData = function(vertexSrc, fragmentSrc) {
        var gl = getTestContext();
        if (gl) {
          var program = compileProgram(gl, vertexSrc, fragmentSrc);
          this.attributeData = this.getAttributeData(program, gl);
          this.uniformData = this.getUniformData(program, gl);
          gl.deleteProgram(program);
        } else {
          this.uniformData = {};
          this.attributeData = {};
        }
      };
      Program2.prototype.getAttributeData = function(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i2 = 0; i2 < totalAttributes; i2++) {
          var attribData = gl.getActiveAttrib(program, i2);
          var type2 = mapType(gl, attribData.type);
          var data = {
            type: type2,
            name: attribData.name,
            size: mapSize(type2),
            location: 0
          };
          attributes[attribData.name] = data;
          attributesArray.push(data);
        }
        attributesArray.sort(function(a2, b2) {
          return a2.name > b2.name ? 1 : -1;
        });
        for (var i2 = 0; i2 < attributesArray.length; i2++) {
          attributesArray[i2].location = i2;
        }
        return attributes;
      };
      Program2.prototype.getUniformData = function(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i2 = 0; i2 < totalUniforms; i2++) {
          var uniformData = gl.getActiveUniform(program, i2);
          var name2 = uniformData.name.replace(/\[.*?\]$/, "");
          var isArray = uniformData.name.match(/\[.*?\]$/);
          var type2 = mapType(gl, uniformData.type);
          uniforms[name2] = {
            type: type2,
            size: uniformData.size,
            isArray,
            value: defaultValue(type2, uniformData.size)
          };
        }
        return uniforms;
      };
      Object.defineProperty(Program2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Program2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment;
        },
        enumerable: false,
        configurable: true
      });
      Program2.from = function(vertexSrc, fragmentSrc, name2) {
        var key = vertexSrc + fragmentSrc;
        var program = utils6.ProgramCache[key];
        if (!program) {
          utils6.ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name2);
        }
        return program;
      };
      return Program2;
    }();
    var Shader = function() {
      function Shader2(program, uniforms) {
        this.program = program;
        if (uniforms) {
          if (uniforms instanceof UniformGroup) {
            this.uniformGroup = uniforms;
          } else {
            this.uniformGroup = new UniformGroup(uniforms);
          }
        } else {
          this.uniformGroup = new UniformGroup({});
        }
        for (var i2 in program.uniformData) {
          if (this.uniformGroup.uniforms[i2] instanceof Array) {
            this.uniformGroup.uniforms[i2] = new Float32Array(this.uniformGroup.uniforms[i2]);
          }
        }
      }
      Shader2.prototype.checkUniformExists = function(name2, group) {
        if (group.uniforms[name2]) {
          return true;
        }
        for (var i2 in group.uniforms) {
          var uniform = group.uniforms[i2];
          if (uniform.group) {
            if (this.checkUniformExists(name2, uniform)) {
              return true;
            }
          }
        }
        return false;
      };
      Shader2.prototype.destroy = function() {
        this.uniformGroup = null;
      };
      Object.defineProperty(Shader2.prototype, "uniforms", {
        get: function() {
          return this.uniformGroup.uniforms;
        },
        enumerable: false,
        configurable: true
      });
      Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
        var program = Program.from(vertexSrc, fragmentSrc);
        return new Shader2(program, uniforms);
      };
      return Shader2;
    }();
    var BLEND = 0;
    var OFFSET = 1;
    var CULLING = 2;
    var DEPTH_TEST = 3;
    var WINDING = 4;
    var DEPTH_MASK = 5;
    var State2 = function() {
      function State3() {
        this.data = 0;
        this.blendMode = constants.BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      Object.defineProperty(State3.prototype, "blend", {
        get: function() {
          return !!(this.data & 1 << BLEND);
        },
        set: function(value) {
          if (!!(this.data & 1 << BLEND) !== value) {
            this.data ^= 1 << BLEND;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "offsets", {
        get: function() {
          return !!(this.data & 1 << OFFSET);
        },
        set: function(value) {
          if (!!(this.data & 1 << OFFSET) !== value) {
            this.data ^= 1 << OFFSET;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "culling", {
        get: function() {
          return !!(this.data & 1 << CULLING);
        },
        set: function(value) {
          if (!!(this.data & 1 << CULLING) !== value) {
            this.data ^= 1 << CULLING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthTest", {
        get: function() {
          return !!(this.data & 1 << DEPTH_TEST);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value) {
            this.data ^= 1 << DEPTH_TEST;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthMask", {
        get: function() {
          return !!(this.data & 1 << DEPTH_MASK);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value) {
            this.data ^= 1 << DEPTH_MASK;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "clockwiseFrontFace", {
        get: function() {
          return !!(this.data & 1 << WINDING);
        },
        set: function(value) {
          if (!!(this.data & 1 << WINDING) !== value) {
            this.data ^= 1 << WINDING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "blendMode", {
        get: function() {
          return this._blendMode;
        },
        set: function(value) {
          this.blend = value !== constants.BLEND_MODES.NONE;
          this._blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "polygonOffset", {
        get: function() {
          return this._polygonOffset;
        },
        set: function(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        },
        enumerable: false,
        configurable: true
      });
      State3.prototype.toString = function() {
        return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
      };
      State3.for2d = function() {
        var state = new State3();
        state.depthTest = false;
        state.blend = true;
        return state;
      };
      return State3;
    }();
    var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
    var Filter = function(_super) {
      __extends(Filter2, _super);
      function Filter2(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
        _this = _super.call(this, program, uniforms) || this;
        _this.padding = 0;
        _this.resolution = settings2.settings.FILTER_RESOLUTION;
        _this.enabled = true;
        _this.autoFit = true;
        _this.legacy = !!_this.program.attributeData.aTextureCoord;
        _this.state = new State2();
        return _this;
      }
      Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(Filter2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment$1;
        },
        enumerable: false,
        configurable: true
      });
      return Filter2;
    }(Shader);
    var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
    var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
    var tempMat = new math.Matrix();
    var TextureMatrix = function() {
      function TextureMatrix2(texture, clampMargin) {
        this._texture = texture;
        this.mapCoord = new math.Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
      }
      Object.defineProperty(TextureMatrix2.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value) {
          this._texture = value;
          this._textureID = -1;
        },
        enumerable: false,
        configurable: true
      });
      TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
        if (out === void 0) {
          out = uvs;
        }
        var mat = this.mapCoord;
        for (var i2 = 0; i2 < uvs.length; i2 += 2) {
          var x2 = uvs[i2];
          var y2 = uvs[i2 + 1];
          out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
          out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
        }
        return out;
      };
      TextureMatrix2.prototype.update = function(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
          return false;
        }
        if (!forceUpdate && this._textureID === tex._updateID) {
          return false;
        }
        this._textureID = tex._updateID;
        this._updateID++;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
          tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
          this.mapCoord.append(tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
        return true;
      };
      return TextureMatrix2;
    }();
    var SpriteMaskFilter = function(_super) {
      __extends(SpriteMaskFilter2, _super);
      function SpriteMaskFilter2(sprite) {
        var _this = this;
        var maskMatrix = new math.Matrix();
        _this = _super.call(this, vertex, fragment) || this;
        sprite.renderable = false;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        return _this;
      }
      SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
        var maskSprite = this.maskSprite;
        var tex = maskSprite._texture;
        if (!tex.valid) {
          return;
        }
        if (!tex.uvMatrix) {
          tex.uvMatrix = new TextureMatrix(tex, 0);
        }
        tex.uvMatrix.update();
        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
        filterManager.applyFilter(this, input, output, clearMode);
      };
      return SpriteMaskFilter2;
    }(Filter);
    var MaskSystem = function(_super) {
      __extends(MaskSystem2, _super);
      function MaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.enableScissor = true;
        _this.alphaMaskPool = [];
        _this.maskDataPool = [];
        _this.maskStack = [];
        _this.alphaMaskIndex = 0;
        return _this;
      }
      MaskSystem2.prototype.setMaskStack = function(maskStack) {
        this.maskStack = maskStack;
        this.renderer.scissor.setMaskStack(maskStack);
        this.renderer.stencil.setMaskStack(maskStack);
      };
      MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
        var maskData = maskDataOrTarget;
        if (!maskData.isMaskData) {
          var d2 = this.maskDataPool.pop() || new MaskData();
          d2.pooled = true;
          d2.maskObject = maskDataOrTarget;
          maskData = d2;
        }
        if (maskData.autoDetect) {
          this.detect(maskData);
        }
        maskData.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]);
        maskData._target = target;
        switch (maskData.type) {
          case constants.MASK_TYPES.SCISSOR:
            this.maskStack.push(maskData);
            this.renderer.scissor.push(maskData);
            break;
          case constants.MASK_TYPES.STENCIL:
            this.maskStack.push(maskData);
            this.renderer.stencil.push(maskData);
            break;
          case constants.MASK_TYPES.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            this.maskStack.push(maskData);
            break;
        }
      };
      MaskSystem2.prototype.pop = function(target) {
        var maskData = this.maskStack.pop();
        if (!maskData || maskData._target !== target) {
          return;
        }
        switch (maskData.type) {
          case constants.MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop();
            break;
          case constants.MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case constants.MASK_TYPES.SPRITE:
            this.popSpriteMask();
            break;
        }
        maskData.reset();
        if (maskData.pooled) {
          this.maskDataPool.push(maskData);
        }
      };
      MaskSystem2.prototype.detect = function(maskData) {
        var maskObject = maskData.maskObject;
        if (maskObject.isSprite) {
          maskData.type = constants.MASK_TYPES.SPRITE;
          return;
        }
        maskData.type = constants.MASK_TYPES.STENCIL;
        if (this.enableScissor && maskObject.isFastRect && maskObject.isFastRect()) {
          var matrix = maskObject.worldTransform;
          var rotX = Math.atan2(matrix.b, matrix.a);
          var rotXY = Math.atan2(matrix.d, matrix.c);
          rotX = Math.round(rotX * (180 / Math.PI) * 100);
          rotXY = Math.round(rotXY * (180 / Math.PI) * 100) - rotX;
          rotX = (rotX % 9e3 + 9e3) % 9e3;
          rotXY = (rotXY % 18e3 + 18e3) % 18e3;
          if (rotX === 0 && rotXY === 9e3) {
            maskData.type = constants.MASK_TYPES.SCISSOR;
          }
        }
      };
      MaskSystem2.prototype.pushSpriteMask = function(maskData) {
        var maskObject = maskData.maskObject;
        var target = maskData._target;
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskObject)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskObject;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskObject.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
      };
      MaskSystem2.prototype.popSpriteMask = function() {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
      };
      return MaskSystem2;
    }(System);
    var AbstractMaskSystem = function(_super) {
      __extends(AbstractMaskSystem2, _super);
      function AbstractMaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.maskStack = [];
        _this.glConst = 0;
        return _this;
      }
      AbstractMaskSystem2.prototype.getStackLength = function() {
        return this.maskStack.length;
      };
      AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
        var gl = this.renderer.gl;
        var curStackLen = this.getStackLength();
        this.maskStack = maskStack;
        var newStackLen = this.getStackLength();
        if (newStackLen !== curStackLen) {
          if (newStackLen === 0) {
            gl.disable(this.glConst);
          } else {
            gl.enable(this.glConst);
            this._useCurrent();
          }
        }
      };
      AbstractMaskSystem2.prototype._useCurrent = function() {
      };
      AbstractMaskSystem2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.maskStack = null;
      };
      return AbstractMaskSystem2;
    }(System);
    var ScissorSystem = function(_super) {
      __extends(ScissorSystem2, _super);
      function ScissorSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
        return _this;
      }
      ScissorSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._scissorCounter;
        }
        return 0;
      };
      ScissorSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        maskObject.renderable = true;
        var prevData = maskData._scissorRect;
        var bounds = maskObject.getBounds(true);
        var gl = this.renderer.gl;
        maskObject.renderable = false;
        if (prevData) {
          bounds.fit(prevData);
        } else {
          gl.enable(gl.SCISSOR_TEST);
        }
        maskData._scissorCounter++;
        maskData._scissorRect = bounds;
        this._useCurrent();
      };
      ScissorSystem2.prototype.pop = function() {
        var gl = this.renderer.gl;
        if (this.getStackLength() > 0) {
          this._useCurrent();
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      };
      ScissorSystem2.prototype._useCurrent = function() {
        var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        var rt = this.renderer.renderTexture.current;
        var _a = this.renderer.projection, transform = _a.transform, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
        var resolution = rt ? rt.resolution : this.renderer.resolution;
        var sx = destinationFrame.width / sourceFrame.width;
        var sy = destinationFrame.height / sourceFrame.height;
        var x2 = ((rect.x - sourceFrame.x) * sx + destinationFrame.x) * resolution;
        var y2 = ((rect.y - sourceFrame.y) * sy + destinationFrame.y) * resolution;
        var width = rect.width * sx * resolution;
        var height = rect.height * sy * resolution;
        if (transform) {
          x2 += transform.tx * resolution;
          y2 += transform.ty * resolution;
        }
        if (!rt) {
          y2 = this.renderer.height - height - y2;
        }
        this.renderer.gl.scissor(x2, y2, width, height);
      };
      return ScissorSystem2;
    }(AbstractMaskSystem);
    var StencilSystem = function(_super) {
      __extends(StencilSystem2, _super);
      function StencilSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.STENCIL_TEST;
        return _this;
      }
      StencilSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._stencilCounter;
        }
        return 0;
      };
      StencilSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        var gl = this.renderer.gl;
        var prevMaskCount = maskData._stencilCounter;
        if (prevMaskCount === 0) {
          this.renderer.framebuffer.forceStencil();
          gl.enable(gl.STENCIL_TEST);
        }
        maskData._stencilCounter++;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        this.renderer.framebuffer.blit();
        maskObject.renderable = false;
        this._useCurrent();
      };
      StencilSystem2.prototype.pop = function(maskObject) {
        var gl = this.renderer.gl;
        if (this.getStackLength() === 0) {
          gl.disable(gl.STENCIL_TEST);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.clearStencil(0);
        } else {
          gl.colorMask(false, false, false, false);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          maskObject.renderable = true;
          maskObject.render(this.renderer);
          this.renderer.batch.flush();
          maskObject.renderable = false;
          this._useCurrent();
        }
      };
      StencilSystem2.prototype._useCurrent = function() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.getStackLength(), this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      };
      StencilSystem2.prototype._getBitwiseMask = function() {
        return (1 << this.getStackLength()) - 1;
      };
      return StencilSystem2;
    }(AbstractMaskSystem);
    var ProjectionSystem = function(_super) {
      __extends(ProjectionSystem2, _super);
      function ProjectionSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destinationFrame = null;
        _this.sourceFrame = null;
        _this.defaultFrame = null;
        _this.projectionMatrix = new math.Matrix();
        _this.transform = null;
        return _this;
      }
      ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        if (renderer.shader.shader) {
          renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
      };
      ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
        var pm = this.projectionMatrix;
        var sign = !root ? 1 : -1;
        pm.identity();
        pm.a = 1 / sourceFrame.width * 2;
        pm.d = sign * (1 / sourceFrame.height * 2);
        pm.tx = -1 - sourceFrame.x * pm.a;
        pm.ty = -sign - sourceFrame.y * pm.d;
      };
      ProjectionSystem2.prototype.setTransform = function(_matrix) {
      };
      return ProjectionSystem2;
    }(System);
    var tempRect = new math.Rectangle();
    var tempRect2 = new math.Rectangle();
    var RenderTextureSystem = function(_super) {
      __extends(RenderTextureSystem2, _super);
      function RenderTextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.clearColor = renderer._backgroundColorRgba;
        _this.defaultMaskStack = [];
        _this.current = null;
        _this.sourceFrame = new math.Rectangle();
        _this.destinationFrame = new math.Rectangle();
        _this.viewportFrame = new math.Rectangle();
        return _this;
      }
      RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
        if (renderTexture === void 0) {
          renderTexture = null;
        }
        var renderer = this.renderer;
        this.current = renderTexture;
        var baseTexture;
        var framebuffer;
        var resolution;
        if (renderTexture) {
          baseTexture = renderTexture.baseTexture;
          resolution = baseTexture.resolution;
          if (!sourceFrame) {
            tempRect.width = renderTexture.frame.width;
            tempRect.height = renderTexture.frame.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            tempRect2.x = renderTexture.frame.x;
            tempRect2.y = renderTexture.frame.y;
            tempRect2.width = sourceFrame.width;
            tempRect2.height = sourceFrame.height;
            destinationFrame = tempRect2;
          }
          framebuffer = baseTexture.framebuffer;
        } else {
          resolution = renderer.resolution;
          if (!sourceFrame) {
            tempRect.width = renderer.screen.width;
            tempRect.height = renderer.screen.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            destinationFrame = tempRect;
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
          }
        }
        var viewportFrame = this.viewportFrame;
        viewportFrame.x = destinationFrame.x * resolution;
        viewportFrame.y = destinationFrame.y * resolution;
        viewportFrame.width = destinationFrame.width * resolution;
        viewportFrame.height = destinationFrame.height * resolution;
        if (!renderTexture) {
          viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
        }
        this.renderer.framebuffer.bind(framebuffer, viewportFrame);
        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
        if (renderTexture) {
          this.renderer.mask.setMaskStack(baseTexture.maskStack);
        } else {
          this.renderer.mask.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.copyFrom(destinationFrame);
      };
      RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
        if (this.current) {
          clearColor = clearColor || this.current.baseTexture.clearColor;
        } else {
          clearColor = clearColor || this.clearColor;
        }
        var destinationFrame = this.destinationFrame;
        var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
        var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
        if (clearMask) {
          var _a = this.viewportFrame, x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
          this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
          this.renderer.gl.scissor(x2, y2, width, height);
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
        if (clearMask) {
          this.renderer.scissor.pop();
        }
      };
      RenderTextureSystem2.prototype.resize = function() {
        this.bind(null);
      };
      RenderTextureSystem2.prototype.reset = function() {
        this.bind(null);
      };
      return RenderTextureSystem2;
    }(System);
    var IGLUniformData = function() {
      function IGLUniformData2() {
      }
      return IGLUniformData2;
    }();
    var GLProgram = function() {
      function GLProgram2(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
      }
      GLProgram2.prototype.destroy = function() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
      };
      return GLProgram2;
    }();
    var UID$4 = 0;
    var defaultSyncData = {textureCount: 0};
    var ShaderSystem = function(_super) {
      __extends(ShaderSystem2, _super);
      function ShaderSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destroyed = false;
        _this.systemCheck();
        _this.gl = null;
        _this.shader = null;
        _this.program = null;
        _this.cache = {};
        _this.id = UID$4++;
        return _this;
      }
      ShaderSystem2.prototype.systemCheck = function() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      };
      ShaderSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.reset();
      };
      ShaderSystem2.prototype.bind = function(shader, dontSync) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        if (this.program !== program) {
          this.program = program;
          this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
          defaultSyncData.textureCount = 0;
          this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
        }
        return glProgram;
      };
      ShaderSystem2.prototype.setUniforms = function(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
      };
      ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
        var glProgram = this.getglProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
          glProgram.uniformGroups[group.id] = group.dirtyId;
          this.syncUniforms(group, glProgram, syncData);
        }
      };
      ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
      };
      ShaderSystem2.prototype.createSyncGroups = function(group) {
        var id = this.getSignature(group, this.shader.program.uniformData);
        if (!this.cache[id]) {
          this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
      };
      ShaderSystem2.prototype.getSignature = function(group, uniformData) {
        var uniforms = group.uniforms;
        var strings = [];
        for (var i2 in uniforms) {
          strings.push(i2);
          if (uniformData[i2]) {
            strings.push(uniformData[i2].type);
          }
        }
        return strings.join("-");
      };
      ShaderSystem2.prototype.getglProgram = function() {
        if (this.shader) {
          return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
      };
      ShaderSystem2.prototype.generateShader = function(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i2 in program.attributeData) {
          attribMap[i2] = program.attributeData[i2].location;
        }
        var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i2 in program.uniformData) {
          var data = program.uniformData[i2];
          uniformData[i2] = {
            location: gl.getUniformLocation(shaderProgram, i2),
            value: defaultValue(data.type, data.size)
          };
        }
        var glProgram = new GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
      };
      ShaderSystem2.prototype.reset = function() {
        this.program = null;
        this.shader = null;
      };
      ShaderSystem2.prototype.destroy = function() {
        this.destroyed = true;
      };
      return ShaderSystem2;
    }(System);
    function mapWebGLBlendModesToPixi(gl, array) {
      if (array === void 0) {
        array = [];
      }
      array[constants.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
      array[constants.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.NONE] = [0, 0];
      array[constants.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
      array[constants.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
      array[constants.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
      array[constants.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
      array[constants.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
      array[constants.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
      array[constants.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[constants.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
      return array;
    }
    var BLEND$1 = 0;
    var OFFSET$1 = 1;
    var CULLING$1 = 2;
    var DEPTH_TEST$1 = 3;
    var WINDING$1 = 4;
    var DEPTH_MASK$1 = 5;
    var StateSystem = function(_super) {
      __extends(StateSystem2, _super);
      function StateSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.gl = null;
        _this.stateId = 0;
        _this.polygonOffset = 0;
        _this.blendMode = constants.BLEND_MODES.NONE;
        _this._blendEq = false;
        _this.map = [];
        _this.map[BLEND$1] = _this.setBlend;
        _this.map[OFFSET$1] = _this.setOffset;
        _this.map[CULLING$1] = _this.setCullFace;
        _this.map[DEPTH_TEST$1] = _this.setDepthTest;
        _this.map[WINDING$1] = _this.setFrontFace;
        _this.map[DEPTH_MASK$1] = _this.setDepthMask;
        _this.checks = [];
        _this.defaultState = new State2();
        _this.defaultState.blend = true;
        return _this;
      }
      StateSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.blendModes = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      };
      StateSystem2.prototype.set = function(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          var diff = this.stateId ^ state.data;
          var i2 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i2].call(this, !!(state.data & 1 << i2));
            }
            diff = diff >> 1;
            i2++;
          }
          this.stateId = state.data;
        }
        for (var i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
      };
      StateSystem2.prototype.forceState = function(state) {
        state = state || this.defaultState;
        for (var i2 = 0; i2 < this.map.length; i2++) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        for (var i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
        this.stateId = state.data;
      };
      StateSystem2.prototype.setBlend = function(value) {
        this.updateCheck(StateSystem2.checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      };
      StateSystem2.prototype.setOffset = function(value) {
        this.updateCheck(StateSystem2.checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      };
      StateSystem2.prototype.setDepthTest = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      };
      StateSystem2.prototype.setDepthMask = function(value) {
        this.gl.depthMask(value);
      };
      StateSystem2.prototype.setCullFace = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      };
      StateSystem2.prototype.setFrontFace = function(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      };
      StateSystem2.prototype.setBlendMode = function(value) {
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      };
      StateSystem2.prototype.setPolygonOffset = function(value, scale) {
        this.gl.polygonOffset(value, scale);
      };
      StateSystem2.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
      };
      StateSystem2.prototype.updateCheck = function(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      };
      StateSystem2.checkBlendMode = function(system, state) {
        system.setBlendMode(state.blendMode);
      };
      StateSystem2.checkPolygonOffset = function(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      };
      return StateSystem2;
    }(System);
    var TextureGCSystem = function(_super) {
      __extends(TextureGCSystem2, _super);
      function TextureGCSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.count = 0;
        _this.checkCount = 0;
        _this.maxIdle = settings2.settings.GC_MAX_IDLE;
        _this.checkCountMax = settings2.settings.GC_MAX_CHECK_COUNT;
        _this.mode = settings2.settings.GC_MODE;
        return _this;
      }
      TextureGCSystem2.prototype.postrender = function() {
        if (!this.renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (this.mode === constants.GC_MODES.MANUAL) {
          return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      };
      TextureGCSystem2.prototype.run = function() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i2 = 0; i2 < managedTextures.length; i2++) {
          var texture = managedTextures[i2];
          if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
            tm.destroyTexture(texture, true);
            managedTextures[i2] = null;
            wasRemoved = true;
          }
        }
        if (wasRemoved) {
          var j2 = 0;
          for (var i2 = 0; i2 < managedTextures.length; i2++) {
            if (managedTextures[i2] !== null) {
              managedTextures[j2++] = managedTextures[i2];
            }
          }
          managedTextures.length = j2;
        }
      };
      TextureGCSystem2.prototype.unload = function(displayObject) {
        var tm = this.renderer.texture;
        var texture = displayObject._texture;
        if (texture && !texture.framebuffer) {
          tm.destroyTexture(texture);
        }
        for (var i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
          this.unload(displayObject.children[i2]);
        }
      };
      return TextureGCSystem2;
    }(System);
    var GLTexture = function() {
      function GLTexture2(texture) {
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.dirtyId = -1;
        this.dirtyStyleId = -1;
        this.mipmap = false;
        this.wrapMode = 33071;
        this.type = 6408;
        this.internalFormat = 5121;
      }
      return GLTexture2;
    }();
    var TextureSystem = function(_super) {
      __extends(TextureSystem2, _super);
      function TextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.boundTextures = [];
        _this.currentLocation = -1;
        _this.managedTextures = [];
        _this._unknownBoundTextures = false;
        _this.unknownTexture = new BaseTexture();
        return _this;
      }
      TextureSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i2 = 0; i2 < maxTextures; i2++) {
          this.boundTextures[i2] = null;
        }
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i2 = 0; i2 < 6; i2++) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
          this.bind(null, i2);
        }
      };
      TextureSystem2.prototype.bind = function(texture, location) {
        if (location === void 0) {
          location = 0;
        }
        var gl = this.gl;
        if (texture) {
          texture = texture.castToBaseTexture();
          if (texture.parentTextureArray) {
            return;
          }
          if (texture.valid) {
            texture.touched = this.renderer.textureGC.count;
            var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
            if (this.boundTextures[location] !== texture) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              gl.bindTexture(texture.target, glTexture.texture);
            }
            if (glTexture.dirtyId !== texture.dirtyId) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              this.updateTexture(texture);
            }
            this.boundTextures[location] = texture;
          }
        } else {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
          this.boundTextures[location] = null;
        }
      };
      TextureSystem2.prototype.reset = function() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
          this.boundTextures[i2] = this.unknownTexture;
        }
      };
      TextureSystem2.prototype.unbind = function(texture) {
        var _a = this, gl = _a.gl, boundTextures = _a.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === this.unknownTexture) {
              this.bind(null, i2);
            }
          }
        }
        for (var i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === texture) {
            if (this.currentLocation !== i2) {
              gl.activeTexture(gl.TEXTURE0 + i2);
              this.currentLocation = i2;
            }
            gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
            boundTextures[i2] = null;
          }
        }
      };
      TextureSystem2.prototype.initTexture = function(texture) {
        var glTexture = new GLTexture(this.gl.createTexture());
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        texture.on("dispose", this.destroyTexture, this);
        return glTexture;
      };
      TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
        glTexture.internalFormat = texture.format;
        glTexture.type = texture.type;
        if (this.webGLVersion !== 2) {
          return;
        }
        var gl = this.renderer.gl;
        if (texture.type === gl.FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA32F;
        }
        if (texture.type === constants.TYPES.HALF_FLOAT) {
          glTexture.type = gl.HALF_FLOAT;
        }
        if (glTexture.type === gl.HALF_FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA16F;
        }
      };
      TextureSystem2.prototype.updateTexture = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        var renderer = this.renderer;
        this.initTextureType(texture, glTexture);
        if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
          ;
        else {
          var width = texture.realWidth;
          var height = texture.realHeight;
          var gl = renderer.gl;
          if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
          }
        }
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
      };
      TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
        var gl = this.gl;
        texture = texture.castToBaseTexture();
        if (texture._glTextures[this.CONTEXT_UID]) {
          this.unbind(texture);
          gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
          texture.off("dispose", this.destroyTexture, this);
          delete texture._glTextures[this.CONTEXT_UID];
          if (!skipRemove) {
            var i2 = this.managedTextures.indexOf(texture);
            if (i2 !== -1) {
              utils6.removeItems(this.managedTextures, i2, 1);
            }
          }
        }
      };
      TextureSystem2.prototype.updateTextureStyle = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        if ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
          glTexture.mipmap = false;
        } else {
          glTexture.mipmap = texture.mipmap >= 1;
        }
        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
          glTexture.wrapMode = constants.WRAP_MODES.CLAMP;
        } else {
          glTexture.wrapMode = texture.wrapMode;
        }
        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
          ;
        else {
          this.setStyle(texture, glTexture);
        }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
      };
      TextureSystem2.prototype.setStyle = function(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL) {
          gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
          if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {
            var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
          }
        } else {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      };
      return TextureSystem2;
    }(System);
    var _systems = {
      __proto__: null,
      FilterSystem,
      BatchSystem,
      ContextSystem,
      FramebufferSystem,
      GeometrySystem,
      MaskSystem,
      ScissorSystem,
      StencilSystem,
      ProjectionSystem,
      RenderTextureSystem,
      ShaderSystem,
      StateSystem,
      TextureGCSystem,
      TextureSystem
    };
    var tempMatrix$1 = new math.Matrix();
    var AbstractRenderer = function(_super) {
      __extends(AbstractRenderer2, _super);
      function AbstractRenderer2(type2, options) {
        if (type2 === void 0) {
          type2 = constants.RENDERER_TYPE.UNKNOWN;
        }
        var _this = _super.call(this) || this;
        options = Object.assign({}, settings2.settings.RENDER_OPTIONS, options);
        _this.options = options;
        _this.type = type2;
        _this.screen = new math.Rectangle(0, 0, options.width, options.height);
        _this.view = options.view || document.createElement("canvas");
        _this.resolution = options.resolution || settings2.settings.RESOLUTION;
        _this.useContextAlpha = options.useContextAlpha;
        _this.autoDensity = !!options.autoDensity;
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        _this.clearBeforeRender = options.clearBeforeRender;
        _this._backgroundColor = 0;
        _this._backgroundColorRgba = [0, 0, 0, 1];
        _this._backgroundColorString = "#000000";
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
        _this.backgroundAlpha = options.backgroundAlpha;
        if (options.transparent !== void 0) {
          utils6.deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
          _this.useContextAlpha = options.transparent;
          _this.backgroundAlpha = options.transparent ? 0 : 1;
        }
        _this._lastObjectRendered = null;
        _this.plugins = {};
        return _this;
      }
      AbstractRenderer2.prototype.initPlugins = function(staticMap) {
        for (var o2 in staticMap) {
          this.plugins[o2] = new staticMap[o2](this);
        }
      };
      Object.defineProperty(AbstractRenderer2.prototype, "width", {
        get: function() {
          return this.view.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer2.prototype, "height", {
        get: function() {
          return this.view.height;
        },
        enumerable: false,
        configurable: true
      });
      AbstractRenderer2.prototype.resize = function(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
          this.view.style.width = screenWidth + "px";
          this.view.style.height = screenHeight + "px";
        }
        this.emit("resize", screenWidth, screenHeight);
      };
      AbstractRenderer2.prototype.generateTexture = function(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds(null, true);
        if (region.width === 0) {
          region.width = 1;
        }
        if (region.height === 0) {
          region.height = 1;
        }
        var renderTexture = RenderTexture.create({
          width: region.width | 0,
          height: region.height | 0,
          scaleMode,
          resolution
        });
        tempMatrix$1.tx = -region.x;
        tempMatrix$1.ty = -region.y;
        this.render(displayObject, {
          renderTexture,
          clear: false,
          transform: tempMatrix$1,
          skipUpdateTransform: !!displayObject.parent
        });
        return renderTexture;
      };
      AbstractRenderer2.prototype.destroy = function(removeView) {
        for (var o2 in this.plugins) {
          this.plugins[o2].destroy();
          this.plugins[o2] = null;
        }
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
        var thisAny = this;
        thisAny.plugins = null;
        thisAny.type = constants.RENDERER_TYPE.UNKNOWN;
        thisAny.view = null;
        thisAny.screen = null;
        thisAny._tempDisplayObjectParent = null;
        thisAny.options = null;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._lastObjectRendered = null;
      };
      Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
        get: function() {
          return this._backgroundColor;
        },
        set: function(value) {
          this._backgroundColor = value;
          this._backgroundColorString = utils6.hex2string(value);
          utils6.hex2rgb(value, this._backgroundColorRgba);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
        get: function() {
          return this._backgroundColorRgba[3];
        },
        set: function(value) {
          this._backgroundColorRgba[3] = value;
        },
        enumerable: false,
        configurable: true
      });
      return AbstractRenderer2;
    }(utils6.EventEmitter);
    var Renderer = function(_super) {
      __extends(Renderer2, _super);
      function Renderer2(options) {
        var _this = _super.call(this, constants.RENDERER_TYPE.WEBGL, options) || this;
        options = _this.options;
        _this.gl = null;
        _this.CONTEXT_UID = 0;
        _this.runners = {
          destroy: new runner.Runner("destroy"),
          contextChange: new runner.Runner("contextChange"),
          reset: new runner.Runner("reset"),
          update: new runner.Runner("update"),
          postrender: new runner.Runner("postrender"),
          prerender: new runner.Runner("prerender"),
          resize: new runner.Runner("resize")
        };
        _this.globalUniforms = new UniformGroup({
          projectionMatrix: new math.Matrix()
        }, true);
        _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
        _this.initPlugins(Renderer2.__plugins);
        if (options.context) {
          _this.context.initFromContext(options.context);
        } else {
          _this.context.initFromOptions({
            alpha: !!_this.useContextAlpha,
            antialias: options.antialias,
            premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference
          });
        }
        _this.renderingToScreen = true;
        utils6.sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
        _this.resize(_this.options.width, _this.options.height);
        return _this;
      }
      Renderer2.create = function(options) {
        if (utils6.isWebGLSupported()) {
          return new Renderer2(options);
        }
        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
      };
      Renderer2.prototype.addSystem = function(ClassRef, name2) {
        if (!name2) {
          name2 = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name2]) {
          throw new Error('Whoops! The name "' + name2 + '" is already in use');
        }
        this[name2] = system;
        for (var i2 in this.runners) {
          this.runners[i2].add(system);
        }
        return this;
      };
      Renderer2.prototype.render = function(displayObject, options) {
        var renderTexture;
        var clear;
        var transform;
        var skipUpdateTransform;
        if (options) {
          if (options instanceof RenderTexture) {
            utils6.deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
            renderTexture = options;
            clear = arguments[2];
            transform = arguments[3];
            skipUpdateTransform = arguments[4];
          } else {
            renderTexture = options.renderTexture;
            clear = options.clear;
            transform = options.transform;
            skipUpdateTransform = options.skipUpdateTransform;
          }
        }
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.emit();
        this.emit("prerender");
        this.projection.transform = transform;
        if (this.context.isLost) {
          return;
        }
        if (!renderTexture) {
          this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
          var cacheParent = displayObject.enableTempParent();
          displayObject.updateTransform();
          displayObject.disableTempParent(cacheParent);
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== void 0 ? clear : this.clearBeforeRender) {
          this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
          renderTexture.baseTexture.update();
        }
        this.runners.postrender.emit();
        this.projection.transform = null;
        this.emit("postrender");
      };
      Renderer2.prototype.resize = function(screenWidth, screenHeight) {
        _super.prototype.resize.call(this, screenWidth, screenHeight);
        this.runners.resize.emit(screenWidth, screenHeight);
      };
      Renderer2.prototype.reset = function() {
        this.runners.reset.emit();
        return this;
      };
      Renderer2.prototype.clear = function() {
        this.renderTexture.bind();
        this.renderTexture.clear();
      };
      Renderer2.prototype.destroy = function(removeView) {
        this.runners.destroy.emit();
        for (var r2 in this.runners) {
          this.runners[r2].destroy();
        }
        _super.prototype.destroy.call(this, removeView);
        this.gl = null;
      };
      Object.defineProperty(Renderer2.prototype, "extract", {
        get: function() {
          utils6.deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
          return this.plugins.extract;
        },
        enumerable: false,
        configurable: true
      });
      Renderer2.registerPlugin = function(pluginName, ctor) {
        Renderer2.__plugins = Renderer2.__plugins || {};
        Renderer2.__plugins[pluginName] = ctor;
      };
      return Renderer2;
    }(AbstractRenderer);
    function autoDetectRenderer(options) {
      return Renderer.create(options);
    }
    var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
    var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var defaultVertex$2 = $defaultVertex;
    var defaultFilterVertex = $defaultFilterVertex;
    var BatchDrawCall = function() {
      function BatchDrawCall2() {
        this.texArray = null;
        this.blend = 0;
        this.type = constants.DRAW_MODES.TRIANGLES;
        this.start = 0;
        this.size = 0;
        this.data = null;
      }
      return BatchDrawCall2;
    }();
    var BatchTextureArray = function() {
      function BatchTextureArray2() {
        this.elements = [];
        this.ids = [];
        this.count = 0;
      }
      BatchTextureArray2.prototype.clear = function() {
        for (var i2 = 0; i2 < this.count; i2++) {
          this.elements[i2] = null;
        }
        this.count = 0;
      };
      return BatchTextureArray2;
    }();
    var ViewableBuffer = function() {
      function ViewableBuffer2(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
      }
      Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
        get: function() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
        get: function() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
        get: function() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
        get: function() {
          if (!this._uint16View) {
            this._uint16View = new Uint16Array(this.rawBinaryData);
          }
          return this._uint16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
        get: function() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        },
        enumerable: false,
        configurable: true
      });
      ViewableBuffer2.prototype.view = function(type2) {
        return this[type2 + "View"];
      };
      ViewableBuffer2.prototype.destroy = function() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      };
      ViewableBuffer2.sizeOf = function(type2) {
        switch (type2) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(type2 + " isn't a valid view type");
        }
      };
      return ViewableBuffer2;
    }();
    var AbstractBatchRenderer = function(_super) {
      __extends(AbstractBatchRenderer2, _super);
      function AbstractBatchRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = null;
        _this.geometryClass = null;
        _this.vertexSize = null;
        _this.state = State2.for2d();
        _this.size = settings2.settings.SPRITE_BATCH_SIZE * 4;
        _this._vertexCount = 0;
        _this._indexCount = 0;
        _this._bufferedElements = [];
        _this._bufferedTextures = [];
        _this._bufferSize = 0;
        _this._shader = null;
        _this._packedGeometries = [];
        _this._packedGeometryPoolSize = 2;
        _this._flushId = 0;
        _this._aBuffers = {};
        _this._iBuffers = {};
        _this.MAX_TEXTURES = 1;
        _this.renderer.on("prerender", _this.onPrerender, _this);
        renderer.runners.contextChange.add(_this);
        _this._dcIndex = 0;
        _this._aIndex = 0;
        _this._iIndex = 0;
        _this._attributeBuffer = null;
        _this._indexBuffer = null;
        _this._tempBoundTextures = [];
        return _this;
      }
      AbstractBatchRenderer2.prototype.contextChange = function() {
        var gl = this.renderer.gl;
        if (settings2.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
          this.MAX_TEXTURES = 1;
        } else {
          this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings2.settings.SPRITE_MAX_TEXTURES);
          this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
          this._packedGeometries[i2] = new this.geometryClass();
        }
        this.initFlushBuffers();
      };
      AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
        var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
        var MAX_SPRITES = this.size / 4;
        var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
        while (_drawCallPool.length < MAX_SPRITES) {
          _drawCallPool.push(new BatchDrawCall());
        }
        while (_textureArrayPool.length < MAX_TA) {
          _textureArrayPool.push(new BatchTextureArray());
        }
        for (var i2 = 0; i2 < this.MAX_TEXTURES; i2++) {
          this._tempBoundTextures[i2] = null;
        }
      };
      AbstractBatchRenderer2.prototype.onPrerender = function() {
        this._flushId = 0;
      };
      AbstractBatchRenderer2.prototype.render = function(element) {
        if (!element._texture.valid) {
          return;
        }
        if (this._vertexCount + element.vertexData.length / 2 > this.size) {
          this.flush();
        }
        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
        this._bufferedElements[this._bufferSize++] = element;
      };
      AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
        var _a = this, textures = _a._bufferedTextures, MAX_TEXTURES = _a.MAX_TEXTURES;
        var textureArrays = AbstractBatchRenderer2._textureArrayPool;
        var batch = this.renderer.batch;
        var boundTextures = this._tempBoundTextures;
        var touch = this.renderer.textureGC.count;
        var TICK = ++BaseTexture._globalBatch;
        var countTexArrays = 0;
        var texArray = textureArrays[0];
        var start = 0;
        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
        for (var i2 = 0; i2 < this._bufferSize; ++i2) {
          var tex = textures[i2];
          textures[i2] = null;
          if (tex._batchEnabled === TICK) {
            continue;
          }
          if (texArray.count >= MAX_TEXTURES) {
            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
            this.buildDrawCalls(texArray, start, i2);
            start = i2;
            texArray = textureArrays[++countTexArrays];
            ++TICK;
          }
          tex._batchEnabled = TICK;
          tex.touched = touch;
          texArray.elements[texArray.count++] = tex;
        }
        if (texArray.count > 0) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, this._bufferSize);
          ++countTexArrays;
          ++TICK;
        }
        for (var i2 = 0; i2 < boundTextures.length; i2++) {
          boundTextures[i2] = null;
        }
        BaseTexture._globalBatch = TICK;
      };
      AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
        var _a = this, elements = _a._bufferedElements, _attributeBuffer = _a._attributeBuffer, _indexBuffer = _a._indexBuffer, vertexSize = _a.vertexSize;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var dcIndex = this._dcIndex;
        var aIndex = this._aIndex;
        var iIndex = this._iIndex;
        var drawCall = drawCalls[dcIndex];
        drawCall.start = this._iIndex;
        drawCall.texArray = texArray;
        for (var i2 = start; i2 < finish; ++i2) {
          var sprite = elements[i2];
          var tex = sprite._texture.baseTexture;
          var spriteBlendMode = utils6.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
          elements[i2] = null;
          if (start < i2 && drawCall.blend !== spriteBlendMode) {
            drawCall.size = iIndex - drawCall.start;
            start = i2;
            drawCall = drawCalls[++dcIndex];
            drawCall.texArray = texArray;
            drawCall.start = iIndex;
          }
          this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
          aIndex += sprite.vertexData.length / 2 * vertexSize;
          iIndex += sprite.indices.length;
          drawCall.blend = spriteBlendMode;
        }
        if (start < finish) {
          drawCall.size = iIndex - drawCall.start;
          ++dcIndex;
        }
        this._dcIndex = dcIndex;
        this._aIndex = aIndex;
        this._iIndex = iIndex;
      };
      AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
        var textureSystem = this.renderer.texture;
        for (var j2 = 0; j2 < texArray.count; j2++) {
          textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
          texArray.elements[j2] = null;
        }
        texArray.count = 0;
      };
      AbstractBatchRenderer2.prototype.updateGeometry = function() {
        var _a = this, packedGeometries = _a._packedGeometries, attributeBuffer = _a._attributeBuffer, indexBuffer = _a._indexBuffer;
        if (!settings2.settings.CAN_UPLOAD_SAME_BUFFER) {
          if (this._packedGeometryPoolSize <= this._flushId) {
            this._packedGeometryPoolSize++;
            packedGeometries[this._flushId] = new this.geometryClass();
          }
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.bind(packedGeometries[this._flushId]);
          this.renderer.geometry.updateBuffers();
          this._flushId++;
        } else {
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.updateBuffers();
        }
      };
      AbstractBatchRenderer2.prototype.drawBatches = function() {
        var dcCount = this._dcIndex;
        var _a = this.renderer, gl = _a.gl, stateSystem = _a.state;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var curTexArray = null;
        for (var i2 = 0; i2 < dcCount; i2++) {
          var _b = drawCalls[i2], texArray = _b.texArray, type2 = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
          if (curTexArray !== texArray) {
            curTexArray = texArray;
            this.bindAndClearTexArray(texArray);
          }
          this.state.blendMode = blend;
          stateSystem.set(this.state);
          gl.drawElements(type2, size, gl.UNSIGNED_SHORT, start * 2);
        }
      };
      AbstractBatchRenderer2.prototype.flush = function() {
        if (this._vertexCount === 0) {
          return;
        }
        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        this._indexBuffer = this.getIndexBuffer(this._indexCount);
        this._aIndex = 0;
        this._iIndex = 0;
        this._dcIndex = 0;
        this.buildTexturesAndDrawCalls();
        this.updateGeometry();
        this.drawBatches();
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
      };
      AbstractBatchRenderer2.prototype.start = function() {
        this.renderer.state.set(this.state);
        this.renderer.shader.bind(this._shader);
        if (settings2.settings.CAN_UPLOAD_SAME_BUFFER) {
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
      };
      AbstractBatchRenderer2.prototype.stop = function() {
        this.flush();
      };
      AbstractBatchRenderer2.prototype.destroy = function() {
        for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
          if (this._packedGeometries[i2]) {
            this._packedGeometries[i2].destroy();
          }
        }
        this.renderer.off("prerender", this.onPrerender, this);
        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._attributeBuffer = null;
        this._indexBuffer = null;
        if (this._shader) {
          this._shader.destroy();
          this._shader = null;
        }
        _super.prototype.destroy.call(this);
      };
      AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
        var roundedP2 = utils6.nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = utils6.log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this._aBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._aBuffers[roundedSize];
        if (!buffer) {
          this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
        var roundedP2 = utils6.nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = utils6.log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this._iBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._iBuffers[roundedSizeIndex];
        if (!buffer) {
          this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1);
        var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? utils6.premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
        for (var i2 = 0; i2 < vertexData.length; i2 += 2) {
          float32View[aIndex++] = vertexData[i2];
          float32View[aIndex++] = vertexData[i2 + 1];
          float32View[aIndex++] = uvs[i2];
          float32View[aIndex++] = uvs[i2 + 1];
          uint32View[aIndex++] = argb;
          float32View[aIndex++] = textureId;
        }
        for (var i2 = 0; i2 < indicies.length; i2++) {
          indexBuffer[iIndex++] = packedVertices + indicies[i2];
        }
      };
      AbstractBatchRenderer2._drawCallPool = [];
      AbstractBatchRenderer2._textureArrayPool = [];
      return AbstractBatchRenderer2;
    }(ObjectRenderer);
    var BatchShaderGenerator = function() {
      function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
        this.vertexSrc = vertexSrc;
        this.fragTemplate = fragTemplate2;
        this.programCache = {};
        this.defaultGroupCache = {};
        if (fragTemplate2.indexOf("%count%") < 0) {
          throw new Error('Fragment template must contain "%count%".');
        }
        if (fragTemplate2.indexOf("%forloop%") < 0) {
          throw new Error('Fragment template must contain "%forloop%".');
        }
      }
      BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
        if (!this.programCache[maxTextures]) {
          var sampleValues = new Int32Array(maxTextures);
          for (var i2 = 0; i2 < maxTextures; i2++) {
            sampleValues[i2] = i2;
          }
          this.defaultGroupCache[maxTextures] = UniformGroup.from({uSamplers: sampleValues}, true);
          var fragmentSrc = this.fragTemplate;
          fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
          fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
          this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new math.Matrix(),
          default: this.defaultGroupCache[maxTextures]
        };
        return new Shader(this.programCache[maxTextures], uniforms);
      };
      BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
        var src = "";
        src += "\n";
        src += "\n";
        for (var i2 = 0; i2 < maxTextures; i2++) {
          if (i2 > 0) {
            src += "\nelse ";
          }
          if (i2 < maxTextures - 1) {
            src += "if(vTextureId < " + i2 + ".5)";
          }
          src += "\n{";
          src += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);";
          src += "\n}";
        }
        src += "\n";
        src += "\n";
        return src;
      };
      return BatchShaderGenerator2;
    }();
    var BatchGeometry = function(_super) {
      __extends(BatchGeometry2, _super);
      function BatchGeometry2(_static) {
        if (_static === void 0) {
          _static = false;
        }
        var _this = _super.call(this) || this;
        _this._buffer = new Buffer2(null, _static, false);
        _this._indexBuffer = new Buffer2(null, _static, true);
        _this.addAttribute("aVertexPosition", _this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, constants.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, constants.TYPES.FLOAT).addIndex(_this._indexBuffer);
        return _this;
      }
      return BatchGeometry2;
    }(Geometry);
    var defaultVertex$3 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
    var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
    var BatchPluginFactory = function() {
      function BatchPluginFactory2() {
      }
      BatchPluginFactory2.create = function(options) {
        var _a = Object.assign({
          vertex: defaultVertex$3,
          fragment: defaultFragment$2,
          geometryClass: BatchGeometry,
          vertexSize: 6
        }, options), vertex2 = _a.vertex, fragment2 = _a.fragment, vertexSize = _a.vertexSize, geometryClass = _a.geometryClass;
        return function(_super) {
          __extends(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer);
      };
      Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$3;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
        get: function() {
          return defaultFragment$2;
        },
        enumerable: false,
        configurable: true
      });
      return BatchPluginFactory2;
    }();
    var BatchRenderer = BatchPluginFactory.create();
    var resources = {};
    var _loop_1 = function(name2) {
      Object.defineProperty(resources, name2, {
        get: function() {
          utils6.deprecation("6.0.0", "PIXI.systems." + name2 + " has moved to PIXI." + name2);
          return _resources[name2];
        }
      });
    };
    for (var name in _resources) {
      _loop_1(name);
    }
    var systems = {};
    var _loop_2 = function(name2) {
      Object.defineProperty(systems, name2, {
        get: function() {
          utils6.deprecation("6.0.0", "PIXI.resources." + name2 + " has moved to PIXI." + name2);
          return _systems[name2];
        }
      });
    };
    for (var name in _systems) {
      _loop_2(name);
    }
    exports.AbstractBatchRenderer = AbstractBatchRenderer;
    exports.AbstractMultiResource = AbstractMultiResource;
    exports.AbstractRenderer = AbstractRenderer;
    exports.ArrayResource = ArrayResource;
    exports.Attribute = Attribute;
    exports.BaseImageResource = BaseImageResource;
    exports.BaseRenderTexture = BaseRenderTexture;
    exports.BaseTexture = BaseTexture;
    exports.BatchDrawCall = BatchDrawCall;
    exports.BatchGeometry = BatchGeometry;
    exports.BatchPluginFactory = BatchPluginFactory;
    exports.BatchRenderer = BatchRenderer;
    exports.BatchShaderGenerator = BatchShaderGenerator;
    exports.BatchSystem = BatchSystem;
    exports.BatchTextureArray = BatchTextureArray;
    exports.Buffer = Buffer2;
    exports.BufferResource = BufferResource;
    exports.CanvasResource = CanvasResource;
    exports.ContextSystem = ContextSystem;
    exports.CubeResource = CubeResource;
    exports.Filter = Filter;
    exports.FilterState = FilterState;
    exports.FilterSystem = FilterSystem;
    exports.Framebuffer = Framebuffer;
    exports.FramebufferSystem = FramebufferSystem;
    exports.GLFramebuffer = GLFramebuffer;
    exports.GLProgram = GLProgram;
    exports.GLTexture = GLTexture;
    exports.Geometry = Geometry;
    exports.GeometrySystem = GeometrySystem;
    exports.IGLUniformData = IGLUniformData;
    exports.INSTALLED = INSTALLED;
    exports.ImageBitmapResource = ImageBitmapResource;
    exports.ImageResource = ImageResource;
    exports.MaskData = MaskData;
    exports.MaskSystem = MaskSystem;
    exports.ObjectRenderer = ObjectRenderer;
    exports.Program = Program;
    exports.ProjectionSystem = ProjectionSystem;
    exports.Quad = Quad;
    exports.QuadUv = QuadUv;
    exports.RenderTexture = RenderTexture;
    exports.RenderTexturePool = RenderTexturePool;
    exports.RenderTextureSystem = RenderTextureSystem;
    exports.Renderer = Renderer;
    exports.Resource = Resource;
    exports.SVGResource = SVGResource;
    exports.ScissorSystem = ScissorSystem;
    exports.Shader = Shader;
    exports.ShaderSystem = ShaderSystem;
    exports.SpriteMaskFilter = SpriteMaskFilter;
    exports.State = State2;
    exports.StateSystem = StateSystem;
    exports.StencilSystem = StencilSystem;
    exports.System = System;
    exports.Texture = Texture2;
    exports.TextureGCSystem = TextureGCSystem;
    exports.TextureMatrix = TextureMatrix;
    exports.TextureSystem = TextureSystem;
    exports.TextureUvs = TextureUvs;
    exports.UniformGroup = UniformGroup;
    exports.VideoResource = VideoResource;
    exports.ViewableBuffer = ViewableBuffer;
    exports.autoDetectRenderer = autoDetectRenderer;
    exports.autoDetectResource = autoDetectResource;
    exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;
    exports.defaultFilterVertex = defaultFilterVertex;
    exports.defaultVertex = defaultVertex$2;
    exports.resources = resources;
    exports.systems = systems;
    exports.uniformParsers = uniformParsers;
  });

  // node_modules/@pixi/loaders/dist/cjs/loaders.js
  var require_loaders = __commonJS((exports) => {
    /*!
     * @pixi/loaders - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/loaders is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var resourceLoader = require_resource_loader_cjs();
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var TextureLoader = function() {
      function TextureLoader2() {
      }
      TextureLoader2.add = function() {
        resourceLoader.Resource.setExtensionLoadType("svg", resourceLoader.Resource.LOAD_TYPE.XHR);
        resourceLoader.Resource.setExtensionXhrType("svg", resourceLoader.Resource.XHR_RESPONSE_TYPE.TEXT);
      };
      TextureLoader2.use = function(resource, next) {
        if (resource.data && (resource.type === resourceLoader.Resource.TYPE.IMAGE || resource.extension === "svg")) {
          var data = resource.data, url = resource.url, name = resource.name, metadata = resource.metadata;
          core.Texture.fromLoader(data, url, name, metadata).then(function(texture) {
            resource.texture = texture;
            next();
          }).catch(next);
        } else {
          next();
        }
      };
      return TextureLoader2;
    }();
    var Loader = function(_super) {
      __extends(Loader2, _super);
      function Loader2(baseUrl, concurrency) {
        var _this = _super.call(this, baseUrl, concurrency) || this;
        for (var i2 = 0; i2 < Loader2._plugins.length; ++i2) {
          var plugin = Loader2._plugins[i2];
          var pre = plugin.pre, use = plugin.use;
          if (pre) {
            _this.pre(pre);
          }
          if (use) {
            _this.use(use);
          }
        }
        _this._protected = false;
        return _this;
      }
      Loader2.prototype.destroy = function() {
        if (!this._protected) {
          this.reset();
        }
      };
      Object.defineProperty(Loader2, "shared", {
        get: function() {
          var shared = Loader2._shared;
          if (!shared) {
            shared = new Loader2();
            shared._protected = true;
            Loader2._shared = shared;
          }
          return shared;
        },
        enumerable: false,
        configurable: true
      });
      Loader2.registerPlugin = function(plugin) {
        Loader2._plugins.push(plugin);
        if (plugin.add) {
          plugin.add();
        }
        return Loader2;
      };
      Loader2._plugins = [];
      return Loader2;
    }(resourceLoader.Loader);
    Loader.registerPlugin({use: resourceLoader.middleware.parsing});
    Loader.registerPlugin(TextureLoader);
    var AppLoaderPlugin = function() {
      function AppLoaderPlugin2() {
      }
      AppLoaderPlugin2.init = function(options) {
        options = Object.assign({
          sharedLoader: false
        }, options);
        this.loader = options.sharedLoader ? Loader.shared : new Loader();
      };
      AppLoaderPlugin2.destroy = function() {
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
      };
      return AppLoaderPlugin2;
    }();
    var LoaderResource = resourceLoader.Resource;
    exports.AppLoaderPlugin = AppLoaderPlugin;
    exports.Loader = Loader;
    exports.LoaderResource = LoaderResource;
    exports.TextureLoader = TextureLoader;
  });

  // node_modules/promise-polyfill/lib/index.js
  var require_lib = __commonJS((exports, module) => {
    "use strict";
    function finallyConstructor(callback) {
      var constructor = this.constructor;
      return this.then(function(value) {
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      }, function(reason) {
        return constructor.resolve(callback()).then(function() {
          return constructor.reject(reason);
        });
      });
    }
    function allSettled(arr) {
      var P2 = this;
      return new P2(function(resolve2, reject2) {
        if (!(arr && typeof arr.length !== "undefined")) {
          return reject2(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
        }
        var args = Array.prototype.slice.call(arr);
        if (args.length === 0)
          return resolve2([]);
        var remaining = args.length;
        function res(i3, val) {
          if (val && (typeof val === "object" || typeof val === "function")) {
            var then = val.then;
            if (typeof then === "function") {
              then.call(val, function(val2) {
                res(i3, val2);
              }, function(e2) {
                args[i3] = {status: "rejected", reason: e2};
                if (--remaining === 0) {
                  resolve2(args);
                }
              });
              return;
            }
          }
          args[i3] = {status: "fulfilled", value: val};
          if (--remaining === 0) {
            resolve2(args);
          }
        }
        for (var i2 = 0; i2 < args.length; i2++) {
          res(i2, args[i2]);
        }
      });
    }
    var setTimeoutFunc = setTimeout;
    function isArray(x2) {
      return Boolean(x2 && typeof x2.length !== "undefined");
    }
    function noop() {
    }
    function bind(fn, thisArg) {
      return function() {
        fn.apply(thisArg, arguments);
      };
    }
    function Promise2(fn) {
      if (!(this instanceof Promise2))
        throw new TypeError("Promises must be constructed via new");
      if (typeof fn !== "function")
        throw new TypeError("not a function");
      this._state = 0;
      this._handled = false;
      this._value = void 0;
      this._deferreds = [];
      doResolve(fn, this);
    }
    function handle(self2, deferred) {
      while (self2._state === 3) {
        self2 = self2._value;
      }
      if (self2._state === 0) {
        self2._deferreds.push(deferred);
        return;
      }
      self2._handled = true;
      Promise2._immediateFn(function() {
        var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          (self2._state === 1 ? resolve : reject)(deferred.promise, self2._value);
          return;
        }
        var ret;
        try {
          ret = cb(self2._value);
        } catch (e2) {
          reject(deferred.promise, e2);
          return;
        }
        resolve(deferred.promise, ret);
      });
    }
    function resolve(self2, newValue) {
      try {
        if (newValue === self2)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
          var then = newValue.then;
          if (newValue instanceof Promise2) {
            self2._state = 3;
            self2._value = newValue;
            finale(self2);
            return;
          } else if (typeof then === "function") {
            doResolve(bind(then, newValue), self2);
            return;
          }
        }
        self2._state = 1;
        self2._value = newValue;
        finale(self2);
      } catch (e2) {
        reject(self2, e2);
      }
    }
    function reject(self2, newValue) {
      self2._state = 2;
      self2._value = newValue;
      finale(self2);
    }
    function finale(self2) {
      if (self2._state === 2 && self2._deferreds.length === 0) {
        Promise2._immediateFn(function() {
          if (!self2._handled) {
            Promise2._unhandledRejectionFn(self2._value);
          }
        });
      }
      for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {
        handle(self2, self2._deferreds[i2]);
      }
      self2._deferreds = null;
    }
    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
      this.onRejected = typeof onRejected === "function" ? onRejected : null;
      this.promise = promise;
    }
    function doResolve(fn, self2) {
      var done = false;
      try {
        fn(function(value) {
          if (done)
            return;
          done = true;
          resolve(self2, value);
        }, function(reason) {
          if (done)
            return;
          done = true;
          reject(self2, reason);
        });
      } catch (ex) {
        if (done)
          return;
        done = true;
        reject(self2, ex);
      }
    }
    Promise2.prototype["catch"] = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      var prom = new this.constructor(noop);
      handle(this, new Handler(onFulfilled, onRejected, prom));
      return prom;
    };
    Promise2.prototype["finally"] = finallyConstructor;
    Promise2.all = function(arr) {
      return new Promise2(function(resolve2, reject2) {
        if (!isArray(arr)) {
          return reject2(new TypeError("Promise.all accepts an array"));
        }
        var args = Array.prototype.slice.call(arr);
        if (args.length === 0)
          return resolve2([]);
        var remaining = args.length;
        function res(i3, val) {
          try {
            if (val && (typeof val === "object" || typeof val === "function")) {
              var then = val.then;
              if (typeof then === "function") {
                then.call(val, function(val2) {
                  res(i3, val2);
                }, reject2);
                return;
              }
            }
            args[i3] = val;
            if (--remaining === 0) {
              resolve2(args);
            }
          } catch (ex) {
            reject2(ex);
          }
        }
        for (var i2 = 0; i2 < args.length; i2++) {
          res(i2, args[i2]);
        }
      });
    };
    Promise2.allSettled = allSettled;
    Promise2.resolve = function(value) {
      if (value && typeof value === "object" && value.constructor === Promise2) {
        return value;
      }
      return new Promise2(function(resolve2) {
        resolve2(value);
      });
    };
    Promise2.reject = function(value) {
      return new Promise2(function(resolve2, reject2) {
        reject2(value);
      });
    };
    Promise2.race = function(arr) {
      return new Promise2(function(resolve2, reject2) {
        if (!isArray(arr)) {
          return reject2(new TypeError("Promise.race accepts an array"));
        }
        for (var i2 = 0, len = arr.length; i2 < len; i2++) {
          Promise2.resolve(arr[i2]).then(resolve2, reject2);
        }
      });
    };
    Promise2._immediateFn = typeof setImmediate === "function" && function(fn) {
      setImmediate(fn);
    } || function(fn) {
      setTimeoutFunc(fn, 0);
    };
    Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
      if (typeof console !== "undefined" && console) {
        console.warn("Possible Unhandled Promise Rejection:", err);
      }
    };
    module.exports = Promise2;
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS((exports, module) => {
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from = Object(arguments[s3]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  });

  // node_modules/@pixi/polyfill/dist/cjs/polyfill.js
  var require_polyfill = __commonJS(() => {
    /*!
     * @pixi/polyfill - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/polyfill is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Polyfill = _interopDefault(require_lib());
    var objectAssign = _interopDefault(require_object_assign());
    if (!self.Promise) {
      self.Promise = Polyfill;
    }
    if (!Object.assign) {
      Object.assign = objectAssign;
    }
    var ONE_FRAME_TIME = 16;
    if (!(Date.now && Date.prototype.getTime)) {
      Date.now = function now() {
        return new Date().getTime();
      };
    }
    if (!(self.performance && self.performance.now)) {
      startTime_1 = Date.now();
      if (!self.performance) {
        self.performance = {};
      }
      self.performance.now = function() {
        return Date.now() - startTime_1;
      };
    }
    var startTime_1;
    var lastTime = Date.now();
    var vendors = ["ms", "moz", "webkit", "o"];
    for (var x2 = 0; x2 < vendors.length && !self.requestAnimationFrame; ++x2) {
      p2 = vendors[x2];
      self.requestAnimationFrame = self[p2 + "RequestAnimationFrame"];
      self.cancelAnimationFrame = self[p2 + "CancelAnimationFrame"] || self[p2 + "CancelRequestAnimationFrame"];
    }
    var p2;
    if (!self.requestAnimationFrame) {
      self.requestAnimationFrame = function(callback) {
        if (typeof callback !== "function") {
          throw new TypeError(callback + "is not a function");
        }
        var currentTime = Date.now();
        var delay = ONE_FRAME_TIME + lastTime - currentTime;
        if (delay < 0) {
          delay = 0;
        }
        lastTime = currentTime;
        return self.setTimeout(function() {
          lastTime = Date.now();
          callback(performance.now());
        }, delay);
      };
    }
    if (!self.cancelAnimationFrame) {
      self.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
    if (!Math.sign) {
      Math.sign = function mathSign(x3) {
        x3 = Number(x3);
        if (x3 === 0 || isNaN(x3)) {
          return x3;
        }
        return x3 > 0 ? 1 : -1;
      };
    }
    if (!Number.isInteger) {
      Number.isInteger = function numberIsInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
    }
    if (!self.ArrayBuffer) {
      self.ArrayBuffer = Array;
    }
    if (!self.Float32Array) {
      self.Float32Array = Array;
    }
    if (!self.Uint32Array) {
      self.Uint32Array = Array;
    }
    if (!self.Uint16Array) {
      self.Uint16Array = Array;
    }
    if (!self.Uint8Array) {
      self.Uint8Array = Array;
    }
    if (!self.Int32Array) {
      self.Int32Array = Array;
    }
  });

  // node_modules/@pixi/display/dist/cjs/display.js
  var require_display = __commonJS((exports) => {
    /*!
     * @pixi/display - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/display is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var settings2 = require_settings();
    var math = require_math();
    var utils6 = require_utils();
    settings2.settings.SORTABLE_CHILDREN = false;
    var Bounds = function() {
      function Bounds2() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.rect = null;
        this.updateID = -1;
      }
      Bounds2.prototype.isEmpty = function() {
        return this.minX > this.maxX || this.minY > this.maxY;
      };
      Bounds2.prototype.clear = function() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
      };
      Bounds2.prototype.getRectangle = function(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
          return math.Rectangle.EMPTY;
        }
        rect = rect || new math.Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
      };
      Bounds2.prototype.addPoint = function(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
      };
      Bounds2.prototype.addPointMatrix = function(matrix, point) {
        var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
        var x2 = a2 * point.x + c2 * point.y + tx;
        var y2 = b2 * point.x + d2 * point.y + ty;
        this.minX = Math.min(this.minX, x2);
        this.maxX = Math.max(this.maxX, x2);
        this.minY = Math.min(this.minY, y2);
        this.maxY = Math.max(this.maxY, y2);
      };
      Bounds2.prototype.addQuad = function(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = vertices[0];
        var y2 = vertices[1];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[2];
        y2 = vertices[3];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[4];
        y2 = vertices[5];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[6];
        y2 = vertices[7];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
      };
      Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
        var a2 = matrix.a;
        var b2 = matrix.b;
        var c2 = matrix.c;
        var d2 = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = a2 * x0 + c2 * y0 + tx;
        var y2 = b2 * x0 + d2 * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x1 + c2 * y0 + tx;
        y2 = b2 * x1 + d2 * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x0 + c2 * y1 + tx;
        y2 = b2 * x0 + d2 * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x1 + c2 * y1 + tx;
        y2 = b2 * x1 + d2 * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
          var x2 = vertexData[i2];
          var y2 = vertexData[i2 + 1];
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
      };
      Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
        if (padX === void 0) {
          padX = 0;
        }
        if (padY === void 0) {
          padY = padX;
        }
        var a2 = matrix.a;
        var b2 = matrix.b;
        var c2 = matrix.c;
        var d2 = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
          var rawX = vertices[i2];
          var rawY = vertices[i2 + 1];
          var x2 = a2 * rawX + c2 * rawY + tx;
          var y2 = d2 * rawY + b2 * rawX + ty;
          minX = Math.min(minX, x2 - padX);
          maxX = Math.max(maxX, x2 + padX);
          minY = Math.min(minY, y2 - padY);
          maxY = Math.max(maxY, y2 + padY);
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addBounds = function(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
      };
      Bounds2.prototype.addBoundsMask = function(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      };
      Bounds2.prototype.addBoundsArea = function(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        if (!this.isEmpty()) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
        }
      };
      Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
        x0 -= padX;
        y0 -= padY;
        x1 += padX;
        y1 += padY;
        this.minX = this.minX < x0 ? this.minX : x0;
        this.maxX = this.maxX > x1 ? this.maxX : x1;
        this.minY = this.minY < y0 ? this.minY : y0;
        this.maxY = this.maxY > y1 ? this.maxY : y1;
      };
      return Bounds2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var DisplayObject = function(_super) {
      __extends(DisplayObject2, _super);
      function DisplayObject2() {
        var _this = _super.call(this) || this;
        _this.tempDisplayObjectParent = null;
        _this.transform = new math.Transform();
        _this.alpha = 1;
        _this.visible = true;
        _this.renderable = true;
        _this.parent = null;
        _this.worldAlpha = 1;
        _this._lastSortedIndex = 0;
        _this._zIndex = 0;
        _this.filterArea = null;
        _this.filters = null;
        _this._enabledFilters = null;
        _this._bounds = new Bounds();
        _this._localBounds = null;
        _this._boundsID = 0;
        _this._boundsRect = null;
        _this._localBoundsRect = null;
        _this._mask = null;
        _this._destroyed = false;
        _this.isSprite = false;
        _this.isMask = false;
        return _this;
      }
      DisplayObject2.mixin = function(source) {
        var keys = Object.keys(source);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var propertyName = keys[i2];
          Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      };
      DisplayObject2.prototype._recursivePostUpdateTransform = function() {
        if (this.parent) {
          this.parent._recursivePostUpdateTransform();
          this.transform.updateTransform(this.parent.transform);
        } else {
          this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
      };
      DisplayObject2.prototype.updateTransform = function() {
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
      };
      DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
        if (!skipUpdate) {
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
          } else {
            this._recursivePostUpdateTransform();
            this.updateTransform();
          }
        }
        if (this._bounds.updateID !== this._boundsID) {
          this.calculateBounds();
          this._bounds.updateID = this._boundsID;
        }
        if (!rect) {
          if (!this._boundsRect) {
            this._boundsRect = new math.Rectangle();
          }
          rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
      };
      DisplayObject2.prototype.getLocalBounds = function(rect) {
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new math.Rectangle();
          }
          rect = this._localBoundsRect;
        }
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        var worldBounds = this._bounds;
        var worldBoundsID = this._boundsID;
        this._bounds = this._localBounds;
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        this._bounds = worldBounds;
        this._bounds.updateID += this._boundsID - worldBoundsID;
        return bounds;
      };
      DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
          skipUpdate = false;
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.apply(position, point);
      };
      DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.applyInverse(position, point);
      };
      DisplayObject2.prototype.setParent = function(container) {
        if (!container || !container.addChild) {
          throw new Error("setParent: Argument must be a Container");
        }
        container.addChild(this);
        return container;
      };
      DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
        if (skewX === void 0) {
          skewX = 0;
        }
        if (skewY === void 0) {
          skewY = 0;
        }
        if (pivotX === void 0) {
          pivotX = 0;
        }
        if (pivotY === void 0) {
          pivotY = 0;
        }
        this.position.x = x2;
        this.position.y = y2;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
      };
      DisplayObject2.prototype.destroy = function(_options) {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.removeAllListeners();
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._mask = null;
        this.filters = null;
        this.filterArea = null;
        this.hitArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
      };
      Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
        get: function() {
          if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new TemporaryDisplayObject();
          }
          return this.tempDisplayObjectParent;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject2.prototype.enableTempParent = function() {
        var myParent = this.parent;
        this.parent = this._tempDisplayObjectParent;
        return myParent;
      };
      DisplayObject2.prototype.disableTempParent = function(cacheParent) {
        this.parent = cacheParent;
      };
      Object.defineProperty(DisplayObject2.prototype, "x", {
        get: function() {
          return this.position.x;
        },
        set: function(value) {
          this.transform.position.x = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "y", {
        get: function() {
          return this.position.y;
        },
        set: function(value) {
          this.transform.position.y = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
        get: function() {
          return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "localTransform", {
        get: function() {
          return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "position", {
        get: function() {
          return this.transform.position;
        },
        set: function(value) {
          this.transform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "scale", {
        get: function() {
          return this.transform.scale;
        },
        set: function(value) {
          this.transform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "pivot", {
        get: function() {
          return this.transform.pivot;
        },
        set: function(value) {
          this.transform.pivot.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "skew", {
        get: function() {
          return this.transform.skew;
        },
        set: function(value) {
          this.transform.skew.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "rotation", {
        get: function() {
          return this.transform.rotation;
        },
        set: function(value) {
          this.transform.rotation = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "angle", {
        get: function() {
          return this.transform.rotation * math.RAD_TO_DEG;
        },
        set: function(value) {
          this.transform.rotation = value * math.DEG_TO_RAD;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "zIndex", {
        get: function() {
          return this._zIndex;
        },
        set: function(value) {
          this._zIndex = value;
          if (this.parent) {
            this.parent.sortDirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
        get: function() {
          var item = this;
          do {
            if (!item.visible) {
              return false;
            }
            item = item.parent;
          } while (item);
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "mask", {
        get: function() {
          return this._mask;
        },
        set: function(value) {
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
          this._mask = value;
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      return DisplayObject2;
    }(utils6.EventEmitter);
    var TemporaryDisplayObject = function(_super) {
      __extends(TemporaryDisplayObject2, _super);
      function TemporaryDisplayObject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortDirty = null;
        return _this;
      }
      return TemporaryDisplayObject2;
    }(DisplayObject);
    DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
    function sortChildren(a2, b2) {
      if (a2.zIndex === b2.zIndex) {
        return a2._lastSortedIndex - b2._lastSortedIndex;
      }
      return a2.zIndex - b2.zIndex;
    }
    var Container8 = function(_super) {
      __extends(Container9, _super);
      function Container9() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.sortableChildren = settings2.settings.SORTABLE_CHILDREN;
        _this.sortDirty = false;
        return _this;
      }
      Container9.prototype.onChildrenChange = function(_length) {
      };
      Container9.prototype.addChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
        } else {
          var child = children[0];
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.sortDirty = true;
          child.transform._parentID = -1;
          this.children.push(child);
          this._boundsID++;
          this.onChildrenChange(this.children.length - 1);
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
        }
        return children[0];
      };
      Container9.prototype.addChildAt = function(child, index) {
        if (index < 0 || index > this.children.length) {
          throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("added", this);
        this.emit("childAdded", child, this, index);
        return child;
      };
      Container9.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      };
      Container9.prototype.getChildIndex = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index;
      };
      Container9.prototype.setChildIndex = function(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
        }
        var currentIndex = this.getChildIndex(child);
        utils6.removeItems(this.children, currentIndex, 1);
        this.children.splice(index, 0, child);
        this.onChildrenChange(index);
      };
      Container9.prototype.getChildAt = function(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("getChildAt: Index (" + index + ") does not exist.");
        }
        return this.children[index];
      };
      Container9.prototype.removeChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
        } else {
          var child = children[0];
          var index = this.children.indexOf(child);
          if (index === -1) {
            return null;
          }
          child.parent = null;
          child.transform._parentID = -1;
          utils6.removeItems(this.children, index, 1);
          this._boundsID++;
          this.onChildrenChange(index);
          child.emit("removed", this);
          this.emit("childRemoved", child, this, index);
        }
        return children[0];
      };
      Container9.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        child.parent = null;
        child.transform._parentID = -1;
        utils6.removeItems(this.children, index, 1);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index);
        return child;
      };
      Container9.prototype.removeChildren = function(beginIndex, endIndex) {
        if (beginIndex === void 0) {
          beginIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = this.children.length;
        }
        var begin = beginIndex;
        var end = endIndex;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
          removed = this.children.splice(begin, range);
          for (var i2 = 0; i2 < removed.length; ++i2) {
            removed[i2].parent = null;
            if (removed[i2].transform) {
              removed[i2].transform._parentID = -1;
            }
          }
          this._boundsID++;
          this.onChildrenChange(beginIndex);
          for (var i2 = 0; i2 < removed.length; ++i2) {
            removed[i2].emit("removed", this);
            this.emit("childRemoved", removed[i2], this, i2);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return [];
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      };
      Container9.prototype.sortChildren = function() {
        var sortRequired = false;
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          var child = this.children[i2];
          child._lastSortedIndex = i2;
          if (!sortRequired && child.zIndex !== 0) {
            sortRequired = true;
          }
        }
        if (sortRequired && this.children.length > 1) {
          this.children.sort(sortChildren);
        }
        this.sortDirty = false;
      };
      Container9.prototype.updateTransform = function() {
        if (this.sortableChildren && this.sortDirty) {
          this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          var child = this.children[i2];
          if (child.visible) {
            child.updateTransform();
          }
        }
      };
      Container9.prototype.calculateBounds = function() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i2 = 0; i2 < this.children.length; i2++) {
          var child = this.children[i2];
          if (!child.visible || !child.renderable) {
            continue;
          }
          child.calculateBounds();
          if (child._mask) {
            var maskObject = child._mask.maskObject || child._mask;
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else if (child.filterArea) {
            this._bounds.addBoundsArea(child._bounds, child.filterArea);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        }
        this._bounds.updateID = this._boundsID;
      };
      Container9.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
        if (skipChildrenUpdate === void 0) {
          skipChildrenUpdate = false;
        }
        var result = _super.prototype.getLocalBounds.call(this, rect);
        if (!skipChildrenUpdate) {
          for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
            var child = this.children[i2];
            if (child.visible) {
              child.updateTransform();
            }
          }
        }
        return result;
      };
      Container9.prototype._calculateBounds = function() {
      };
      Container9.prototype.render = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask || this.filters && this.filters.length) {
          this.renderAdvanced(renderer);
        } else {
          this._render(renderer);
          for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
            this.children[i2].render(renderer);
          }
        }
      };
      Container9.prototype.renderAdvanced = function(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        if (filters) {
          if (!this._enabledFilters) {
            this._enabledFilters = [];
          }
          this._enabledFilters.length = 0;
          for (var i2 = 0; i2 < filters.length; i2++) {
            if (filters[i2].enabled) {
              this._enabledFilters.push(filters[i2]);
            }
          }
          if (this._enabledFilters.length) {
            renderer.filter.push(this, this._enabledFilters);
          }
        }
        if (mask) {
          renderer.mask.push(this, this._mask);
        }
        this._render(renderer);
        for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
          this.children[i2].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
          renderer.mask.pop(this);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.pop();
        }
      };
      Container9.prototype._render = function(_renderer) {
      };
      Container9.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this);
        this.sortDirty = false;
        var destroyChildren = typeof options === "boolean" ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (var i2 = 0; i2 < oldChildren.length; ++i2) {
            oldChildren[i2].destroy(options);
          }
        }
      };
      Object.defineProperty(Container9.prototype, "width", {
        get: function() {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
          var width = this.getLocalBounds().width;
          if (width !== 0) {
            this.scale.x = value / width;
          } else {
            this.scale.x = 1;
          }
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Container9.prototype, "height", {
        get: function() {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
          var height = this.getLocalBounds().height;
          if (height !== 0) {
            this.scale.y = value / height;
          } else {
            this.scale.y = 1;
          }
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      return Container9;
    }(DisplayObject);
    Container8.prototype.containerUpdateTransform = Container8.prototype.updateTransform;
    exports.Bounds = Bounds;
    exports.Container = Container8;
    exports.DisplayObject = DisplayObject;
    exports.TemporaryDisplayObject = TemporaryDisplayObject;
  });

  // node_modules/@pixi/accessibility/dist/cjs/accessibility.js
  var require_accessibility = __commonJS((exports) => {
    /*!
     * @pixi/accessibility - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/accessibility is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var display = require_display();
    var utils6 = require_utils();
    var accessibleTarget = {
      accessible: false,
      accessibleTitle: null,
      accessibleHint: null,
      tabIndex: 0,
      _accessibleActive: false,
      _accessibleDiv: null,
      accessibleType: "button",
      accessiblePointerEvents: "auto",
      accessibleChildren: true,
      renderId: -1
    };
    display.DisplayObject.mixin(accessibleTarget);
    var KEY_CODE_TAB = 9;
    var DIV_TOUCH_SIZE = 100;
    var DIV_TOUCH_POS_X = 0;
    var DIV_TOUCH_POS_Y = 0;
    var DIV_TOUCH_ZINDEX = 2;
    var DIV_HOOK_SIZE = 1;
    var DIV_HOOK_POS_X = -1e3;
    var DIV_HOOK_POS_Y = -1e3;
    var DIV_HOOK_ZINDEX = 2;
    var AccessibilityManager = function() {
      function AccessibilityManager2(renderer) {
        this.debug = false;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this.pool = [];
        this.renderId = 0;
        this.children = [];
        this.androidUpdateCount = 0;
        this.androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (utils6.isMobile.tablet || utils6.isMobile.phone) {
          this.createTouchHook();
        }
        var div = document.createElement("div");
        div.style.width = DIV_TOUCH_SIZE + "px";
        div.style.height = DIV_TOUCH_SIZE + "px";
        div.style.position = "absolute";
        div.style.top = DIV_TOUCH_POS_X + "px";
        div.style.left = DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this.div = div;
        this.renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        self.addEventListener("keydown", this._onKeyDown, false);
      }
      Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
        get: function() {
          return this._isActive;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
        get: function() {
          return this._isMobileAccessibility;
        },
        enumerable: false,
        configurable: true
      });
      AccessibilityManager2.prototype.createTouchHook = function() {
        var _this = this;
        var hookDiv = document.createElement("button");
        hookDiv.style.width = DIV_HOOK_SIZE + "px";
        hookDiv.style.height = DIV_HOOK_SIZE + "px";
        hookDiv.style.position = "absolute";
        hookDiv.style.top = DIV_HOOK_POS_X + "px";
        hookDiv.style.left = DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", function() {
          _this._isMobileAccessibility = true;
          _this.activate();
          _this.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      };
      AccessibilityManager2.prototype.destroyTouchHook = function() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      };
      AccessibilityManager2.prototype.activate = function() {
        var _a;
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        self.document.addEventListener("mousemove", this._onMouseMove, true);
        self.removeEventListener("keydown", this._onKeyDown, false);
        this.renderer.on("postrender", this.update, this);
        (_a = this.renderer.view.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this.div);
      };
      AccessibilityManager2.prototype.deactivate = function() {
        var _a;
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        self.document.removeEventListener("mousemove", this._onMouseMove, true);
        self.addEventListener("keydown", this._onKeyDown, false);
        this.renderer.off("postrender", this.update);
        (_a = this.div.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.div);
      };
      AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
        if (!displayObject.visible || !displayObject.accessibleChildren) {
          return;
        }
        if (displayObject.accessible && displayObject.interactive) {
          if (!displayObject._accessibleActive) {
            this.addChild(displayObject);
          }
          displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i2 = 0; i2 < children.length; i2++) {
          this.updateAccessibleObjects(children[i2]);
        }
      };
      AccessibilityManager2.prototype.update = function() {
        var now = performance.now();
        if (utils6.isMobile.android.device && now < this.androidUpdateCount) {
          return;
        }
        this.androidUpdateCount = now + this.androidUpdateFrequency;
        if (!this.renderer.renderingToScreen) {
          return;
        }
        if (this.renderer._lastObjectRendered) {
          this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        }
        var _a = this.renderer.view.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
        var _b = this.renderer, viewWidth = _b.width, viewHeight = _b.height, resolution = _b.resolution;
        var sx = width / viewWidth * resolution;
        var sy = height / viewHeight * resolution;
        var div = this.div;
        div.style.left = left + "px";
        div.style.top = top + "px";
        div.style.width = viewWidth + "px";
        div.style.height = viewHeight + "px";
        for (var i2 = 0; i2 < this.children.length; i2++) {
          var child = this.children[i2];
          if (child.renderId !== this.renderId) {
            child._accessibleActive = false;
            utils6.removeItems(this.children, i2, 1);
            this.div.removeChild(child._accessibleDiv);
            this.pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i2--;
          } else {
            div = child._accessibleDiv;
            var hitArea = child.hitArea;
            var wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
              div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
              div.style.width = hitArea.width * wt.a * sx + "px";
              div.style.height = hitArea.height * wt.d * sy + "px";
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = hitArea.x * sx + "px";
              div.style.top = hitArea.y * sy + "px";
              div.style.width = hitArea.width * sx + "px";
              div.style.height = hitArea.height * sy + "px";
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this.renderId++;
      };
      AccessibilityManager2.prototype.updateDebugHTML = function(div) {
        div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
      };
      AccessibilityManager2.prototype.capHitArea = function(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        var _a = this.renderer, viewWidth = _a.width, viewHeight = _a.height;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      };
      AccessibilityManager2.prototype.addChild = function(displayObject) {
        var div = this.pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = DIV_TOUCH_SIZE + "px";
          div.style.height = DIV_TOUCH_SIZE + "px";
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = displayObject.accessiblePointerEvents;
        div.type = displayObject.accessibleType;
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
          div.title = displayObject.accessibleTitle;
        } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
          div.title = "displayObject " + displayObject.tabIndex;
        }
        if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
          div.setAttribute("aria-label", displayObject.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
      };
      AccessibilityManager2.prototype._onClick = function(e2) {
        var interactionManager = this.renderer.plugins.interaction;
        var displayObject = e2.target.displayObject;
        var eventData = interactionManager.eventData;
        interactionManager.dispatchEvent(displayObject, "click", eventData);
        interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
        interactionManager.dispatchEvent(displayObject, "tap", eventData);
      };
      AccessibilityManager2.prototype._onFocus = function(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "assertive");
        }
        var interactionManager = this.renderer.plugins.interaction;
        var displayObject = e2.target.displayObject;
        var eventData = interactionManager.eventData;
        interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
      };
      AccessibilityManager2.prototype._onFocusOut = function(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "polite");
        }
        var interactionManager = this.renderer.plugins.interaction;
        var displayObject = e2.target.displayObject;
        var eventData = interactionManager.eventData;
        interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
      };
      AccessibilityManager2.prototype._onKeyDown = function(e2) {
        if (e2.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this.activate();
      };
      AccessibilityManager2.prototype._onMouseMove = function(e2) {
        if (e2.movementX === 0 && e2.movementY === 0) {
          return;
        }
        this.deactivate();
      };
      AccessibilityManager2.prototype.destroy = function() {
        this.destroyTouchHook();
        this.div = null;
        self.document.removeEventListener("mousemove", this._onMouseMove, true);
        self.removeEventListener("keydown", this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
      };
      return AccessibilityManager2;
    }();
    exports.AccessibilityManager = AccessibilityManager;
    exports.accessibleTarget = accessibleTarget;
  });

  // node_modules/@pixi/interaction/dist/cjs/interaction.js
  var require_interaction = __commonJS((exports) => {
    /*!
     * @pixi/interaction - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/interaction is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var math = require_math();
    var ticker = require_ticker();
    var display = require_display();
    var utils6 = require_utils();
    var InteractionData = function() {
      function InteractionData2() {
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.global = new math.Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
      }
      Object.defineProperty(InteractionData2.prototype, "pointerId", {
        get: function() {
          return this.identifier;
        },
        enumerable: false,
        configurable: true
      });
      InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
      };
      InteractionData2.prototype.copyEvent = function(event) {
        if ("isPrimary" in event && event.isPrimary) {
          this.isPrimary = true;
        }
        this.button = "button" in event && event.button;
        var buttons = "buttons" in event && event.buttons;
        this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
        this.width = "width" in event && event.width;
        this.height = "height" in event && event.height;
        this.tiltX = "tiltX" in event && event.tiltX;
        this.tiltY = "tiltY" in event && event.tiltY;
        this.pointerType = "pointerType" in event && event.pointerType;
        this.pressure = "pressure" in event && event.pressure;
        this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
        this.twist = "twist" in event && event.twist || 0;
        this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
      };
      InteractionData2.prototype.reset = function() {
        this.isPrimary = false;
      };
      return InteractionData2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var InteractionEvent = function() {
      function InteractionEvent2() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.target = null;
        this.currentTarget = null;
        this.type = null;
        this.data = null;
      }
      InteractionEvent2.prototype.stopPropagation = function() {
        this.stopped = true;
        this.stopPropagationHint = true;
        this.stopsPropagatingAt = this.currentTarget;
      };
      InteractionEvent2.prototype.reset = function() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.currentTarget = null;
        this.target = null;
      };
      return InteractionEvent2;
    }();
    var InteractionTrackingData = function() {
      function InteractionTrackingData2(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData2.FLAGS.NONE;
      }
      InteractionTrackingData2.prototype._doSet = function(flag, yn) {
        if (yn) {
          this._flags = this._flags | flag;
        } else {
          this._flags = this._flags & ~flag;
        }
      };
      Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
        get: function() {
          return this._pointerId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
        get: function() {
          return this._flags;
        },
        set: function(flags) {
          this._flags = flags;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "none", {
        get: function() {
          return this._flags === InteractionTrackingData2.FLAGS.NONE;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "over", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      InteractionTrackingData2.FLAGS = Object.freeze({
        NONE: 0,
        OVER: 1 << 0,
        LEFT_DOWN: 1 << 1,
        RIGHT_DOWN: 1 << 2
      });
      return InteractionTrackingData2;
    }();
    var TreeSearch = function() {
      function TreeSearch2() {
        this._tempPoint = new math.Point();
      }
      TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
        if (!displayObject || !displayObject.visible) {
          return false;
        }
        var point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        var hit = false;
        var interactiveParent = interactive;
        var hitTestChildren = true;
        if (displayObject.hitArea) {
          if (hitTest) {
            displayObject.worldTransform.applyInverse(point, this._tempPoint);
            if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
              hitTest = false;
              hitTestChildren = false;
            } else {
              hit = true;
            }
          }
          interactiveParent = false;
        } else if (displayObject._mask) {
          if (hitTest) {
            if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
              hitTest = false;
            }
          }
        }
        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
          var children = displayObject.children;
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            var child = children[i2];
            var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
            if (childHit) {
              if (!child.parent) {
                continue;
              }
              interactiveParent = false;
              if (childHit) {
                if (interactionEvent.target) {
                  hitTest = false;
                }
                hit = true;
              }
            }
          }
        }
        if (interactive) {
          if (hitTest && !interactionEvent.target) {
            if (!displayObject.hitArea && displayObject.containsPoint) {
              if (displayObject.containsPoint(point)) {
                hit = true;
              }
            }
          }
          if (displayObject.interactive) {
            if (hit && !interactionEvent.target) {
              interactionEvent.target = displayObject;
            }
            if (func) {
              func(interactionEvent, displayObject, !!hit);
            }
          }
        }
        return hit;
      };
      TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
        this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
      };
      return TreeSearch2;
    }();
    var interactiveTarget = {
      interactive: false,
      interactiveChildren: true,
      hitArea: null,
      get buttonMode() {
        return this.cursor === "pointer";
      },
      set buttonMode(value) {
        if (value) {
          this.cursor = "pointer";
        } else if (this.cursor === "pointer") {
          this.cursor = null;
        }
      },
      cursor: null,
      get trackedPointers() {
        if (this._trackedPointers === void 0) {
          this._trackedPointers = {};
        }
        return this._trackedPointers;
      },
      _trackedPointers: void 0
    };
    display.DisplayObject.mixin(interactiveTarget);
    var MOUSE_POINTER_ID = 1;
    var hitTestEvent = {
      target: null,
      data: {
        global: null
      }
    };
    var InteractionManager = function(_super) {
      __extends(InteractionManager2, _super);
      function InteractionManager2(renderer, options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.renderer = renderer;
        _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
        _this.interactionFrequency = options.interactionFrequency || 10;
        _this.mouse = new InteractionData();
        _this.mouse.identifier = MOUSE_POINTER_ID;
        _this.mouse.global.set(-999999);
        _this.activeInteractionData = {};
        _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
        _this.interactionDataPool = [];
        _this.eventData = new InteractionEvent();
        _this.interactionDOMElement = null;
        _this.moveWhenInside = false;
        _this.eventsAdded = false;
        _this.tickerAdded = false;
        _this.mouseOverRenderer = !("PointerEvent" in self);
        _this.supportsTouchEvents = "ontouchstart" in self;
        _this.supportsPointerEvents = !!self.PointerEvent;
        _this.onPointerUp = _this.onPointerUp.bind(_this);
        _this.processPointerUp = _this.processPointerUp.bind(_this);
        _this.onPointerCancel = _this.onPointerCancel.bind(_this);
        _this.processPointerCancel = _this.processPointerCancel.bind(_this);
        _this.onPointerDown = _this.onPointerDown.bind(_this);
        _this.processPointerDown = _this.processPointerDown.bind(_this);
        _this.onPointerMove = _this.onPointerMove.bind(_this);
        _this.processPointerMove = _this.processPointerMove.bind(_this);
        _this.onPointerOut = _this.onPointerOut.bind(_this);
        _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
        _this.onPointerOver = _this.onPointerOver.bind(_this);
        _this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        _this.currentCursorMode = null;
        _this.cursor = null;
        _this.resolution = 1;
        _this.delayedEvents = [];
        _this.search = new TreeSearch();
        _this._tempDisplayObject = new display.TemporaryDisplayObject();
        _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
        _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
        return _this;
      }
      Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
        get: function() {
          return this._useSystemTicker;
        },
        set: function(useSystemTicker) {
          this._useSystemTicker = useSystemTicker;
          if (useSystemTicker) {
            this.addTickerListener();
          } else {
            this.removeTickerListener();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
        get: function() {
          return this.renderer._lastObjectRendered || this._tempDisplayObject;
        },
        enumerable: false,
        configurable: true
      });
      InteractionManager2.prototype.hitTest = function(globalPoint, root) {
        hitTestEvent.target = null;
        hitTestEvent.data.global = globalPoint;
        if (!root) {
          root = this.lastObjectRendered;
        }
        this.processInteractive(hitTestEvent, root, null, true);
        return hitTestEvent.target;
      };
      InteractionManager2.prototype.setTargetElement = function(element, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        this.removeTickerListener();
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
        this.addTickerListener();
      };
      InteractionManager2.prototype.addTickerListener = function() {
        if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
          return;
        }
        ticker.Ticker.system.add(this.tickerUpdate, this, ticker.UPDATE_PRIORITY.INTERACTION);
        this.tickerAdded = true;
      };
      InteractionManager2.prototype.removeTickerListener = function() {
        if (!this.tickerAdded) {
          return;
        }
        ticker.Ticker.system.remove(this.tickerUpdate, this);
        this.tickerAdded = false;
      };
      InteractionManager2.prototype.addEvents = function() {
        if (this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (self.navigator.msPointerEnabled) {
          style.msContentZooming = "none";
          style.msTouchAction = "none";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "none";
        }
        if (this.supportsPointerEvents) {
          self.document.addEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, true);
          self.addEventListener("pointercancel", this.onPointerCancel, true);
          self.addEventListener("pointerup", this.onPointerUp, true);
        } else {
          self.document.addEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, true);
          self.addEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, true);
        }
        this.eventsAdded = true;
      };
      InteractionManager2.prototype.removeEvents = function() {
        if (!this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (self.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          self.document.removeEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, true);
          self.removeEventListener("pointercancel", this.onPointerCancel, true);
          self.removeEventListener("pointerup", this.onPointerUp, true);
        } else {
          self.document.removeEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, true);
          self.removeEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, true);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
      };
      InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
        this._deltaTime += deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this.update();
      };
      InteractionManager2.prototype.update = function() {
        if (!this.interactionDOMElement) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        this.cursor = null;
        for (var k2 in this.activeInteractionData) {
          if (this.activeInteractionData.hasOwnProperty(k2)) {
            var interactionData = this.activeInteractionData[k2];
            if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
              var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
              this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
            }
          }
        }
        this.setCursorMode(this.cursor);
      };
      InteractionManager2.prototype.setCursorMode = function(mode) {
        mode = mode || "default";
        var applyStyles = true;
        if (self.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this.currentCursorMode === mode) {
          return;
        }
        this.currentCursorMode = mode;
        var style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.interactionDOMElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.interactionDOMElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.interactionDOMElement.style.cursor = mode;
        }
      };
      InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
        if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
          eventData.currentTarget = displayObject;
          eventData.type = eventString;
          displayObject.emit(eventString, eventData);
          if (displayObject[eventString]) {
            displayObject[eventString](eventData);
          }
        }
      };
      InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
        this.delayedEvents.push({displayObject, eventString, eventData});
      };
      InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {
        var rect;
        if (!this.interactionDOMElement.parentElement) {
          rect = {
            x: 0,
            y: 0,
            width: this.interactionDOMElement.width,
            height: this.interactionDOMElement.height,
            left: 0,
            top: 0
          };
        } else {
          rect = this.interactionDOMElement.getBoundingClientRect();
        }
        var resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
      };
      InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
        var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
        var delayedEvents = this.delayedEvents;
        if (!delayedEvents.length) {
          return hit;
        }
        interactionEvent.stopPropagationHint = false;
        var delayedLen = delayedEvents.length;
        this.delayedEvents = [];
        for (var i2 = 0; i2 < delayedLen; i2++) {
          var _a = delayedEvents[i2], displayObject_1 = _a.displayObject, eventString = _a.eventString, eventData = _a.eventData;
          if (eventData.stopsPropagatingAt === displayObject_1) {
            eventData.stopPropagationHint = true;
          }
          this.dispatchEvent(displayObject_1, eventString, eventData);
        }
        return hit;
      };
      InteractionManager2.prototype.onPointerDown = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events = this.normalizeToPointerData(originalEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
          if (cancelable) {
            originalEvent.preventDefault();
          }
        }
        var eventLen = events.length;
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
          this.emit("pointerdown", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchstart", interactionEvent);
          } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
          }
        }
      };
      InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;
        if (hit) {
          if (!displayObject.trackedPointers[id]) {
            displayObject.trackedPointers[id] = new InteractionTrackingData(id);
          }
          this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchstart", interactionEvent);
          } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
            var isRightButton = data.button === 2;
            if (isRightButton) {
              displayObject.trackedPointers[id].rightDown = true;
            } else {
              displayObject.trackedPointers[id].leftDown = true;
            }
            this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
        var events = this.normalizeToPointerData(originalEvent);
        var eventLen = events.length;
        var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
          this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
          } else if (event.pointerType === "touch") {
            this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
            this.releaseInteractionDataForPointerId(event.pointerId);
          }
        }
      };
      InteractionManager2.prototype.onPointerCancel = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, true, this.processPointerCancel);
      };
      InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id] !== void 0) {
          delete displayObject.trackedPointers[id];
          this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerUp = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, false, this.processPointerUp);
      };
      InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;
        var trackingData = displayObject.trackedPointers[id];
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var isMouseTap = false;
        if (isMouse) {
          var isRightButton = data.button === 2;
          var flags = InteractionTrackingData.FLAGS;
          var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
          var isDown2 = trackingData !== void 0 && trackingData.flags & test;
          if (hit) {
            this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
            if (isDown2) {
              this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
              isMouseTap = true;
            }
          } else if (isDown2) {
            this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
          }
          if (trackingData) {
            if (isRightButton) {
              trackingData.rightDown = false;
            } else {
              trackingData.leftDown = false;
            }
          }
        }
        if (hit) {
          this.dispatchEvent(displayObject, "pointerup", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchend", interactionEvent);
          }
          if (trackingData) {
            if (!isMouse || isMouseTap) {
              this.dispatchEvent(displayObject, "pointertap", interactionEvent);
            }
            if (isTouch) {
              this.dispatchEvent(displayObject, "tap", interactionEvent);
              trackingData.over = false;
            }
          }
        } else if (trackingData) {
          this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
          }
        }
        if (trackingData && trackingData.none) {
          delete displayObject.trackedPointers[id];
        }
      };
      InteractionManager2.prototype.onPointerMove = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events = this.normalizeToPointerData(originalEvent);
        if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
          this._didMove = true;
          this.cursor = null;
        }
        var eventLen = events.length;
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
          this.emit("pointermove", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchmove", interactionEvent);
          }
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            this.emit("mousemove", interactionEvent);
          }
        }
        if (events[0].pointerType === "mouse") {
          this.setCursorMode(this.cursor);
        }
      };
      InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        if (isMouse) {
          this.processPointerOverOut(interactionEvent, displayObject, hit);
        }
        if (!this.moveWhenInside || hit) {
          this.dispatchEvent(displayObject, "pointermove", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchmove", interactionEvent);
          }
          if (isMouse) {
            this.dispatchEvent(displayObject, "mousemove", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerOut = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events = this.normalizeToPointerData(originalEvent);
        var event = events[0];
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = false;
          this.setCursorMode(null);
        }
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
        this.emit("pointerout", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseout", interactionEvent);
        } else {
          this.releaseInteractionDataForPointerId(interactionData.identifier);
        }
      };
      InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var trackingData = displayObject.trackedPointers[id];
        if (hit && !trackingData) {
          trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }
        if (trackingData === void 0) {
          return;
        }
        if (hit && this.mouseOverRenderer) {
          if (!trackingData.over) {
            trackingData.over = true;
            this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
            if (isMouse) {
              this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
            }
          }
          if (isMouse && this.cursor === null) {
            this.cursor = displayObject.cursor;
          }
        } else if (trackingData.over) {
          trackingData.over = false;
          this.dispatchEvent(displayObject, "pointerout", this.eventData);
          if (isMouse) {
            this.dispatchEvent(displayObject, "mouseout", interactionEvent);
          }
          if (trackingData.none) {
            delete displayObject.trackedPointers[id];
          }
        }
      };
      InteractionManager2.prototype.onPointerOver = function(originalEvent) {
        var events = this.normalizeToPointerData(originalEvent);
        var event = events[0];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = true;
        }
        this.emit("pointerover", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseover", interactionEvent);
        }
      };
      InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
        var pointerId = event.pointerId;
        var interactionData;
        if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
          interactionData = this.mouse;
        } else if (this.activeInteractionData[pointerId]) {
          interactionData = this.activeInteractionData[pointerId];
        } else {
          interactionData = this.interactionDataPool.pop() || new InteractionData();
          interactionData.identifier = pointerId;
          this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
      };
      InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
        var interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
          delete this.activeInteractionData[pointerId];
          interactionData.reset();
          this.interactionDataPool.push(interactionData);
        }
      };
      InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === "touch") {
          pointerEvent.globalX = interactionData.global.x;
          pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
      };
      InteractionManager2.prototype.normalizeToPointerData = function(event) {
        var normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (var i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
            var touch = event.changedTouches[i2];
            if (typeof touch.button === "undefined") {
              touch.button = event.touches.length ? 1 : 0;
            }
            if (typeof touch.buttons === "undefined") {
              touch.buttons = event.touches.length ? 1 : 0;
            }
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined") {
              touch.width = touch.radiusX || 1;
            }
            if (typeof touch.height === "undefined") {
              touch.height = touch.radiusY || 1;
            }
            if (typeof touch.tiltX === "undefined") {
              touch.tiltX = 0;
            }
            if (typeof touch.tiltY === "undefined") {
              touch.tiltY = 0;
            }
            if (typeof touch.pointerType === "undefined") {
              touch.pointerType = "touch";
            }
            if (typeof touch.pointerId === "undefined") {
              touch.pointerId = touch.identifier || 0;
            }
            if (typeof touch.pressure === "undefined") {
              touch.pressure = touch.force || 0.5;
            }
            if (typeof touch.twist === "undefined") {
              touch.twist = 0;
            }
            if (typeof touch.tangentialPressure === "undefined") {
              touch.tangentialPressure = 0;
            }
            if (typeof touch.layerX === "undefined") {
              touch.layerX = touch.offsetX = touch.clientX;
            }
            if (typeof touch.layerY === "undefined") {
              touch.layerY = touch.offsetY = touch.clientY;
            }
            touch.isNormalized = true;
            normalizedEvents.push(touch);
          }
        } else if (!self.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof self.PointerEvent))) {
          var tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined") {
            tempEvent.isPrimary = true;
          }
          if (typeof tempEvent.width === "undefined") {
            tempEvent.width = 1;
          }
          if (typeof tempEvent.height === "undefined") {
            tempEvent.height = 1;
          }
          if (typeof tempEvent.tiltX === "undefined") {
            tempEvent.tiltX = 0;
          }
          if (typeof tempEvent.tiltY === "undefined") {
            tempEvent.tiltY = 0;
          }
          if (typeof tempEvent.pointerType === "undefined") {
            tempEvent.pointerType = "mouse";
          }
          if (typeof tempEvent.pointerId === "undefined") {
            tempEvent.pointerId = MOUSE_POINTER_ID;
          }
          if (typeof tempEvent.pressure === "undefined") {
            tempEvent.pressure = 0.5;
          }
          if (typeof tempEvent.twist === "undefined") {
            tempEvent.twist = 0;
          }
          if (typeof tempEvent.tangentialPressure === "undefined") {
            tempEvent.tangentialPressure = 0;
          }
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      };
      InteractionManager2.prototype.destroy = function() {
        this.removeEvents();
        this.removeTickerListener();
        this.removeAllListeners();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this.search = null;
      };
      return InteractionManager2;
    }(utils6.EventEmitter);
    exports.InteractionData = InteractionData;
    exports.InteractionEvent = InteractionEvent;
    exports.InteractionManager = InteractionManager;
    exports.InteractionTrackingData = InteractionTrackingData;
    exports.interactiveTarget = interactiveTarget;
  });

  // node_modules/@pixi/app/dist/cjs/app.js
  var require_app = __commonJS((exports) => {
    /*!
     * @pixi/app - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/app is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var display = require_display();
    var core = require_core();
    var Application2 = function() {
      function Application3(options) {
        var _this = this;
        this.stage = new display.Container();
        options = Object.assign({
          forceCanvas: false
        }, options);
        this.renderer = core.autoDetectRenderer(options);
        Application3._plugins.forEach(function(plugin) {
          plugin.init.call(_this, options);
        });
      }
      Application3.registerPlugin = function(plugin) {
        Application3._plugins.push(plugin);
      };
      Application3.prototype.render = function() {
        this.renderer.render(this.stage);
      };
      Object.defineProperty(Application3.prototype, "view", {
        get: function() {
          return this.renderer.view;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Application3.prototype, "screen", {
        get: function() {
          return this.renderer.screen;
        },
        enumerable: false,
        configurable: true
      });
      Application3.prototype.destroy = function(removeView, stageOptions) {
        var _this = this;
        var plugins = Application3._plugins.slice(0);
        plugins.reverse();
        plugins.forEach(function(plugin) {
          plugin.destroy.call(_this);
        });
        this.stage.destroy(stageOptions);
        this.stage = null;
        this.renderer.destroy(removeView);
        this.renderer = null;
      };
      Application3._plugins = [];
      return Application3;
    }();
    var ResizePlugin = function() {
      function ResizePlugin2() {
      }
      ResizePlugin2.init = function(options) {
        var _this = this;
        Object.defineProperty(this, "resizeTo", {
          set: function(dom) {
            self.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              self.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get: function() {
            return this._resizeTo;
          }
        });
        this.queueResize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          _this._resizeId = requestAnimationFrame(function() {
            return _this.resize();
          });
        };
        this.cancelResize = function() {
          if (_this._resizeId) {
            cancelAnimationFrame(_this._resizeId);
            _this._resizeId = null;
          }
        };
        this.resize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          var width;
          var height;
          if (_this._resizeTo === self) {
            width = self.innerWidth;
            height = self.innerHeight;
          } else {
            var _a = _this._resizeTo, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
            width = clientWidth;
            height = clientHeight;
          }
          _this.renderer.resize(width, height);
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      };
      ResizePlugin2.destroy = function() {
        self.removeEventListener("resize", this.queueResize);
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      };
      return ResizePlugin2;
    }();
    Application2.registerPlugin(ResizePlugin);
    exports.Application = Application2;
  });

  // node_modules/@pixi/extract/dist/cjs/extract.js
  var require_extract = __commonJS((exports) => {
    /*!
     * @pixi/extract - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/extract is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var utils6 = require_utils();
    var math = require_math();
    var core = require_core();
    var TEMP_RECT = new math.Rectangle();
    var BYTES_PER_PIXEL = 4;
    var Extract = function() {
      function Extract2(renderer) {
        this.renderer = renderer;
      }
      Extract2.prototype.image = function(target, format, quality) {
        var image = new Image();
        image.src = this.base64(target, format, quality);
        return image;
      };
      Extract2.prototype.base64 = function(target, format, quality) {
        return this.canvas(target).toDataURL(format, quality);
      };
      Extract2.prototype.canvas = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof core.RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          flipY = false;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = this.renderer.resolution;
          flipY = true;
          frame = TEMP_RECT;
          frame.width = this.renderer.width;
          frame.height = this.renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width = Math.floor(frame.width * resolution + 1e-4);
        var height = Math.floor(frame.height * resolution + 1e-4);
        var canvasBuffer = new utils6.CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        Extract2.arrayPostDivide(webglPixels, canvasData.data);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        if (flipY) {
          var target_1 = new utils6.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
          target_1.context.scale(1, -1);
          target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
          canvasBuffer.destroy();
          canvasBuffer = target_1;
        }
        if (generated) {
          renderTexture.destroy(true);
        }
        return canvasBuffer.canvas;
      };
      Extract2.prototype.pixels = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof core.RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = renderer.resolution;
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
          renderTexture.destroy(true);
        }
        Extract2.arrayPostDivide(webglPixels, webglPixels);
        return webglPixels;
      };
      Extract2.prototype.destroy = function() {
        this.renderer = null;
      };
      Extract2.arrayPostDivide = function(pixels, out) {
        for (var i2 = 0; i2 < pixels.length; i2 += 4) {
          var alpha = out[i2 + 3] = pixels[i2 + 3];
          if (alpha !== 0) {
            out[i2] = Math.round(Math.min(pixels[i2] * 255 / alpha, 255));
            out[i2 + 1] = Math.round(Math.min(pixels[i2 + 1] * 255 / alpha, 255));
            out[i2 + 2] = Math.round(Math.min(pixels[i2 + 2] * 255 / alpha, 255));
          } else {
            out[i2] = pixels[i2];
            out[i2 + 1] = pixels[i2 + 1];
            out[i2 + 2] = pixels[i2 + 2];
          }
        }
      };
      return Extract2;
    }();
    exports.Extract = Extract;
  });

  // node_modules/@pixi/compressed-textures/dist/cjs/compressed-textures.js
  var require_compressed_textures = __commonJS((exports) => {
    /*!
     * @pixi/compressed-textures - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/compressed-textures is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var loaders = require_loaders();
    var constants = require_constants();
    var _a;
    (function(INTERNAL_FORMATS) {
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
      INTERNAL_FORMATS[INTERNAL_FORMATS["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    })(exports.INTERNAL_FORMATS || (exports.INTERNAL_FORMATS = {}));
    var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a = {}, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a[exports.INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a);
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    function __awaiter(thisArg, _arguments, P2, generator) {
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P2(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _2 = {label: 0, sent: function() {
        if (t2[0] & 1) {
          throw t2[1];
        }
        return t2[1];
      }, trys: [], ops: []}, f2, y2, t2, g2;
      return g2 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2) {
          throw new TypeError("Generator is already executing.");
        }
        while (_2) {
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) {
              return t2;
            }
            if (y2 = 0, t2) {
              op = [op[0] & 2, t2.value];
            }
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return {value: op[1], done: false};
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2]) {
                  _2.ops.pop();
                }
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        }
        if (op[0] & 5) {
          throw op[1];
        }
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    }
    var BlobResource = function(_super) {
      __extends(BlobResource2, _super);
      function BlobResource2(source, options) {
        if (options === void 0) {
          options = {width: 1, height: 1, autoLoad: true};
        }
        var _this = this;
        var origin;
        var data;
        if (typeof source === "string") {
          origin = source;
          data = new Uint8Array();
        } else {
          origin = null;
          data = source;
        }
        _this = _super.call(this, data, options) || this;
        _this.origin = origin;
        _this.buffer = data ? new core.ViewableBuffer(data) : null;
        if (_this.origin && options.autoLoad !== false) {
          _this.load();
        }
        if (data && data.length) {
          _this.loaded = true;
          _this.onBlobLoaded(_this.buffer.rawBinaryData);
        }
        return _this;
      }
      BlobResource2.prototype.onBlobLoaded = function(_data) {
      };
      BlobResource2.prototype.load = function() {
        return __awaiter(this, void 0, Promise, function() {
          var response, blob, arrayBuffer;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, fetch(this.origin)];
              case 1:
                response = _a2.sent();
                return [4, response.blob()];
              case 2:
                blob = _a2.sent();
                return [4, blob.arrayBuffer()];
              case 3:
                arrayBuffer = _a2.sent();
                this.data = new Uint32Array(arrayBuffer);
                this.buffer = new core.ViewableBuffer(arrayBuffer);
                this.loaded = true;
                this.onBlobLoaded(arrayBuffer);
                this.update();
                return [2, this];
            }
          });
        });
      };
      return BlobResource2;
    }(core.BufferResource);
    var CompressedTextureResource = function(_super) {
      __extends(CompressedTextureResource2, _super);
      function CompressedTextureResource2(source, options) {
        var _this = _super.call(this, source, options) || this;
        _this.format = options.format;
        _this.levels = options.levels || 1;
        _this._width = options.width;
        _this._height = options.height;
        _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
        if (options.levelBuffers || _this.buffer) {
          _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(source instanceof Uint8Array ? source : _this.buffer.uint8View, _this.format, _this.levels, 4, 4, _this.width, _this.height);
        }
        return _this;
      }
      CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {
        var gl = renderer.gl;
        var extension = renderer.context.extensions[this._extension];
        if (!extension) {
          throw new Error(this._extension + " textures are not supported on the current machine");
        }
        if (!this._levelBuffers) {
          return false;
        }
        for (var i2 = 0, j2 = this.levels; i2 < j2; i2++) {
          var _a2 = this._levelBuffers[i2], levelID = _a2.levelID, levelWidth = _a2.levelWidth, levelHeight = _a2.levelHeight, levelBuffer = _a2.levelBuffer;
          gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
        }
        return true;
      };
      CompressedTextureResource2.prototype.onBlobLoaded = function() {
        this._levelBuffers = CompressedTextureResource2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
      };
      CompressedTextureResource2._formatToExtension = function(format2) {
        if (format2 >= 33776 && format2 <= 33779) {
          return "s3tc";
        } else if (format2 >= 37488 && format2 <= 37497) {
          return "etc";
        } else if (format2 >= 35840 && format2 <= 35843) {
          return "pvrtc";
        } else if (format2 >= 36196) {
          return "etc1";
        } else if (format2 >= 35986 && format2 <= 34798) {
          return "atc";
        }
        throw new Error("Invalid (compressed) texture format given!");
      };
      CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
        var buffers = new Array(levels);
        var offset = buffer.byteOffset;
        var levelWidth = imageWidth;
        var levelHeight = imageHeight;
        var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
        var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
        var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
        for (var i2 = 0; i2 < levels; i2++) {
          buffers[i2] = {
            levelID: i2,
            levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
            levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
            levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
          };
          offset += levelSize;
          levelWidth = levelWidth >> 1 || 1;
          levelHeight = levelHeight >> 1 || 1;
          alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
          alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
          levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
        }
        return buffers;
      };
      return CompressedTextureResource2;
    }(BlobResource);
    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
    function createMatch(userAgent) {
      return function(regex) {
        return regex.test(userAgent);
      };
    }
    function isMobile(param) {
      var nav = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
      };
      if (!param && typeof navigator !== "undefined") {
        nav = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0
        };
      } else if (typeof param === "string") {
        nav.userAgent = param;
      } else if (param && param.userAgent) {
        nav = {
          userAgent: param.userAgent,
          platform: param.platform,
          maxTouchPoints: param.maxTouchPoints || 0
        };
      }
      var userAgent = nav.userAgent;
      var tmp = userAgent.split("[FBAN");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      tmp = userAgent.split("Twitter");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      var match = createMatch(userAgent);
      var result = {
        apple: {
          phone: match(appleIphone) && !match(windowsPhone),
          ipod: match(appleIpod),
          tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
          universal: match(appleUniversal),
          device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
        },
        amazon: {
          phone: match(amazonPhone),
          tablet: !match(amazonPhone) && match(amazonTablet),
          device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
          phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
          tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
          device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
        },
        windows: {
          phone: match(windowsPhone),
          tablet: match(windowsTablet),
          device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
          blackberry: match(otherBlackBerry),
          blackberry10: match(otherBlackBerry10),
          opera: match(otherOpera),
          firefox: match(otherFirefox),
          chrome: match(otherChrome),
          device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
      };
      result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
      result.phone = result.apple.phone || result.android.phone || result.windows.phone;
      result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
      return result;
    }
    /*!
     * @pixi/settings - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/settings is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var isMobile$1 = isMobile(self.navigator);
    function maxRecommendedTextures(max) {
      var allowMax = true;
      if (isMobile$1.tablet || isMobile$1.phone) {
        if (isMobile$1.apple.device) {
          var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 11) {
              allowMax = false;
            }
          }
        }
        if (isMobile$1.android.device) {
          var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 7) {
              allowMax = false;
            }
          }
        }
      }
      return allowMax ? max : 4;
    }
    function canUploadSameBuffer() {
      return !isMobile$1.apple.device;
    }
    var settings2 = {
      MIPMAP_TEXTURES: 1,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: false,
        autoDensity: false,
        backgroundColor: 0,
        backgroundAlpha: 1,
        useContextAlpha: true,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        width: 800,
        height: 600,
        legacy: false
      },
      GC_MODE: 0,
      GC_MAX_IDLE: 60 * 60,
      GC_MAX_CHECK_COUNT: 60 * 10,
      WRAP_MODE: 33071,
      SCALE_MODE: 1,
      PRECISION_VERTEX: "highp",
      PRECISION_FRAGMENT: isMobile$1.apple.device ? "highp" : "mediump",
      CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
      CREATE_IMAGE_BITMAP: false,
      ROUND_PIXELS: false
    };
    var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function createCommonjsModule2(fn, basedir, module2) {
      return module2 = {
        path: basedir,
        exports: {},
        require: function(path, base) {
          return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
        }
      }, fn(module2, module2.exports), module2.exports;
    }
    function commonjsRequire() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    }
    var eventemitter3 = createCommonjsModule2(function(module2) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = Object.create(null);
        if (!new Events().__proto__) {
          prefix = false;
        }
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) {
          emitter._events[evt] = listener, emitter._eventsCount++;
        } else if (!emitter._events[evt].fn) {
          emitter._events[evt].push(listener);
        } else {
          emitter._events[evt] = [emitter._events[evt], listener];
        }
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) {
          emitter._events = new Events();
        } else {
          delete emitter._events[evt];
        }
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) {
          return names;
        }
        for (name in events = this._events) {
          if (has.call(events, name)) {
            names.push(prefix ? name.slice(1) : name);
          }
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) {
          return [];
        }
        if (handlers.fn) {
          return [handlers.fn];
        }
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) {
          return 0;
        }
        if (listeners.fn) {
          return 1;
        }
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var arguments$1 = arguments;
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) {
          return false;
        }
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once) {
            this.removeListener(event, listeners.fn, void 0, true);
          }
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments$1[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once) {
              this.removeListener(event, listeners[i2].fn, void 0, true);
            }
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args) {
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments$1[j2];
                  }
                }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) {
          return this;
        }
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
              events.push(listeners[i2]);
            }
          }
          if (events.length) {
            this._events[evt] = events.length === 1 ? events[0] : events;
          } else {
            clearEvent(this, evt);
          }
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) {
            clearEvent(this, evt);
          }
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix;
      EventEmitter.EventEmitter = EventEmitter;
      {
        module2.exports = EventEmitter;
      }
    });
    var punycode = createCommonjsModule2(function(module2, exports2) {
      (function(root) {
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = module2 && !module2.nodeType && module2;
        var freeGlobal = typeof commonjsGlobal2 == "object" && commonjsGlobal2;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type2) {
          throw RangeError(errors[type2]);
        }
        function map(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k2 = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode2(input) {
          var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j2 = 0; j2 < basic; ++j2) {
            if (input.charCodeAt(j2) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j2));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i2) / w2)) {
                error("overflow");
              }
              i2 += digit * w2;
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (digit < t2) {
                break;
              }
              baseMinusT = base - t2;
              if (w2 > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w2 *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i2 - oldi, out, oldi == 0);
            if (floor(i2 / out) > maxInt - n2) {
              error("overflow");
            }
            n2 += floor(i2 / out);
            i2 %= out;
            output.splice(i2++, 0, n2);
          }
          return ucs2encode(output);
        }
        function encode2(input) {
          var n2, delta, handledCPCount, basicLength, bias, j2, m2, q, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n2 = initialN;
          delta = 0;
          bias = initialBias;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            for (j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue < n2 && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n2) {
                for (q = delta, k2 = base; ; k2 += base) {
                  t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                  if (q < t2) {
                    break;
                  }
                  qMinusT = q - t2;
                  baseMinusT = base - t2;
                  output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
          });
        }
        punycode2 = {
          version: "1.3.2",
          ucs2: {
            decode: ucs2decode,
            encode: ucs2encode
          },
          decode: decode2,
          encode: encode2,
          toASCII,
          toUnicode
        };
        if (freeExports && freeModule) {
          if (module2.exports == freeExports) {
            freeModule.exports = punycode2;
          } else {
            for (key in punycode2) {
              punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
            }
          }
        } else {
          root.punycode = punycode2;
        }
      })(commonjsGlobal2);
    });
    var util = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var decode = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i2 = 0; i2 < len; ++i2) {
        var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v2;
        if (idx >= 0) {
          kstr = x2.substr(0, idx);
          vstr = x2.substr(idx + 1);
        } else {
          kstr = x2;
          vstr = "";
        }
        k2 = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k2)) {
          obj[k2] = v2;
        } else if (Array.isArray(obj[k2])) {
          obj[k2].push(v2);
        } else {
          obj[k2] = [obj[k2], v2];
        }
      }
      return obj;
    };
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    var encode = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k2) {
          var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq;
          if (Array.isArray(obj[k2])) {
            return obj[k2].map(function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
          }
        }).join(sep);
      }
      if (!name) {
        return "";
      }
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var querystring = createCommonjsModule2(function(module2, exports2) {
      exports2.decode = exports2.parse = decode;
      exports2.encode = exports2.stringify = encode;
    });
    var parse = urlParse;
    var resolve = urlResolve;
    var format = urlFormat;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url2, parseQueryString, slashesDenoteHost) {
      if (url2 && util.isObject(url2) && url2 instanceof Url) {
        return url2;
      }
      var u2 = new Url();
      u2.parse(url2, parseQueryString, slashesDenoteHost);
      return u2;
    }
    Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url2)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest = url2;
      rest = rest.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
          var hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i2 = 0; i2 < nonHostChars.length; i2++) {
          var hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
                if (part.charCodeAt(j2) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j2];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p2 = this.port ? ":" + this.port : "";
        var h2 = this.hostname || "";
        this.host = h2 + p2;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
          var ae = autoEscape[i2];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p2 = this.pathname || "";
        var s3 = this.search || "";
        this.path = p2 + s3;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj)) {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v2 = 0; v2 < keys.length; v2++) {
            var k2 = keys[v2];
            result[k2] = relative[k2];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p2 = result.pathname || "";
          var s3 = result.search || "";
          result.path = p2 + s3;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i2 = srcPath.length; i2 >= 0; i2--) {
        last = srcPath[i2];
        if (last === ".") {
          srcPath.splice(i2, 1);
        } else if (last === "..") {
          srcPath.splice(i2, 1);
          up++;
        } else if (up) {
          srcPath.splice(i2, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    var url = {
      parse,
      format,
      resolve
    };
    settings2.RETINA_PREFIX = /@([0-9\.]+)x/;
    settings2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
    function mapPremultipliedBlendModes() {
      var pm = [];
      var npm = [];
      for (var i2 = 0; i2 < 32; i2++) {
        pm[i2] = i2;
        npm[i2] = i2;
      }
      pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL;
      pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD;
      pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN;
      npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM;
      npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM;
      npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;
      var array = [];
      array.push(npm);
      array.push(pm);
      return array;
    }
    var premultiplyBlendMode = mapPremultipliedBlendModes();
    var CanvasRenderTarget = function() {
      function CanvasRenderTarget2(width, height, resolution) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.resolution = resolution || settings2.RESOLUTION;
        this.resize(width, height);
      }
      CanvasRenderTarget2.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderTarget2.prototype.resize = function(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
      };
      CanvasRenderTarget2.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
      Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
        get: function() {
          return this.canvas.width;
        },
        set: function(val) {
          this.canvas.width = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
        get: function() {
          return this.canvas.height;
        },
        set: function(val) {
          this.canvas.height = val;
        },
        enumerable: false,
        configurable: true
      });
      return CanvasRenderTarget2;
    }();
    var CompressedTextureLoader = function() {
      function CompressedTextureLoader2() {
      }
      CompressedTextureLoader2.use = function(resource, next) {
        var data = resource.data;
        var loader = this;
        if (resource.type === loaders.LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {
          var textures = data.textures;
          var textureURL = void 0;
          var fallbackURL = void 0;
          for (var i2 = 0, j2 = textures.length; i2 < j2; i2++) {
            var texture = textures[i2];
            var url_1 = texture.src;
            var format2 = texture.format;
            if (!format2) {
              fallbackURL = url_1;
            }
            if (CompressedTextureLoader2.textureFormats[format2]) {
              textureURL = url_1;
              break;
            }
          }
          textureURL = textureURL || fallbackURL;
          if (!textureURL) {
            next(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
            return;
          }
          if (textureURL === resource.url) {
            next(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
            return;
          }
          var loadOptions = {
            crossOrigin: resource.crossOrigin,
            metadata: resource.metadata.imageMetadata,
            parentResource: resource
          };
          var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
          var resourceName = data.cacheID;
          loader.add(resourceName, resourcePath, loadOptions, function(res) {
            if (res.error) {
              next(res.error);
              return;
            }
            var _a2 = res.texture, texture2 = _a2 === void 0 ? null : _a2, _b2 = res.textures, textures2 = _b2 === void 0 ? {} : _b2;
            Object.assign(resource, {texture: texture2, textures: textures2});
            next();
          });
        } else {
          next();
        }
      };
      CompressedTextureLoader2.add = function() {
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl");
        if (!gl) {
          console.error("WebGL not available for compressed textures. Silently failing.");
          return;
        }
        var extensions = {
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        CompressedTextureLoader2.textureExtensions = extensions;
        CompressedTextureLoader2.textureFormats = {};
        for (var extensionName in extensions) {
          var extension = extensions[extensionName];
          if (!extension) {
            continue;
          }
          Object.assign(CompressedTextureLoader2.textureFormats, Object.getPrototypeOf(extension));
        }
      };
      return CompressedTextureLoader2;
    }();
    function registerCompressedTextures(url2, resources, metadata) {
      var result = {
        textures: {},
        texture: null
      };
      if (!resources) {
        return result;
      }
      var textures = resources.map(function(resource) {
        return new core.Texture(new core.BaseTexture(resource, Object.assign({
          mipmap: constants.MIPMAP_MODES.OFF,
          alphaMode: constants.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
        }, metadata)));
      });
      textures.forEach(function(texture, i2) {
        var baseTexture = texture.baseTexture;
        var cacheID = url2 + "-" + (i2 + 1);
        core.BaseTexture.addToCache(baseTexture, cacheID);
        core.Texture.addToCache(texture, cacheID);
        if (i2 === 0) {
          core.BaseTexture.addToCache(baseTexture, url2);
          core.Texture.addToCache(texture, url2);
          result.texture = texture;
        }
        result.textures[cacheID] = texture;
      });
      return result;
    }
    var _a$1;
    var _b;
    loaders.LoaderResource.setExtensionXhrType("dds", loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
    var DDS_MAGIC_SIZE = 4;
    var DDS_HEADER_SIZE = 124;
    var DDS_HEADER_PF_SIZE = 32;
    var DDS_HEADER_DX10_SIZE = 20;
    var DDS_MAGIC = 542327876;
    var DDS_FIELDS = {
      SIZE: 1,
      FLAGS: 2,
      HEIGHT: 3,
      WIDTH: 4,
      MIPMAP_COUNT: 7,
      PIXEL_FORMAT: 19
    };
    var DDS_PF_FIELDS = {
      SIZE: 0,
      FLAGS: 1,
      FOURCC: 2,
      RGB_BITCOUNT: 3,
      R_BIT_MASK: 4,
      G_BIT_MASK: 5,
      B_BIT_MASK: 6,
      A_BIT_MASK: 7
    };
    var DDS_DX10_FIELDS = {
      DXGI_FORMAT: 0,
      RESOURCE_DIMENSION: 1,
      MISC_FLAG: 2,
      ARRAY_SIZE: 3,
      MISC_FLAGS2: 4
    };
    var DXGI_FORMAT;
    (function(DXGI_FORMAT2) {
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
    })(DXGI_FORMAT || (DXGI_FORMAT = {}));
    var D3D10_RESOURCE_DIMENSION;
    (function(D3D10_RESOURCE_DIMENSION2) {
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
    })(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
    var PF_FLAGS = 1;
    var DDPF_ALPHA = 2;
    var DDPF_FOURCC = 4;
    var DDPF_RGB = 64;
    var DDPF_YUV = 512;
    var DDPF_LUMINANCE = 131072;
    var FOURCC_DXT1 = 827611204;
    var FOURCC_DXT3 = 861165636;
    var FOURCC_DXT5 = 894720068;
    var FOURCC_DX10 = 808540228;
    var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
    var FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1);
    var DXGI_TO_FORMAT = (_b = {}, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = exports.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = exports.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b);
    var DDSLoader = function() {
      function DDSLoader2() {
      }
      DDSLoader2.use = function(resource, next) {
        if (resource.extension === "dds" && resource.data) {
          try {
            Object.assign(resource, registerCompressedTextures(resource.name || resource.url, DDSLoader2.parse(resource.data), resource.metadata));
          } catch (err) {
            next(err);
            return;
          }
        }
        next();
      };
      DDSLoader2.parse = function(arrayBuffer) {
        var data = new Uint32Array(arrayBuffer);
        var magicWord = data[0];
        if (magicWord !== DDS_MAGIC) {
          throw new Error("Invalid DDS file magic word");
        }
        var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        var height = header[DDS_FIELDS.HEIGHT];
        var width = header[DDS_FIELDS.WIDTH];
        var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
        var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        var formatFlags = pixelFormat[PF_FLAGS];
        if (formatFlags & DDPF_FOURCC) {
          var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
          if (fourCC !== FOURCC_DX10) {
            var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
            var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
            var texData = new Uint8Array(arrayBuffer, dataOffset_1);
            var resource = new CompressedTextureResource(texData, {
              format: internalFormat_1,
              width,
              height,
              levels: mipmapCount
            });
            return [resource];
          }
          var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
          var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
          var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
          var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
          var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
          var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
          var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
          if (internalFormat_2 === void 0) {
            throw new Error("DDSLoader cannot parse texture data with DXGI format " + dxgiFormat);
          }
          if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
            throw new Error("DDSLoader does not support cubemap textures");
          }
          if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
            throw new Error("DDSLoader does not supported 3D texture data");
          }
          var imageBuffers = new Array();
          var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
          if (arraySize === 1) {
            imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
          } else {
            var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
            var imageSize = 0;
            var levelWidth = width;
            var levelHeight = height;
            for (var i2 = 0; i2 < mipmapCount; i2++) {
              var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
              var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
              var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
              imageSize += levelSize;
              levelWidth = levelWidth >>> 1;
              levelHeight = levelHeight >>> 1;
            }
            var imageOffset = dataOffset;
            for (var i2 = 0; i2 < arraySize; i2++) {
              imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
              imageOffset += imageSize;
            }
          }
          return imageBuffers.map(function(buffer) {
            return new CompressedTextureResource(buffer, {
              format: internalFormat_2,
              width,
              height,
              levels: mipmapCount
            });
          });
        }
        if (formatFlags & DDPF_RGB) {
          throw new Error("DDSLoader does not support uncompressed texture data.");
        }
        if (formatFlags & DDPF_YUV) {
          throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
        }
        if (formatFlags & DDPF_LUMINANCE) {
          throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
        }
        if (formatFlags & DDPF_ALPHA) {
          throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
        }
        throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
      };
      return DDSLoader2;
    }();
    var _a$2;
    var _b$1;
    var _c;
    loaders.LoaderResource.setExtensionXhrType("ktx", loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
    var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
    var ENDIANNESS = 67305985;
    var KTX_FIELDS = {
      FILE_IDENTIFIER: 0,
      ENDIANNESS: 12,
      GL_TYPE: 16,
      GL_TYPE_SIZE: 20,
      GL_FORMAT: 24,
      GL_INTERNAL_FORMAT: 28,
      GL_BASE_INTERNAL_FORMAT: 32,
      PIXEL_WIDTH: 36,
      PIXEL_HEIGHT: 40,
      PIXEL_DEPTH: 44,
      NUMBER_OF_ARRAY_ELEMENTS: 48,
      NUMBER_OF_FACES: 52,
      NUMBER_OF_MIPMAP_LEVELS: 56,
      BYTES_OF_KEY_VALUE_DATA: 60
    };
    var FILE_HEADER_SIZE = 64;
    var TYPES_TO_BYTES_PER_COMPONENT = (_a$2 = {}, _a$2[constants.TYPES.UNSIGNED_BYTE] = 1, _a$2[constants.TYPES.UNSIGNED_SHORT] = 2, _a$2[constants.TYPES.FLOAT] = 4, _a$2[constants.TYPES.HALF_FLOAT] = 8, _a$2);
    var FORMATS_TO_COMPONENTS = (_b$1 = {}, _b$1[constants.FORMATS.RGBA] = 4, _b$1[constants.FORMATS.RGB] = 3, _b$1[constants.FORMATS.LUMINANCE] = 1, _b$1[constants.FORMATS.LUMINANCE_ALPHA] = 2, _b$1[constants.FORMATS.ALPHA] = 1, _b$1);
    var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[constants.TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[constants.TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[constants.TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);
    var KTXLoader = function() {
      function KTXLoader2() {
      }
      KTXLoader2.use = function(resource, next) {
        if (resource.extension === "ktx" && resource.data) {
          try {
            var url2 = resource.name || resource.url;
            Object.assign(resource, registerCompressedTextures(url2, KTXLoader2.parse(url2, resource.data), resource.metadata));
          } catch (err) {
            next(err);
            return;
          }
        }
        next();
      };
      KTXLoader2.parse = function(url2, arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        if (!KTXLoader2.validate(url2, dataView)) {
          return null;
        }
        var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
        var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
        var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
        var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
        var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
        var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
        var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
        var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
        var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
        var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
        var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
        if (pixelHeight === 0 || pixelDepth !== 1) {
          throw new Error("Only 2D textures are supported");
        }
        if (numberOfFaces !== 1) {
          throw new Error("CubeTextures are not supported by KTXLoader yet!");
        }
        if (numberOfArrayElements !== 1) {
          throw new Error("WebGL does not support array textures");
        }
        var blockWidth = 4;
        var blockHeight = 4;
        var alignedWidth = pixelWidth + 3 & ~3;
        var alignedHeight = pixelHeight + 3 & ~3;
        var imageBuffers = new Array(numberOfArrayElements);
        var imagePixels = pixelWidth * pixelHeight;
        if (glType === 0) {
          imagePixels = alignedWidth * alignedHeight;
        }
        var imagePixelByteSize;
        if (glType !== 0) {
          if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
            imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
          } else {
            imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
          }
        } else {
          imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
        }
        if (imagePixelByteSize === void 0) {
          throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
        }
        var imageByteSize = imagePixels * imagePixelByteSize;
        var mipByteSize = imageByteSize;
        var mipWidth = pixelWidth;
        var mipHeight = pixelHeight;
        var alignedMipWidth = alignedWidth;
        var alignedMipHeight = alignedHeight;
        var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
        for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
          var imageSize = dataView.getUint32(imageOffset, littleEndian);
          var elementOffset = imageOffset + 4;
          for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
            var mips = imageBuffers[arrayElement];
            if (!mips) {
              mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
            }
            mips[mipmapLevel] = {
              levelID: mipmapLevel,
              levelWidth: numberOfMipmapLevels > 1 ? mipWidth : alignedMipWidth,
              levelHeight: numberOfMipmapLevels > 1 ? mipHeight : alignedMipHeight,
              levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
            };
            elementOffset += mipByteSize;
          }
          imageOffset += imageSize + 4;
          imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
          mipWidth = mipWidth >> 1 || 1;
          mipHeight = mipHeight >> 1 || 1;
          alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
          alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
          mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
        }
        if (glType !== 0) {
          throw new Error("TODO: Uncompressed");
        }
        return imageBuffers.map(function(levelBuffers) {
          return new CompressedTextureResource(null, {
            format: glInternalFormat,
            width: pixelWidth,
            height: pixelHeight,
            levels: numberOfMipmapLevels,
            levelBuffers
          });
        });
      };
      KTXLoader2.validate = function(url2, dataView) {
        for (var i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {
          if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2]) {
            console.error(url2 + " is not a valid *.ktx file!");
            return false;
          }
        }
        return true;
      };
      return KTXLoader2;
    }();
    exports.BlobResource = BlobResource;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.CompressedTextureResource = CompressedTextureResource;
    exports.DDSLoader = DDSLoader;
    exports.FORMATS_TO_COMPONENTS = FORMATS_TO_COMPONENTS;
    exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
    exports.KTXLoader = KTXLoader;
    exports.TYPES_TO_BYTES_PER_COMPONENT = TYPES_TO_BYTES_PER_COMPONENT;
    exports.TYPES_TO_BYTES_PER_PIXEL = TYPES_TO_BYTES_PER_PIXEL;
  });

  // node_modules/@pixi/particles/dist/cjs/particles.js
  var require_particles = __commonJS((exports) => {
    /*!
     * @pixi/particles - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/particles is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var constants = require_constants();
    var display = require_display();
    var utils6 = require_utils();
    var core = require_core();
    var math = require_math();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var ParticleContainer = function(_super) {
      __extends(ParticleContainer2, _super);
      function ParticleContainer2(maxSize, properties, batchSize, autoResize) {
        if (maxSize === void 0) {
          maxSize = 1500;
        }
        if (batchSize === void 0) {
          batchSize = 16384;
        }
        if (autoResize === void 0) {
          autoResize = false;
        }
        var _this = _super.call(this) || this;
        var maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
          batchSize = maxBatchSize;
        }
        _this._properties = [false, true, false, false, false];
        _this._maxSize = maxSize;
        _this._batchSize = batchSize;
        _this._buffers = null;
        _this._bufferUpdateIDs = [];
        _this._updateID = 0;
        _this.interactiveChildren = false;
        _this.blendMode = constants.BLEND_MODES.NORMAL;
        _this.autoResize = autoResize;
        _this.roundPixels = true;
        _this.baseTexture = null;
        _this.setProperties(properties);
        _this._tint = 0;
        _this.tintRgb = new Float32Array(4);
        _this.tint = 16777215;
        return _this;
      }
      ParticleContainer2.prototype.setProperties = function(properties) {
        if (properties) {
          this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
          this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
          this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
          this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
          this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
      };
      ParticleContainer2.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
      };
      Object.defineProperty(ParticleContainer2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value) {
          this._tint = value;
          utils6.hex2rgb(value, this.tintRgb);
        },
        enumerable: false,
        configurable: true
      });
      ParticleContainer2.prototype.render = function(renderer) {
        var _this = this;
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        if (!this.baseTexture) {
          this.baseTexture = this.children[0]._texture.baseTexture;
          if (!this.baseTexture.valid) {
            this.baseTexture.once("update", function() {
              return _this.onChildrenChange(0);
            });
          }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
      };
      ParticleContainer2.prototype.onChildrenChange = function(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
          this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
      };
      ParticleContainer2.prototype.dispose = function() {
        if (this._buffers) {
          for (var i2 = 0; i2 < this._buffers.length; ++i2) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
        }
      };
      ParticleContainer2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
      };
      return ParticleContainer2;
    }(display.Container);
    var ParticleBuffer = function() {
      function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
        this.geometry = new core.Geometry();
        this.indexBuffer = null;
        this.size = size;
        this.dynamicProperties = [];
        this.staticProperties = [];
        for (var i2 = 0; i2 < properties.length; ++i2) {
          var property = properties[i2];
          property = {
            attributeName: property.attributeName,
            size: property.size,
            uploadFunction: property.uploadFunction,
            type: property.type || constants.TYPES.FLOAT,
            offset: property.offset
          };
          if (dynamicPropertyFlags[i2]) {
            this.dynamicProperties.push(property);
          } else {
            this.staticProperties.push(property);
          }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
      }
      ParticleBuffer2.prototype.initBuffers = function() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        this.indexBuffer = new core.Buffer(utils6.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
          var property = this.dynamicProperties[i2];
          property.offset = dynamicOffset;
          dynamicOffset += property.size;
          this.dynamicStride += property.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new core.Buffer(this.dynamicData, false, false);
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
          var property = this.staticProperties[i2];
          property.offset = staticOffset;
          staticOffset += property.size;
          this.staticStride += property.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new core.Buffer(this.staticData, true, false);
        for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
          var property = this.dynamicProperties[i2];
          geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === constants.TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
        }
        for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
          var property = this.staticProperties[i2];
          geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === constants.TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
        }
      };
      ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
        for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {
          var property = this.dynamicProperties[i2];
          property.uploadFunction(children, startIndex, amount, property.type === constants.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
      };
      ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
        for (var i2 = 0; i2 < this.staticProperties.length; i2++) {
          var property = this.staticProperties[i2];
          property.uploadFunction(children, startIndex, amount, property.type === constants.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
      };
      ParticleBuffer2.prototype.destroy = function() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.geometry.destroy();
      };
      return ParticleBuffer2;
    }();
    var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
    var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
    var ParticleRenderer = function(_super) {
      __extends(ParticleRenderer2, _super);
      function ParticleRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shader = null;
        _this.properties = null;
        _this.tempMatrix = new math.Matrix();
        _this.properties = [
          {
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: _this.uploadVertices,
            offset: 0
          },
          {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: _this.uploadPosition,
            offset: 0
          },
          {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: _this.uploadRotation,
            offset: 0
          },
          {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: _this.uploadUvs,
            offset: 0
          },
          {
            attributeName: "aColor",
            size: 1,
            type: constants.TYPES.UNSIGNED_BYTE,
            uploadFunction: _this.uploadTint,
            offset: 0
          }
        ];
        _this.shader = core.Shader.from(vertex, fragment, {});
        _this.state = core.State.for2d();
        return _this;
      }
      ParticleRenderer2.prototype.render = function(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
          return;
        } else if (totalChildren > maxSize && !container.autoResize) {
          totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
          buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        this.state.blendMode = utils6.correctBlendMode(container.blendMode, baseTexture.alphaMode);
        renderer.state.set(this.state);
        var gl = renderer.gl;
        var m2 = container.worldTransform.copyTo(this.tempMatrix);
        m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m2.toArray(true);
        this.shader.uniforms.uColor = utils6.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        for (var i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
          var amount = totalChildren - i2;
          if (amount > batchSize) {
            amount = batchSize;
          }
          if (j2 >= buffers.length) {
            buffers.push(this._generateOneMoreBuffer(container));
          }
          var buffer = buffers[j2];
          buffer.uploadDynamic(children, i2, amount);
          var bid = container._bufferUpdateIDs[j2] || 0;
          updateStatic = updateStatic || buffer._updateID < bid;
          if (updateStatic) {
            buffer._updateID = container._updateID;
            buffer.uploadStatic(children, i2, amount);
          }
          renderer.geometry.bind(buffer.geometry);
          gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
      };
      ParticleRenderer2.prototype.generateBuffers = function(container) {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i2 = 0; i2 < size; i2 += batchSize) {
          buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
      };
      ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
      };
      ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i2 = 0; i2 < amount; ++i2) {
          var sprite = children[startIndex + i2];
          var texture = sprite._texture;
          var sx = sprite.scale.x;
          var sy = sprite.scale.y;
          var trim = texture.trim;
          var orig = texture.orig;
          if (trim) {
            w1 = trim.x - sprite.anchor.x * orig.width;
            w0 = w1 + trim.width;
            h1 = trim.y - sprite.anchor.y * orig.height;
            h0 = h1 + trim.height;
          } else {
            w0 = orig.width * (1 - sprite.anchor.x);
            w1 = orig.width * -sprite.anchor.x;
            h0 = orig.height * (1 - sprite.anchor.y);
            h1 = orig.height * -sprite.anchor.y;
          }
          array[offset] = w1 * sx;
          array[offset + 1] = h1 * sy;
          array[offset + stride] = w0 * sx;
          array[offset + stride + 1] = h1 * sy;
          array[offset + stride * 2] = w0 * sx;
          array[offset + stride * 2 + 1] = h0 * sy;
          array[offset + stride * 3] = w1 * sx;
          array[offset + stride * 3 + 1] = h0 * sy;
          offset += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
        for (var i2 = 0; i2 < amount; i2++) {
          var spritePosition = children[startIndex + i2].position;
          array[offset] = spritePosition.x;
          array[offset + 1] = spritePosition.y;
          array[offset + stride] = spritePosition.x;
          array[offset + stride + 1] = spritePosition.y;
          array[offset + stride * 2] = spritePosition.x;
          array[offset + stride * 2 + 1] = spritePosition.y;
          array[offset + stride * 3] = spritePosition.x;
          array[offset + stride * 3 + 1] = spritePosition.y;
          offset += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
        for (var i2 = 0; i2 < amount; i2++) {
          var spriteRotation = children[startIndex + i2].rotation;
          array[offset] = spriteRotation;
          array[offset + stride] = spriteRotation;
          array[offset + stride * 2] = spriteRotation;
          array[offset + stride * 3] = spriteRotation;
          offset += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
        for (var i2 = 0; i2 < amount; ++i2) {
          var textureUvs = children[startIndex + i2]._texture._uvs;
          if (textureUvs) {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;
            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;
            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;
            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;
            offset += stride * 4;
          } else {
            array[offset] = 0;
            array[offset + 1] = 0;
            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;
            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;
            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;
            offset += stride * 4;
          }
        }
      };
      ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
        for (var i2 = 0; i2 < amount; ++i2) {
          var sprite = children[startIndex + i2];
          var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
          var alpha = sprite.alpha;
          var argb = alpha < 1 && premultiplied ? utils6.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
          array[offset] = argb;
          array[offset + stride] = argb;
          array[offset + stride * 2] = argb;
          array[offset + stride * 3] = argb;
          offset += stride * 4;
        }
      };
      ParticleRenderer2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        if (this.shader) {
          this.shader.destroy();
          this.shader = null;
        }
        this.tempMatrix = null;
      };
      return ParticleRenderer2;
    }(core.ObjectRenderer);
    exports.ParticleContainer = ParticleContainer;
    exports.ParticleRenderer = ParticleRenderer;
  });

  // node_modules/@pixi/graphics/dist/cjs/graphics.js
  var require_graphics = __commonJS((exports) => {
    /*!
     * @pixi/graphics - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/graphics is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var math = require_math();
    var utils6 = require_utils();
    var constants = require_constants();
    var display = require_display();
    (function(LINE_JOIN) {
      LINE_JOIN["MITER"] = "miter";
      LINE_JOIN["BEVEL"] = "bevel";
      LINE_JOIN["ROUND"] = "round";
    })(exports.LINE_JOIN || (exports.LINE_JOIN = {}));
    (function(LINE_CAP) {
      LINE_CAP["BUTT"] = "butt";
      LINE_CAP["ROUND"] = "round";
      LINE_CAP["SQUARE"] = "square";
    })(exports.LINE_CAP || (exports.LINE_CAP = {}));
    var GRAPHICS_CURVES = {
      adaptive: true,
      maxLength: 10,
      minSegments: 8,
      maxSegments: 2048,
      epsilon: 1e-4,
      _segmentsCount: function(length, defaultSegments) {
        if (defaultSegments === void 0) {
          defaultSegments = 20;
        }
        if (!this.adaptive || !length || isNaN(length)) {
          return defaultSegments;
        }
        var result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
          result = this.minSegments;
        } else if (result > this.maxSegments) {
          result = this.maxSegments;
        }
        return result;
      }
    };
    var FillStyle = function() {
      function FillStyle2() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = core.Texture.WHITE;
        this.matrix = null;
        this.visible = false;
        this.reset();
      }
      FillStyle2.prototype.clone = function() {
        var obj = new FillStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
      };
      FillStyle2.prototype.reset = function() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = core.Texture.WHITE;
        this.matrix = null;
        this.visible = false;
      };
      FillStyle2.prototype.destroy = function() {
        this.texture = null;
        this.matrix = null;
      };
      return FillStyle2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var buildPoly = {
      build: function(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        if (points.length >= 6) {
          var holeArray = [];
          for (var i2 = 0; i2 < holes.length; i2++) {
            var hole = holes[i2];
            holeArray.push(points.length / 2);
            points = points.concat(hole.points);
          }
          var triangles = utils6.earcut(points, holeArray, 2);
          if (!triangles) {
            return;
          }
          var vertPos = verts.length / 2;
          for (var i2 = 0; i2 < triangles.length; i2 += 3) {
            indices.push(triangles[i2] + vertPos);
            indices.push(triangles[i2 + 1] + vertPos);
            indices.push(triangles[i2 + 2] + vertPos);
          }
          for (var i2 = 0; i2 < points.length; i2++) {
            verts.push(points[i2]);
          }
        }
      }
    };
    var buildCircle = {
      build: function(graphicsData) {
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = circleData.x;
        var y2 = circleData.y;
        var width;
        var height;
        points.length = 0;
        if (graphicsData.type === math.SHAPES.CIRC) {
          width = circleData.radius;
          height = circleData.radius;
        } else {
          var ellipseData = graphicsData.shape;
          width = ellipseData.width;
          height = ellipseData.height;
        }
        if (width === 0 || height === 0) {
          return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width + height));
        totalSegs /= 2.3;
        var seg = Math.PI * 2 / totalSegs;
        for (var i2 = 0; i2 < totalSegs - 0.5; i2++) {
          points.push(x2 + Math.sin(-seg * i2) * width, y2 + Math.cos(-seg * i2) * height);
        }
        points.push(points[0], points[1]);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center2 = vertPos;
        var circle = graphicsData.shape;
        var matrix = graphicsData.matrix;
        var x2 = circle.x;
        var y2 = circle.y;
        verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
        for (var i2 = 0; i2 < points.length; i2 += 2) {
          verts.push(points[i2], points[i2 + 1]);
          indices.push(vertPos++, center2, vertPos);
        }
      }
    };
    var buildRectangle = {
      build: function(graphicsData) {
        var rectData = graphicsData.shape;
        var x2 = rectData.x;
        var y2 = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
      }
    };
    function getPt(n1, n2, perc) {
      var diff = n2 - n1;
      return n1 + diff * perc;
    }
    function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
      if (out === void 0) {
        out = [];
      }
      var n2 = 20;
      var points = out;
      var xa = 0;
      var ya = 0;
      var xb = 0;
      var yb = 0;
      var x2 = 0;
      var y2 = 0;
      for (var i2 = 0, j2 = 0; i2 <= n2; ++i2) {
        j2 = i2 / n2;
        xa = getPt(fromX, cpX, j2);
        ya = getPt(fromY, cpY, j2);
        xb = getPt(cpX, toX, j2);
        yb = getPt(cpY, toY, j2);
        x2 = getPt(xa, xb, j2);
        y2 = getPt(ya, yb, j2);
        points.push(x2, y2);
      }
      return points;
    }
    var buildRoundedRectangle = {
      build: function(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = rrectData.x;
        var y2 = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
        points.length = 0;
        if (!radius) {
          points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
        } else {
          quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);
          quadraticBezierCurve(x2 + width - radius, y2, x2 + width, y2, x2 + width, y2 + radius, points);
          quadraticBezierCurve(x2 + width, y2 + height - radius, x2 + width, y2 + height, x2 + width - radius, y2 + height, points);
          quadraticBezierCurve(x2 + radius, y2 + height, x2, y2 + height, x2, y2 + height - radius, points);
        }
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = utils6.earcut(points, null, 2);
        for (var i2 = 0, j2 = triangles.length; i2 < j2; i2 += 3) {
          indices.push(triangles[i2] + vecPos);
          indices.push(triangles[i2 + 1] + vecPos);
          indices.push(triangles[i2 + 2] + vecPos);
        }
        for (var i2 = 0, j2 = points.length; i2 < j2; i2++) {
          verts.push(points[i2], points[++i2]);
        }
      }
    };
    function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
      var ix = x2 - nx * innerWeight;
      var iy = y2 - ny * innerWeight;
      var ox = x2 + nx * outerWeight;
      var oy = y2 + ny * outerWeight;
      var exx;
      var eyy;
      if (clockwise) {
        exx = ny;
        eyy = -nx;
      } else {
        exx = -ny;
        eyy = nx;
      }
      var eix = ix + exx;
      var eiy = iy + eyy;
      var eox = ox + exx;
      var eoy = oy + eyy;
      verts.push(eix, eiy);
      verts.push(eox, eoy);
      return 2;
    }
    function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
      var cx2p0x = sx - cx;
      var cy2p0y = sy - cy;
      var angle0 = Math.atan2(cx2p0x, cy2p0y);
      var angle1 = Math.atan2(ex - cx, ey - cy);
      if (clockwise && angle0 < angle1) {
        angle0 += Math.PI * 2;
      } else if (!clockwise && angle0 > angle1) {
        angle1 += Math.PI * 2;
      }
      var startAngle = angle0;
      var angleDiff = angle1 - angle0;
      var absAngleDiff = Math.abs(angleDiff);
      var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
      var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
      var angleInc = angleDiff / segCount;
      startAngle += angleInc;
      if (clockwise) {
        verts.push(cx, cy);
        verts.push(sx, sy);
        for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
          verts.push(cx, cy);
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        }
        verts.push(cx, cy);
        verts.push(ex, ey);
      } else {
        verts.push(sx, sy);
        verts.push(cx, cy);
        for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
          verts.push(cx, cy);
        }
        verts.push(ex, ey);
        verts.push(cx, cy);
      }
      return segCount * 2;
    }
    function buildNonNativeLine(graphicsData, graphicsGeometry) {
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points.slice();
      var eps = graphicsGeometry.closePointEps;
      if (points.length === 0) {
        return;
      }
      var style = graphicsData.lineStyle;
      var firstPoint = new math.Point(points[0], points[1]);
      var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);
      var closedShape = shape.type !== math.SHAPES.POLY || shape.closeStroke;
      var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
      if (closedShape) {
        points = points.slice();
        if (closedPath) {
          points.pop();
          points.pop();
          lastPoint.set(points[points.length - 2], points[points.length - 1]);
        }
        var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
        var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
      }
      var verts = graphicsGeometry.points;
      var length = points.length / 2;
      var indexCount = points.length;
      var indexStart = verts.length / 2;
      var width = style.width / 2;
      var widthSquared = width * width;
      var miterLimitSquared = style.miterLimit * style.miterLimit;
      var x0 = points[0];
      var y0 = points[1];
      var x1 = points[2];
      var y1 = points[3];
      var x2 = 0;
      var y2 = 0;
      var perpx = -(y0 - y1);
      var perpy = x0 - x1;
      var perp1x = 0;
      var perp1y = 0;
      var dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width;
      perpy *= width;
      var ratio = style.alignment;
      var innerWeight = (1 - ratio) * 2;
      var outerWeight = ratio * 2;
      if (!closedShape) {
        if (style.cap === exports.LINE_CAP.ROUND) {
          indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
        } else if (style.cap === exports.LINE_CAP.SQUARE) {
          indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
        }
      }
      verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
      verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
      for (var i2 = 1; i2 < length - 1; ++i2) {
        x0 = points[(i2 - 1) * 2];
        y0 = points[(i2 - 1) * 2 + 1];
        x1 = points[i2 * 2];
        y1 = points[i2 * 2 + 1];
        x2 = points[(i2 + 1) * 2];
        y2 = points[(i2 + 1) * 2 + 1];
        perpx = -(y0 - y1);
        perpy = x0 - x1;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        perp1x = -(y1 - y2);
        perp1y = x1 - x2;
        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
        perp1x /= dist;
        perp1y /= dist;
        perp1x *= width;
        perp1y *= width;
        var dx0 = x1 - x0;
        var dy0 = y0 - y1;
        var dx1 = x1 - x2;
        var dy1 = y2 - y1;
        var cross = dy0 * dx1 - dy1 * dx0;
        var clockwise = cross < 0;
        if (Math.abs(cross) < 0.1) {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          continue;
        }
        var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
        var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
        var px = (dx0 * c2 - dx1 * c1) / cross;
        var py = (dy1 * c1 - dy0 * c2) / cross;
        var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
        var imx = x1 + (px - x1) * innerWeight;
        var imy = y1 + (py - y1) * innerWeight;
        var omx = x1 - (px - x1) * outerWeight;
        var omy = y1 - (py - y1) * outerWeight;
        var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
        var insideWeight = clockwise ? innerWeight : outerWeight;
        var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
        var insideMiterOk = pdist <= smallerInsideDiagonalSq;
        if (insideMiterOk) {
          if (style.join === exports.LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
            if (clockwise) {
              verts.push(imx, imy);
              verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
              verts.push(imx, imy);
              verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
            } else {
              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
              verts.push(omx, omy);
              verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
              verts.push(omx, omy);
            }
            indexCount += 2;
          } else if (style.join === exports.LINE_JOIN.ROUND) {
            if (clockwise) {
              verts.push(imx, imy);
              verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
              verts.push(imx, imy);
              verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
            } else {
              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
              verts.push(omx, omy);
              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
              verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
              verts.push(omx, omy);
            }
          } else {
            verts.push(imx, imy);
            verts.push(omx, omy);
          }
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          if (style.join === exports.LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)
            ;
          else if (style.join === exports.LINE_JOIN.ROUND) {
            if (clockwise) {
              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
            } else {
              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
            }
          } else {
            if (clockwise) {
              verts.push(omx, omy);
              verts.push(omx, omy);
            } else {
              verts.push(imx, imy);
              verts.push(imx, imy);
            }
            indexCount += 2;
          }
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          indexCount += 2;
        }
      }
      x0 = points[(length - 2) * 2];
      y0 = points[(length - 2) * 2 + 1];
      x1 = points[(length - 1) * 2];
      y1 = points[(length - 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width;
      perpy *= width;
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (!closedShape) {
        if (style.cap === exports.LINE_CAP.ROUND) {
          indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
        } else if (style.cap === exports.LINE_CAP.SQUARE) {
          indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
        }
      }
      var indices = graphicsGeometry.indices;
      var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
      for (var i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
        x0 = verts[i2 * 2];
        y0 = verts[i2 * 2 + 1];
        x1 = verts[(i2 + 1) * 2];
        y1 = verts[(i2 + 1) * 2 + 1];
        x2 = verts[(i2 + 2) * 2];
        y2 = verts[(i2 + 2) * 2 + 1];
        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
          continue;
        }
        indices.push(i2, i2 + 1, i2 + 2);
      }
    }
    function buildNativeLine(graphicsData, graphicsGeometry) {
      var i2 = 0;
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points;
      var closedShape = shape.type !== math.SHAPES.POLY || shape.closeStroke;
      if (points.length === 0) {
        return;
      }
      var verts = graphicsGeometry.points;
      var indices = graphicsGeometry.indices;
      var length = points.length / 2;
      var startIndex = verts.length / 2;
      var currentIndex = startIndex;
      verts.push(points[0], points[1]);
      for (i2 = 1; i2 < length; i2++) {
        verts.push(points[i2 * 2], points[i2 * 2 + 1]);
        indices.push(currentIndex, currentIndex + 1);
        currentIndex++;
      }
      if (closedShape) {
        indices.push(currentIndex, startIndex);
      }
    }
    function buildLine(graphicsData, graphicsGeometry) {
      if (graphicsData.lineStyle.native) {
        buildNativeLine(graphicsData, graphicsGeometry);
      } else {
        buildNonNativeLine(graphicsData, graphicsGeometry);
      }
    }
    var ArcUtils = function() {
      function ArcUtils2() {
      }
      ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
          return null;
        }
        var dd = a1 * a1 + b1 * b1;
        var cc = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
          cx: cx + x1,
          cy: cy + y1,
          radius,
          startAngle,
          endAngle,
          anticlockwise: b1 * a2 > b2 * a1
        };
      };
      ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n2 = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / math.PI_2) * 40);
        var theta = sweep / (n2 * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n2 - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i2 = 0; i2 <= segMinus; ++i2) {
          var real = i2 + remainder * i2;
          var angle = theta + startAngle + theta2 * real;
          var c2 = Math.cos(angle);
          var s3 = -Math.sin(angle);
          points.push((cTheta * c2 + sTheta * s3) * radius + cx, (cTheta * -s3 + sTheta * c2) * radius + cy);
        }
      };
      return ArcUtils2;
    }();
    var BezierUtils = function() {
      function BezierUtils2() {
      }
      BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n2 = 10;
        var result = 0;
        var t2 = 0;
        var t22 = 0;
        var t3 = 0;
        var nt = 0;
        var nt2 = 0;
        var nt3 = 0;
        var x2 = 0;
        var y2 = 0;
        var dx = 0;
        var dy = 0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i2 = 1; i2 <= n2; ++i2) {
          t2 = i2 / n2;
          t22 = t2 * t2;
          t3 = t22 * t2;
          nt = 1 - t2;
          nt2 = nt * nt;
          nt3 = nt2 * nt;
          x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
          y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
          dx = prevX - x2;
          dy = prevY - y2;
          prevX = x2;
          prevY = y2;
          result += Math.sqrt(dx * dx + dy * dy);
        }
        return result;
      };
      BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n2 = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i2 = 1, j2 = 0; i2 <= n2; ++i2) {
          j2 = i2 / n2;
          dt = 1 - j2;
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j2 * j2;
          t3 = t2 * j2;
          points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
      };
      return BezierUtils2;
    }();
    var QuadraticUtils = function() {
      function QuadraticUtils2() {
      }
      QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - 2 * cpX + toX;
        var ay = fromY - 2 * cpY + toY;
        var bx = 2 * cpX - 2 * fromX;
        var by = 2 * cpY - 2 * fromY;
        var a2 = 4 * (ax * ax + ay * ay);
        var b2 = 4 * (ax * bx + ay * by);
        var c2 = bx * bx + by * by;
        var s3 = 2 * Math.sqrt(a2 + b2 + c2);
        var a22 = Math.sqrt(a2);
        var a32 = 2 * a2 * a22;
        var c22 = 2 * Math.sqrt(c2);
        var ba = b2 / a22;
        return (a32 * s3 + a22 * b2 * (s3 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba + s3) / (ba + c22))) / (4 * a32);
      };
      QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n2 = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i2 = 1; i2 <= n2; ++i2) {
          var j2 = i2 / n2;
          xa = fromX + (cpX - fromX) * j2;
          ya = fromY + (cpY - fromY) * j2;
          points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);
        }
      };
      return QuadraticUtils2;
    }();
    var BatchPart = function() {
      function BatchPart2() {
        this.reset();
      }
      BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
        this.reset();
        this.style = style;
        this.start = startIndex;
        this.attribStart = attribStart;
      };
      BatchPart2.prototype.end = function(endIndex, endAttrib) {
        this.attribSize = endAttrib - this.attribStart;
        this.size = endIndex - this.start;
      };
      BatchPart2.prototype.reset = function() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
      };
      return BatchPart2;
    }();
    var _a;
    var FILL_COMMANDS = (_a = {}, _a[math.SHAPES.POLY] = buildPoly, _a[math.SHAPES.CIRC] = buildCircle, _a[math.SHAPES.ELIP] = buildCircle, _a[math.SHAPES.RECT] = buildRectangle, _a[math.SHAPES.RREC] = buildRoundedRectangle, _a);
    var BATCH_POOL = [];
    var DRAW_CALL_POOL = [];
    var GraphicsData = function() {
      function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        this.shape = shape;
        this.lineStyle = lineStyle;
        this.fillStyle = fillStyle;
        this.matrix = matrix;
        this.type = shape.type;
        this.points = [];
        this.holes = [];
      }
      GraphicsData2.prototype.clone = function() {
        return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
      };
      GraphicsData2.prototype.destroy = function() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
      };
      return GraphicsData2;
    }();
    var tmpPoint = new math.Point();
    var tmpBounds = new display.Bounds();
    var GraphicsGeometry = function(_super) {
      __extends(GraphicsGeometry2, _super);
      function GraphicsGeometry2() {
        var _this = _super.call(this) || this;
        _this.uvsFloat32 = null;
        _this.indicesUint16 = null;
        _this.points = [];
        _this.colors = [];
        _this.uvs = [];
        _this.indices = [];
        _this.textureIds = [];
        _this.graphicsData = [];
        _this.dirty = 0;
        _this.batchDirty = -1;
        _this.cacheDirty = -1;
        _this.clearDirty = 0;
        _this.drawCalls = [];
        _this.batches = [];
        _this.shapeIndex = 0;
        _this._bounds = new display.Bounds();
        _this.boundsDirty = -1;
        _this.boundsPadding = 0;
        _this.batchable = false;
        _this.indicesUint16 = null;
        _this.uvsFloat32 = null;
        _this.closePointEps = 1e-4;
        return _this;
      }
      Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
        get: function() {
          if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
          }
          return this._bounds;
        },
        enumerable: false,
        configurable: true
      });
      GraphicsGeometry2.prototype.invalidate = function() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
          this.drawCalls[i2].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i2]);
        }
        this.drawCalls.length = 0;
        for (var i2 = 0; i2 < this.batches.length; i2++) {
          var batchPart = this.batches[i2];
          batchPart.reset();
          BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      };
      GraphicsGeometry2.prototype.clear = function() {
        if (this.graphicsData.length > 0) {
          this.invalidate();
          this.clearDirty++;
          this.graphicsData.length = 0;
        }
        return this;
      };
      GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        if (!this.graphicsData.length) {
          return null;
        }
        var data = new GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        for (var i2 = 0; i2 < this.graphicsData.length; ++i2) {
          this.graphicsData[i2].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
      };
      GraphicsGeometry2.prototype.containsPoint = function(point) {
        var graphicsData = this.graphicsData;
        for (var i2 = 0; i2 < graphicsData.length; ++i2) {
          var data = graphicsData[i2];
          if (!data.fillStyle.visible) {
            continue;
          }
          if (data.shape) {
            if (data.matrix) {
              data.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
              var hitHole = false;
              if (data.holes) {
                for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
                  var hole = data.holes[i_1];
                  if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
                }
              }
              if (!hitHole) {
                return true;
              }
            }
          }
        }
        return false;
      };
      GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
        if (!this.graphicsData.length) {
          this.batchable = true;
          return;
        }
        if (!this.validateBatching()) {
          return;
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var graphicsData = this.graphicsData;
        var batchPart = null;
        var currentStyle = null;
        if (this.batches.length > 0) {
          batchPart = this.batches[this.batches.length - 1];
          currentStyle = batchPart.style;
        }
        for (var i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
          this.shapeIndex++;
          var data = graphicsData[i2];
          var fillStyle = data.fillStyle;
          var lineStyle = data.lineStyle;
          var command = FILL_COMMANDS[data.type];
          command.build(data);
          if (data.matrix) {
            this.transformPoints(data.points, data.matrix);
          }
          for (var j2 = 0; j2 < 2; j2++) {
            var style = j2 === 0 ? fillStyle : lineStyle;
            if (!style.visible) {
              continue;
            }
            var nextTexture = style.texture.baseTexture;
            var index_1 = this.indices.length;
            var attribIndex = this.points.length / 2;
            nextTexture.wrapMode = constants.WRAP_MODES.REPEAT;
            if (j2 === 0) {
              this.processFill(data);
            } else {
              this.processLine(data);
            }
            var size = this.points.length / 2 - attribIndex;
            if (size === 0) {
              continue;
            }
            if (batchPart && !this._compareStyles(currentStyle, style)) {
              batchPart.end(index_1, attribIndex);
              batchPart = null;
            }
            if (!batchPart) {
              batchPart = BATCH_POOL.pop() || new BatchPart();
              batchPart.begin(style, index_1, attribIndex);
              this.batches.push(batchPart);
              currentStyle = style;
            }
            this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
          }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        if (batchPart) {
          batchPart.end(index, attrib);
        }
        if (this.batches.length === 0) {
          this.batchable = true;
          return;
        }
        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
          this.indicesUint16.set(this.indices);
        } else {
          var need32 = attrib > 65535 && allow32Indices;
          this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.batchable = this.isBatchable();
        if (this.batchable) {
          this.packBatches();
        } else {
          this.buildDrawCalls();
        }
      };
      GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
        if (!styleA || !styleB) {
          return false;
        }
        if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
          return false;
        }
        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
          return false;
        }
        if (!!styleA.native !== !!styleB.native) {
          return false;
        }
        return true;
      };
      GraphicsGeometry2.prototype.validateBatching = function() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return false;
        }
        for (var i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
          var data = this.graphicsData[i2];
          var fill = data.fillStyle;
          var line = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid) {
            return false;
          }
          if (line && !line.texture.baseTexture.valid) {
            return false;
          }
        }
        return true;
      };
      GraphicsGeometry2.prototype.packBatches = function() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        var batches = this.batches;
        for (var i2 = 0, l2 = batches.length; i2 < l2; i2++) {
          var batch = batches[i2];
          for (var j2 = 0; j2 < batch.size; j2++) {
            var index = batch.start + j2;
            this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
          }
        }
      };
      GraphicsGeometry2.prototype.isBatchable = function() {
        if (this.points.length > 65535 * 2) {
          return false;
        }
        var batches = this.batches;
        for (var i2 = 0; i2 < batches.length; i2++) {
          if (batches[i2].style.native) {
            return false;
          }
        }
        return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
      };
      GraphicsGeometry2.prototype.buildDrawCalls = function() {
        var TICK = ++core.BaseTexture._globalBatch;
        for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
          this.drawCalls[i2].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i2]);
        }
        this.drawCalls.length = 0;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = DRAW_CALL_POOL.pop();
        if (!currentGroup) {
          currentGroup = new core.BatchDrawCall();
          currentGroup.texArray = new core.BatchTextureArray();
        }
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = constants.DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = constants.DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        for (var i2 = 0; i2 < this.batches.length; i2++) {
          var data = this.batches[i2];
          var MAX_TEXTURES = 8;
          var style = data.style;
          var nextTexture = style.texture.baseTexture;
          if (native !== !!style.native) {
            native = !!style.native;
            drawMode = native ? constants.DRAW_MODES.LINES : constants.DRAW_MODES.TRIANGLES;
            currentTexture = null;
            textureCount = MAX_TEXTURES;
            TICK++;
          }
          if (currentTexture !== nextTexture) {
            currentTexture = nextTexture;
            if (nextTexture._batchEnabled !== TICK) {
              if (textureCount === MAX_TEXTURES) {
                TICK++;
                textureCount = 0;
                if (currentGroup.size > 0) {
                  currentGroup = DRAW_CALL_POOL.pop();
                  if (!currentGroup) {
                    currentGroup = new core.BatchDrawCall();
                    currentGroup.texArray = new core.BatchTextureArray();
                  }
                  this.drawCalls.push(currentGroup);
                }
                currentGroup.start = index;
                currentGroup.size = 0;
                currentGroup.texArray.count = 0;
                currentGroup.type = drawMode;
              }
              nextTexture.touched = 1;
              nextTexture._batchEnabled = TICK;
              nextTexture._batchLocation = textureCount;
              nextTexture.wrapMode = 10497;
              currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
              textureCount++;
            }
          }
          currentGroup.size += data.size;
          index += data.size;
          textureId = nextTexture._batchLocation;
          this.addColors(colors, style.color, style.alpha, data.attribSize);
          this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        core.BaseTexture._globalBatch = TICK;
        this.packAttributes();
      };
      GraphicsGeometry2.prototype.packAttributes = function() {
        var verts = this.points;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p2 = 0;
        for (var i2 = 0; i2 < verts.length / 2; i2++) {
          f32[p2++] = verts[i2 * 2];
          f32[p2++] = verts[i2 * 2 + 1];
          f32[p2++] = uvs[i2 * 2];
          f32[p2++] = uvs[i2 * 2 + 1];
          u32[p2++] = colors[i2];
          f32[p2++] = textureIds[i2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      };
      GraphicsGeometry2.prototype.processFill = function(data) {
        if (data.holes.length) {
          this.processHoles(data.holes);
          buildPoly.triangulate(data, this);
        } else {
          var command = FILL_COMMANDS[data.type];
          command.triangulate(data, this);
        }
      };
      GraphicsGeometry2.prototype.processLine = function(data) {
        buildLine(data, this);
        for (var i2 = 0; i2 < data.holes.length; i2++) {
          buildLine(data.holes[i2], this);
        }
      };
      GraphicsGeometry2.prototype.processHoles = function(holes) {
        for (var i2 = 0; i2 < holes.length; i2++) {
          var hole = holes[i2];
          var command = FILL_COMMANDS[hole.type];
          command.build(hole);
          if (hole.matrix) {
            this.transformPoints(hole.points, hole.matrix);
          }
        }
      };
      GraphicsGeometry2.prototype.calculateBounds = function() {
        var bounds = this._bounds;
        var sequenceBounds = tmpBounds;
        var curMatrix = math.Matrix.IDENTITY;
        this._bounds.clear();
        sequenceBounds.clear();
        for (var i2 = 0; i2 < this.graphicsData.length; i2++) {
          var data = this.graphicsData[i2];
          var shape = data.shape;
          var type2 = data.type;
          var lineStyle = data.lineStyle;
          var nextMatrix = data.matrix || math.Matrix.IDENTITY;
          var lineWidth = 0;
          if (lineStyle && lineStyle.visible) {
            var alignment = lineStyle.alignment;
            lineWidth = lineStyle.width;
            if (type2 === math.SHAPES.POLY) {
              lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));
            } else {
              lineWidth = lineWidth * Math.max(0, alignment);
            }
          }
          if (curMatrix !== nextMatrix) {
            if (!sequenceBounds.isEmpty()) {
              bounds.addBoundsMatrix(sequenceBounds, curMatrix);
              sequenceBounds.clear();
            }
            curMatrix = nextMatrix;
          }
          if (type2 === math.SHAPES.RECT || type2 === math.SHAPES.RREC) {
            var rect = shape;
            sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
          } else if (type2 === math.SHAPES.CIRC) {
            var circle = shape;
            sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
          } else if (type2 === math.SHAPES.ELIP) {
            var ellipse = shape;
            sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
          } else {
            var poly = shape;
            bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
          }
        }
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
        }
        bounds.pad(this.boundsPadding, this.boundsPadding);
      };
      GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          var x2 = points[i2 * 2];
          var y2 = points[i2 * 2 + 1];
          points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
          points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        }
      };
      GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size) {
        var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
        var rgba = utils6.premultiplyTint(rgb, alpha);
        while (size-- > 0) {
          colors.push(rgba);
        }
      };
      GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size) {
        while (size-- > 0) {
          textureIds.push(id);
        }
      };
      GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
          var x2 = verts[(start + index) * 2];
          var y2 = verts[(start + index) * 2 + 1];
          if (matrix) {
            var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
            y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
            x2 = nx;
          }
          index++;
          uvs.push(x2 / frame.width, y2 / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
          this.adjustUvs(uvs, texture, uvsStart, size);
        }
      };
      GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + size * 2;
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.height;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i2 = start + 2; i2 < finish; i2 += 2) {
          minX = Math.min(minX, Math.floor(uvs[i2] + eps));
          minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i2 = start; i2 < finish; i2 += 2) {
          uvs[i2] = (uvs[i2] + offsetX) * scaleX;
          uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
        }
      };
      GraphicsGeometry2.BATCHABLE_SIZE = 100;
      return GraphicsGeometry2;
    }(core.BatchGeometry);
    var LineStyle = function(_super) {
      __extends(LineStyle2, _super);
      function LineStyle2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.alignment = 0.5;
        _this.native = false;
        _this.cap = exports.LINE_CAP.BUTT;
        _this.join = exports.LINE_JOIN.MITER;
        _this.miterLimit = 10;
        return _this;
      }
      LineStyle2.prototype.clone = function() {
        var obj = new LineStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        obj.cap = this.cap;
        obj.join = this.join;
        obj.miterLimit = this.miterLimit;
        return obj;
      };
      LineStyle2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.color = 0;
        this.alignment = 0.5;
        this.width = 0;
        this.native = false;
      };
      return LineStyle2;
    }(FillStyle);
    var temp = new Float32Array(3);
    var DEFAULT_SHADERS = {};
    var Graphics4 = function(_super) {
      __extends(Graphics5, _super);
      function Graphics5(geometry) {
        if (geometry === void 0) {
          geometry = null;
        }
        var _this = _super.call(this) || this;
        _this._geometry = geometry || new GraphicsGeometry();
        _this._geometry.refCount++;
        _this.shader = null;
        _this.state = core.State.for2d();
        _this._fillStyle = new FillStyle();
        _this._lineStyle = new LineStyle();
        _this._matrix = null;
        _this._holeMode = false;
        _this.currentPath = null;
        _this.batches = [];
        _this.batchTint = -1;
        _this.batchDirty = -1;
        _this.vertexData = null;
        _this.pluginName = "batch";
        _this._transformID = -1;
        _this.tint = 16777215;
        _this.blendMode = constants.BLEND_MODES.NORMAL;
        return _this;
      }
      Object.defineProperty(Graphics5.prototype, "geometry", {
        get: function() {
          return this._geometry;
        },
        enumerable: false,
        configurable: true
      });
      Graphics5.prototype.clone = function() {
        this.finishPoly();
        return new Graphics5(this._geometry);
      };
      Object.defineProperty(Graphics5.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics5.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value) {
          this._tint = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics5.prototype, "fill", {
        get: function() {
          return this._fillStyle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics5.prototype, "line", {
        get: function() {
          return this._lineStyle;
        },
        enumerable: false,
        configurable: true
      });
      Graphics5.prototype.lineStyle = function(options, color, alpha, alignment, native) {
        if (options === void 0) {
          options = null;
        }
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        if (alignment === void 0) {
          alignment = 0.5;
        }
        if (native === void 0) {
          native = false;
        }
        if (typeof options === "number") {
          options = {width: options, color, alpha, alignment, native};
        }
        return this.lineTextureStyle(options);
      };
      Graphics5.prototype.lineTextureStyle = function(options) {
        options = Object.assign({
          width: 0,
          texture: core.Texture.WHITE,
          color: options && options.texture ? 16777215 : 0,
          alpha: 1,
          matrix: null,
          alignment: 0.5,
          native: false,
          cap: exports.LINE_CAP.BUTT,
          join: exports.LINE_JOIN.MITER,
          miterLimit: 10
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.width > 0 && options.alpha > 0;
        if (!visible) {
          this._lineStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._lineStyle, {visible}, options);
        }
        return this;
      };
      Graphics5.prototype.startPoly = function() {
        if (this.currentPath) {
          var points = this.currentPath.points;
          var len = this.currentPath.points.length;
          if (len > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = new math.Polygon();
            this.currentPath.closeStroke = false;
            this.currentPath.points.push(points[len - 2], points[len - 1]);
          }
        } else {
          this.currentPath = new math.Polygon();
          this.currentPath.closeStroke = false;
        }
      };
      Graphics5.prototype.finishPoly = function() {
        if (this.currentPath) {
          if (this.currentPath.points.length > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = null;
          } else {
            this.currentPath.points.length = 0;
          }
        }
      };
      Graphics5.prototype.moveTo = function(x2, y2) {
        this.startPoly();
        this.currentPath.points[0] = x2;
        this.currentPath.points[1] = y2;
        return this;
      };
      Graphics5.prototype.lineTo = function(x2, y2) {
        if (!this.currentPath) {
          this.moveTo(0, 0);
        }
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y2) {
          points.push(x2, y2);
        }
        return this;
      };
      Graphics5.prototype._initCurve = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (this.currentPath) {
          if (this.currentPath.points.length === 0) {
            this.currentPath.points = [x2, y2];
          }
        } else {
          this.moveTo(x2, y2);
        }
      };
      Graphics5.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
      };
      Graphics5.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
      };
      Graphics5.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
          var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
          this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
        }
        return this;
      };
      Graphics5.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) {
          anticlockwise = false;
        }
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += math.PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += math.PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
          return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var eps = this._geometry.closePointEps;
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          var xDiff = Math.abs(points[points.length - 2] - startX);
          var yDiff = Math.abs(points[points.length - 1] - startY);
          if (xDiff < eps && yDiff < eps)
            ;
          else {
            points.push(startX, startY);
          }
        } else {
          this.moveTo(startX, startY);
          points = this.currentPath.points;
        }
        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
      };
      Graphics5.prototype.beginFill = function(color, alpha) {
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        return this.beginTextureFill({texture: core.Texture.WHITE, color, alpha});
      };
      Graphics5.prototype.beginTextureFill = function(options) {
        options = Object.assign({
          texture: core.Texture.WHITE,
          color: 16777215,
          alpha: 1,
          matrix: null
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.alpha > 0;
        if (!visible) {
          this._fillStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._fillStyle, {visible}, options);
        }
        return this;
      };
      Graphics5.prototype.endFill = function() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
      };
      Graphics5.prototype.drawRect = function(x2, y2, width, height) {
        return this.drawShape(new math.Rectangle(x2, y2, width, height));
      };
      Graphics5.prototype.drawRoundedRect = function(x2, y2, width, height, radius) {
        return this.drawShape(new math.RoundedRectangle(x2, y2, width, height, radius));
      };
      Graphics5.prototype.drawCircle = function(x2, y2, radius) {
        return this.drawShape(new math.Circle(x2, y2, radius));
      };
      Graphics5.prototype.drawEllipse = function(x2, y2, width, height) {
        return this.drawShape(new math.Ellipse(x2, y2, width, height));
      };
      Graphics5.prototype.drawPolygon = function() {
        var arguments$1 = arguments;
        var path = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          path[_i] = arguments$1[_i];
        }
        var points;
        var closeStroke = true;
        var poly = path[0];
        if (poly.points) {
          closeStroke = poly.closeStroke;
          points = poly.points;
        } else if (Array.isArray(path[0])) {
          points = path[0];
        } else {
          points = path;
        }
        var shape = new math.Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
      };
      Graphics5.prototype.drawShape = function(shape) {
        if (!this._holeMode) {
          this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        } else {
          this._geometry.drawHole(shape, this._matrix);
        }
        return this;
      };
      Graphics5.prototype.clear = function() {
        this._geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();
        this._boundsID++;
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        return this;
      };
      Graphics5.prototype.isFastRect = function() {
        var data = this._geometry.graphicsData;
        return data.length === 1 && data[0].shape.type === math.SHAPES.RECT && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      };
      Graphics5.prototype._render = function(renderer) {
        this.finishPoly();
        var geometry = this._geometry;
        var hasuint32 = renderer.context.supports.uint32Indices;
        geometry.updateBatches(hasuint32);
        if (geometry.batchable) {
          if (this.batchDirty !== geometry.batchDirty) {
            this._populateBatches();
          }
          this._renderBatched(renderer);
        } else {
          renderer.batch.flush();
          this._renderDirect(renderer);
        }
      };
      Graphics5.prototype._populateBatches = function() {
        var geometry = this._geometry;
        var blendMode = this.blendMode;
        var len = geometry.batches.length;
        this.batchTint = -1;
        this._transformID = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (var i2 = 0; i2 < len; i2++) {
          var gI = geometry.batches[i2];
          var color = gI.style.color;
          var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
          var batch = {
            vertexData,
            blendMode,
            indices,
            uvs,
            _batchRGB: utils6.hex2rgb(color),
            _tintRGB: color,
            _texture: gI.style.texture,
            alpha: gI.style.alpha,
            worldAlpha: 1
          };
          this.batches[i2] = batch;
        }
      };
      Graphics5.prototype._renderBatched = function(renderer) {
        if (!this.batches.length) {
          return;
        }
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        this.calculateVertices();
        this.calculateTints();
        for (var i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
          var batch = this.batches[i2];
          batch.worldAlpha = this.worldAlpha * batch.alpha;
          renderer.plugins[this.pluginName].render(batch);
        }
      };
      Graphics5.prototype._renderDirect = function(renderer) {
        var shader = this._resolveDirectShader(renderer);
        var geometry = this._geometry;
        var tint = this.tint;
        var worldAlpha = this.worldAlpha;
        var uniforms = shader.uniforms;
        var drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
        uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
        uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
        uniforms.tint[3] = worldAlpha;
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (var i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
        }
      };
      Graphics5.prototype._renderDrawCallDirect = function(renderer, drawCall) {
        var texArray = drawCall.texArray, type2 = drawCall.type, size = drawCall.size, start = drawCall.start;
        var groupTextureCount = texArray.count;
        for (var j2 = 0; j2 < groupTextureCount; j2++) {
          renderer.texture.bind(texArray.elements[j2], j2);
        }
        renderer.geometry.draw(type2, size, start);
      };
      Graphics5.prototype._resolveDirectShader = function(renderer) {
        var shader = this.shader;
        var pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;
            var sampleValues = new Int32Array(MAX_TEXTURES);
            for (var i2 = 0; i2 < MAX_TEXTURES; i2++) {
              sampleValues[i2] = i2;
            }
            var uniforms = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new math.Matrix(),
              default: core.UniformGroup.from({uSamplers: sampleValues}, true)
            };
            var program = renderer.plugins[pluginName]._shader.program;
            DEFAULT_SHADERS[pluginName] = new core.Shader(program, uniforms);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      };
      Graphics5.prototype._calculateBounds = function() {
        this.finishPoly();
        var geometry = this._geometry;
        if (!geometry.graphicsData.length) {
          return;
        }
        var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      Graphics5.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, Graphics5._TEMP_POINT);
        return this._geometry.containsPoint(Graphics5._TEMP_POINT);
      };
      Graphics5.prototype.calculateTints = function() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this.tint;
          var tintRGB = utils6.hex2rgb(this.tint, temp);
          for (var i2 = 0; i2 < this.batches.length; i2++) {
            var batch = this.batches[i2];
            var batchTint = batch._batchRGB;
            var r2 = tintRGB[0] * batchTint[0] * 255;
            var g2 = tintRGB[1] * batchTint[1] * 255;
            var b2 = tintRGB[2] * batchTint[2] * 255;
            var color = (r2 << 16) + (g2 << 8) + (b2 | 0);
            batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
          }
        }
      };
      Graphics5.prototype.calculateVertices = function() {
        var wtID = this.transform._worldID;
        if (this._transformID === wtID) {
          return;
        }
        this._transformID = wtID;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b2 = wt.b;
        var c2 = wt.c;
        var d2 = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this._geometry.points;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i2 = 0; i2 < data.length; i2 += 2) {
          var x2 = data[i2];
          var y2 = data[i2 + 1];
          vertexData[count++] = a2 * x2 + c2 * y2 + tx;
          vertexData[count++] = d2 * y2 + b2 * x2 + ty;
        }
      };
      Graphics5.prototype.closePath = function() {
        var currentPath = this.currentPath;
        if (currentPath) {
          currentPath.closeStroke = true;
        }
        return this;
      };
      Graphics5.prototype.setMatrix = function(matrix) {
        this._matrix = matrix;
        return this;
      };
      Graphics5.prototype.beginHole = function() {
        this.finishPoly();
        this._holeMode = true;
        return this;
      };
      Graphics5.prototype.endHole = function() {
        this.finishPoly();
        this._holeMode = false;
        return this;
      };
      Graphics5.prototype.destroy = function(options) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this._geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        _super.prototype.destroy.call(this, options);
      };
      Graphics5._TEMP_POINT = new math.Point();
      return Graphics5;
    }(display.Container);
    var graphicsUtils = {
      buildPoly,
      buildCircle,
      buildRectangle,
      buildRoundedRectangle,
      buildLine,
      ArcUtils,
      BezierUtils,
      QuadraticUtils,
      BatchPart,
      FILL_COMMANDS,
      BATCH_POOL,
      DRAW_CALL_POOL
    };
    exports.FillStyle = FillStyle;
    exports.GRAPHICS_CURVES = GRAPHICS_CURVES;
    exports.Graphics = Graphics4;
    exports.GraphicsData = GraphicsData;
    exports.GraphicsGeometry = GraphicsGeometry;
    exports.LineStyle = LineStyle;
    exports.graphicsUtils = graphicsUtils;
  });

  // node_modules/@pixi/sprite/dist/cjs/sprite.js
  var require_sprite = __commonJS((exports) => {
    /*!
     * @pixi/sprite - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/sprite is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var constants = require_constants();
    var core = require_core();
    var display = require_display();
    var math = require_math();
    var settings2 = require_settings();
    var utils6 = require_utils();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var tempPoint = new math.Point();
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var Sprite3 = function(_super) {
      __extends(Sprite4, _super);
      function Sprite4(texture) {
        var _this = _super.call(this) || this;
        _this._anchor = new math.ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
        _this._texture = null;
        _this._width = 0;
        _this._height = 0;
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 16777215;
        _this.blendMode = constants.BLEND_MODES.NORMAL;
        _this._cachedTint = 16777215;
        _this.uvs = null;
        _this.texture = texture || core.Texture.EMPTY;
        _this.vertexData = new Float32Array(8);
        _this.vertexTrimmedData = null;
        _this._transformID = -1;
        _this._textureID = -1;
        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;
        _this.indices = indices;
        _this.pluginName = "batch";
        _this.isSprite = true;
        _this._roundPixels = settings2.settings.ROUND_PIXELS;
        return _this;
      }
      Sprite4.prototype._onTextureUpdate = function() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        if (this._width) {
          this.scale.x = utils6.sign(this.scale.x) * this._width / this._texture.orig.width;
        }
        if (this._height) {
          this.scale.y = utils6.sign(this.scale.y) * this._height / this._texture.orig.height;
        }
      };
      Sprite4.prototype._onAnchorUpdate = function() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
      };
      Sprite4.prototype.calculateVertices = function() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
          return;
        }
        if (this._textureID !== texture._updateID) {
          this.uvs = this._texture._uvs.uvsFloat32;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b2 = wt.b;
        var c2 = wt.c;
        var d2 = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
          w1 = trim.x - anchor._x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - anchor._y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w1 = -anchor._x * orig.width;
          w0 = w1 + orig.width;
          h1 = -anchor._y * orig.height;
          h0 = h1 + orig.height;
        }
        vertexData[0] = a2 * w1 + c2 * h1 + tx;
        vertexData[1] = d2 * h1 + b2 * w1 + ty;
        vertexData[2] = a2 * w0 + c2 * h1 + tx;
        vertexData[3] = d2 * h1 + b2 * w0 + ty;
        vertexData[4] = a2 * w0 + c2 * h0 + tx;
        vertexData[5] = d2 * h0 + b2 * w0 + ty;
        vertexData[6] = a2 * w1 + c2 * h0 + tx;
        vertexData[7] = d2 * h0 + b2 * w1 + ty;
        if (this._roundPixels) {
          var resolution = settings2.settings.RESOLUTION;
          for (var i2 = 0; i2 < vertexData.length; ++i2) {
            vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
          }
        }
      };
      Sprite4.prototype.calculateTrimmedVertices = function() {
        if (!this.vertexTrimmedData) {
          this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
          return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b2 = wt.b;
        var c2 = wt.c;
        var d2 = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        vertexData[0] = a2 * w1 + c2 * h1 + tx;
        vertexData[1] = d2 * h1 + b2 * w1 + ty;
        vertexData[2] = a2 * w0 + c2 * h1 + tx;
        vertexData[3] = d2 * h1 + b2 * w0 + ty;
        vertexData[4] = a2 * w0 + c2 * h0 + tx;
        vertexData[5] = d2 * h0 + b2 * w0 + ty;
        vertexData[6] = a2 * w1 + c2 * h0 + tx;
        vertexData[7] = d2 * h0 + b2 * w1 + ty;
      };
      Sprite4.prototype._render = function(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      Sprite4.prototype._calculateBounds = function() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        if (!trim || trim.width === orig.width && trim.height === orig.height) {
          this.calculateVertices();
          this._bounds.addQuad(this.vertexData);
        } else {
          this.calculateTrimmedVertices();
          this._bounds.addQuad(this.vertexTrimmedData);
        }
      };
      Sprite4.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._texture.orig.width * -this._anchor._x;
          this._bounds.minY = this._texture.orig.height * -this._anchor._y;
          this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
          this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new math.Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Sprite4.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      Sprite4.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this._texture.off("update", this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
        if (destroyTexture) {
          var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
          this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
      };
      Sprite4.from = function(source, options) {
        var texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
        return new Sprite4(texture);
      };
      Object.defineProperty(Sprite4.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value) {
          if (this._roundPixels !== value) {
            this._transformID = -1;
          }
          this._roundPixels = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite4.prototype, "width", {
        get: function() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value) {
          var s3 = utils6.sign(this.scale.x) || 1;
          this.scale.x = s3 * value / this._texture.orig.width;
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite4.prototype, "height", {
        get: function() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value) {
          var s3 = utils6.sign(this.scale.y) || 1;
          this.scale.y = s3 * value / this._texture.orig.height;
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite4.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value) {
          this._anchor.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite4.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value) {
          this._tint = value;
          this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite4.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value) {
          if (this._texture === value) {
            return;
          }
          if (this._texture) {
            this._texture.off("update", this._onTextureUpdate, this);
          }
          this._texture = value || core.Texture.EMPTY;
          this._cachedTint = 16777215;
          this._textureID = -1;
          this._textureTrimmedID = -1;
          if (value) {
            if (value.baseTexture.valid) {
              this._onTextureUpdate();
            } else {
              value.once("update", this._onTextureUpdate, this);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return Sprite4;
    }(display.Container);
    exports.Sprite = Sprite3;
  });

  // node_modules/@pixi/text/dist/cjs/text.js
  var require_text = __commonJS((exports) => {
    /*!
     * @pixi/text - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/text is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var sprite = require_sprite();
    var core = require_core();
    var settings2 = require_settings();
    var math = require_math();
    var utils6 = require_utils();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    (function(TEXT_GRADIENT) {
      TEXT_GRADIENT[TEXT_GRADIENT["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
      TEXT_GRADIENT[TEXT_GRADIENT["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
    })(exports.TEXT_GRADIENT || (exports.TEXT_GRADIENT = {}));
    var defaultStyle = {
      align: "left",
      breakWords: false,
      dropShadow: false,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fillGradientType: exports.TEXT_GRADIENT.LINEAR_VERTICAL,
      fillGradientStops: [],
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      letterSpacing: 0,
      lineHeight: 0,
      lineJoin: "miter",
      miterLimit: 10,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      textBaseline: "alphabetic",
      trim: false,
      whiteSpace: "pre",
      wordWrap: false,
      wordWrapWidth: 100,
      leading: 0
    };
    var genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
    var TextStyle = function() {
      function TextStyle2(style) {
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
      }
      TextStyle2.prototype.clone = function() {
        var clonedProperties = {};
        deepCopyProperties(clonedProperties, this, defaultStyle);
        return new TextStyle2(clonedProperties);
      };
      TextStyle2.prototype.reset = function() {
        deepCopyProperties(this, defaultStyle, defaultStyle);
      };
      Object.defineProperty(TextStyle2.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(align) {
          if (this._align !== align) {
            this._align = align;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "breakWords", {
        get: function() {
          return this._breakWords;
        },
        set: function(breakWords) {
          if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadow", {
        get: function() {
          return this._dropShadow;
        },
        set: function(dropShadow) {
          if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
        get: function() {
          return this._dropShadowAlpha;
        },
        set: function(dropShadowAlpha) {
          if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
        get: function() {
          return this._dropShadowAngle;
        },
        set: function(dropShadowAngle) {
          if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
        get: function() {
          return this._dropShadowBlur;
        },
        set: function(dropShadowBlur) {
          if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
        get: function() {
          return this._dropShadowColor;
        },
        set: function(dropShadowColor) {
          var outputColor = getColor(dropShadowColor);
          if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
        get: function() {
          return this._dropShadowDistance;
        },
        set: function(dropShadowDistance) {
          if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fill", {
        get: function() {
          return this._fill;
        },
        set: function(fill) {
          var outputColor = getColor(fill);
          if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
        get: function() {
          return this._fillGradientType;
        },
        set: function(fillGradientType) {
          if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
        get: function() {
          return this._fillGradientStops;
        },
        set: function(fillGradientStops) {
          if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontFamily", {
        get: function() {
          return this._fontFamily;
        },
        set: function(fontFamily) {
          if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(fontSize) {
          if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontStyle", {
        get: function() {
          return this._fontStyle;
        },
        set: function(fontStyle) {
          if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontVariant", {
        get: function() {
          return this._fontVariant;
        },
        set: function(fontVariant) {
          if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontWeight", {
        get: function() {
          return this._fontWeight;
        },
        set: function(fontWeight) {
          if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(letterSpacing) {
          if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineHeight", {
        get: function() {
          return this._lineHeight;
        },
        set: function(lineHeight) {
          if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "leading", {
        get: function() {
          return this._leading;
        },
        set: function(leading) {
          if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineJoin", {
        get: function() {
          return this._lineJoin;
        },
        set: function(lineJoin) {
          if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "miterLimit", {
        get: function() {
          return this._miterLimit;
        },
        set: function(miterLimit) {
          if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "padding", {
        get: function() {
          return this._padding;
        },
        set: function(padding) {
          if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "stroke", {
        get: function() {
          return this._stroke;
        },
        set: function(stroke) {
          var outputColor = getColor(stroke);
          if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
        get: function() {
          return this._strokeThickness;
        },
        set: function(strokeThickness) {
          if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "textBaseline", {
        get: function() {
          return this._textBaseline;
        },
        set: function(textBaseline) {
          if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "trim", {
        get: function() {
          return this._trim;
        },
        set: function(trim) {
          if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
        get: function() {
          return this._whiteSpace;
        },
        set: function(whiteSpace) {
          if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrap", {
        get: function() {
          return this._wordWrap;
        },
        set: function(wordWrap) {
          if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
        get: function() {
          return this._wordWrapWidth;
        },
        set: function(wordWrapWidth) {
          if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      TextStyle2.prototype.toFontString = function() {
        var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
          fontFamilies = this.fontFamily.split(",");
        }
        for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
          var fontFamily = fontFamilies[i2].trim();
          if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
            fontFamily = '"' + fontFamily + '"';
          }
          fontFamilies[i2] = fontFamily;
        }
        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
      };
      return TextStyle2;
    }();
    function getSingleColor(color) {
      if (typeof color === "number") {
        return utils6.hex2string(color);
      } else if (typeof color === "string") {
        if (color.indexOf("0x") === 0) {
          color = color.replace("0x", "#");
        }
      }
      return color;
    }
    function getColor(color) {
      if (!Array.isArray(color)) {
        return getSingleColor(color);
      } else {
        for (var i2 = 0; i2 < color.length; ++i2) {
          color[i2] = getSingleColor(color[i2]);
        }
        return color;
      }
    }
    function areArraysEqual(array1, array2) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (var i2 = 0; i2 < array1.length; ++i2) {
        if (array1[i2] !== array2[i2]) {
          return false;
        }
      }
      return true;
    }
    function deepCopyProperties(target, source, propertyObj) {
      for (var prop in propertyObj) {
        if (Array.isArray(source[prop])) {
          target[prop] = source[prop].slice();
        } else {
          target[prop] = source[prop];
        }
      }
    }
    var TextMetrics = function() {
      function TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      TextMetrics2.measureText = function(text, style, wordWrap, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        var context = canvas2.getContext("2d");
        context.font = font;
        var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas2) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var lineWidth = context.measureText(lines[i2]).width + (lines[i2].length - 1) * style.letterSpacing;
          lineWidths[i2] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadowDistance;
        }
        return new TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      };
      TextMetrics2.wordWrap = function(text, style, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        var context = canvas2.getContext("2d");
        var width = 0;
        var line = "";
        var lines = "";
        var cache2 = Object.create(null);
        var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
        var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
        var canPrependSpaces = !collapseSpaces;
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        var tokens = TextMetrics2.tokenize(text);
        for (var i2 = 0; i2 < tokens.length; i2++) {
          var token = tokens[i2];
          if (TextMetrics2.isNewline(token)) {
            if (!collapseNewlines) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
            var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache2, context);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += TextMetrics2.addLine(line);
              line = "";
              width = 0;
            }
            if (TextMetrics2.canBreakWords(token, style.breakWords)) {
              var characters = TextMetrics2.wordWrapSplit(token);
              for (var j2 = 0; j2 < characters.length; j2++) {
                var char = characters[j2];
                var k2 = 1;
                while (characters[j2 + k2]) {
                  var nextChar = characters[j2 + k2];
                  var lastChar = char[char.length - 1];
                  if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  k2++;
                }
                j2 += char.length - 1;
                var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache2, context);
                if (characterWidth + width > wordWrapWidth) {
                  lines += TextMetrics2.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += TextMetrics2.addLine(line);
                line = "";
                width = 0;
              }
              var isLastToken = i2 === tokens.length - 1;
              lines += TextMetrics2.addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += TextMetrics2.addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += TextMetrics2.addLine(line, false);
        return lines;
      };
      TextMetrics2.addLine = function(line, newLine) {
        if (newLine === void 0) {
          newLine = true;
        }
        line = TextMetrics2.trimRight(line);
        line = newLine ? line + "\n" : line;
        return line;
      };
      TextMetrics2.getFromCache = function(key, letterSpacing, cache2, context) {
        var width = cache2[key];
        if (typeof width !== "number") {
          var spacing = key.length * letterSpacing;
          width = context.measureText(key).width + spacing;
          cache2[key] = width;
        }
        return width;
      };
      TextMetrics2.collapseSpaces = function(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      };
      TextMetrics2.collapseNewlines = function(whiteSpace) {
        return whiteSpace === "normal";
      };
      TextMetrics2.trimRight = function(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (var i2 = text.length - 1; i2 >= 0; i2--) {
          var char = text[i2];
          if (!TextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      };
      TextMetrics2.isNewline = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.isBreakingSpace = function(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.tokenize = function(text) {
        var tokens = [];
        var token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (var i2 = 0; i2 < text.length; i2++) {
          var char = text[i2];
          var nextChar = text[i2 + 1];
          if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      };
      TextMetrics2.canBreakWords = function(_token, breakWords) {
        return breakWords;
      };
      TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      };
      TextMetrics2.wordWrapSplit = function(token) {
        return token.split("");
      };
      TextMetrics2.measureFont = function(font) {
        if (TextMetrics2._fonts[font]) {
          return TextMetrics2._fonts[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas2 = TextMetrics2._canvas;
        var context = TextMetrics2._context;
        context.font = font;
        var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics2.BASELINE_SYMBOL).width);
        var height = TextMetrics2.HEIGHT_MULTIPLIER * baseline;
        baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
        canvas2.width = width;
        canvas2.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i2 = 0;
        var idx = 0;
        var stop = false;
        for (i2 = 0; i2 < baseline; ++i2) {
          for (var j2 = 0; j2 < line; j2 += 4) {
            if (imagedata[idx + j2] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i2;
        idx = pixels - line;
        stop = false;
        for (i2 = height; i2 > baseline; --i2) {
          for (var j2 = 0; j2 < line; j2 += 4) {
            if (imagedata[idx + j2] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        properties.descent = i2 - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics2._fonts[font] = properties;
        return properties;
      };
      TextMetrics2.clearMetrics = function(font) {
        if (font === void 0) {
          font = "";
        }
        if (font) {
          delete TextMetrics2._fonts[font];
        } else {
          TextMetrics2._fonts = {};
        }
      };
      return TextMetrics2;
    }();
    var canvas = function() {
      try {
        var c2 = new OffscreenCanvas(0, 0);
        var context = c2.getContext("2d");
        if (context && context.measureText) {
          return c2;
        }
        return document.createElement("canvas");
      } catch (ex) {
        return document.createElement("canvas");
      }
    }();
    canvas.width = canvas.height = 10;
    TextMetrics._canvas = canvas;
    TextMetrics._context = canvas.getContext("2d");
    TextMetrics._fonts = {};
    TextMetrics.METRICS_STRING = "|\xC9q\xC5";
    TextMetrics.BASELINE_SYMBOL = "M";
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics.HEIGHT_MULTIPLIER = 2;
    TextMetrics._newlines = [
      10,
      13
    ];
    TextMetrics._breakingSpaces = [
      9,
      32,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8200,
      8201,
      8202,
      8287,
      12288
    ];
    var defaultDestroyOptions = {
      texture: true,
      children: false,
      baseTexture: true
    };
    var Text5 = function(_super) {
      __extends(Text6, _super);
      function Text6(text, style, canvas2) {
        var _this = this;
        var ownCanvas = false;
        if (!canvas2) {
          canvas2 = document.createElement("canvas");
          ownCanvas = true;
        }
        canvas2.width = 3;
        canvas2.height = 3;
        var texture = core.Texture.from(canvas2);
        texture.orig = new math.Rectangle();
        texture.trim = new math.Rectangle();
        _this = _super.call(this, texture) || this;
        _this._ownCanvas = ownCanvas;
        _this.canvas = canvas2;
        _this.context = _this.canvas.getContext("2d");
        _this._resolution = settings2.settings.RESOLUTION;
        _this._autoResolution = true;
        _this._text = null;
        _this._style = null;
        _this._styleListener = null;
        _this._font = "";
        _this.text = text;
        _this.style = style;
        _this.localStyleID = -1;
        return _this;
      }
      Text6.prototype.updateText = function(respectDirty) {
        var style = this._style;
        if (this.localStyleID !== style.styleID) {
          this.dirty = true;
          this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
          return;
        }
        this._font = this._style.toFontString();
        var context = this.context;
        var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width) + style.padding * 2) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + style.padding * 2) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        var passesCount = style.dropShadow ? 2 : 1;
        for (var i2 = 0; i2 < passesCount; ++i2) {
          var isShadowPass = style.dropShadow && i2 === 0;
          var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          var dsOffsetShadow = dsOffsetText * this._resolution;
          if (isShadowPass) {
            context.fillStyle = "black";
            context.strokeStyle = "black";
            var dropShadowColor = style.dropShadowColor;
            var rgb = utils6.hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : utils6.string2hex(dropShadowColor));
            context.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
            context.shadowBlur = style.dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance + dsOffsetShadow;
          } else {
            context.fillStyle = this._generateFillStyle(style, lines, measured);
            context.strokeStyle = style.stroke;
            context.shadowColor = "black";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
          }
          for (var i_1 = 0; i_1 < lines.length; i_1++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i_1];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
            }
            if (style.fill) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
        }
        this.updateTexture();
      };
      Text6.prototype.drawLetterSpacing = function(text, x2, y2, isStroke) {
        if (isStroke === void 0) {
          isStroke = false;
        }
        var style = this._style;
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
          if (isStroke) {
            this.context.strokeText(text, x2, y2);
          } else {
            this.context.fillText(text, x2, y2);
          }
          return;
        }
        var currentPosition = x2;
        var stringArray = Array.from ? Array.from(text) : text.split("");
        var previousWidth = this.context.measureText(text).width;
        var currentWidth = 0;
        for (var i2 = 0; i2 < stringArray.length; ++i2) {
          var currentChar = stringArray[i2];
          if (isStroke) {
            this.context.strokeText(currentChar, currentPosition, y2);
          } else {
            this.context.fillText(currentChar, currentPosition, y2);
          }
          currentWidth = this.context.measureText(text.substring(i2 + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      };
      Text6.prototype.updateTexture = function() {
        var canvas2 = this.canvas;
        if (this._style.trim) {
          var trimmed = utils6.trimCanvas(canvas2);
          if (trimmed.data) {
            canvas2.width = trimmed.width;
            canvas2.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
          }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = Math.ceil(canvas2.width / this._resolution);
        texture.trim.height = texture._frame.height = Math.ceil(canvas2.height / this._resolution);
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas2.width, canvas2.height, this._resolution);
        this._recursivePostUpdateTransform();
        this.dirty = false;
      };
      Text6.prototype._render = function(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        this.updateText(true);
        _super.prototype._render.call(this, renderer);
      };
      Text6.prototype.getLocalBounds = function(rect) {
        this.updateText(true);
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Text6.prototype._calculateBounds = function() {
        this.updateText(true);
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      };
      Text6.prototype._generateFillStyle = function(style, lines, metrics) {
        var fillStyle = style.fill;
        if (!Array.isArray(fillStyle)) {
          return fillStyle;
        } else if (fillStyle.length === 1) {
          return fillStyle[0];
        }
        var gradient;
        var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
        var padding = style.padding || 0;
        var width = Math.ceil(this.canvas.width / this._resolution) - dropShadowCorrection - padding * 2;
        var height = Math.ceil(this.canvas.height / this._resolution) - dropShadowCorrection - padding * 2;
        var fill = fillStyle.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          var lengthPlus1 = fill.length + 1;
          for (var i2 = 1; i2 < lengthPlus1; ++i2) {
            fillGradientStops.push(i2 / lengthPlus1);
          }
        }
        fill.unshift(fillStyle[0]);
        fillGradientStops.unshift(0);
        fill.push(fillStyle[fillStyle.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === exports.TEXT_GRADIENT.LINEAR_VERTICAL) {
          gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
          var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          var gradStopLineHeight = textHeight / height;
          for (var i2 = 0; i2 < lines.length; i2++) {
            var thisLineTop = metrics.lineHeight * i2;
            for (var j2 = 0; j2 < fill.length; j2++) {
              var lineStop = 0;
              if (typeof fillGradientStops[j2] === "number") {
                lineStop = fillGradientStops[j2];
              } else {
                lineStop = j2 / fill.length;
              }
              var globalStop = Math.min(1, Math.max(0, thisLineTop / height + lineStop * gradStopLineHeight));
              globalStop = Number(globalStop.toFixed(5));
              gradient.addColorStop(globalStop, fill[j2]);
            }
          }
        } else {
          gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
          var totalIterations = fill.length + 1;
          var currentIteration = 1;
          for (var i2 = 0; i2 < fill.length; i2++) {
            var stop = void 0;
            if (typeof fillGradientStops[i2] === "number") {
              stop = fillGradientStops[i2];
            } else {
              stop = currentIteration / totalIterations;
            }
            gradient.addColorStop(stop, fill[i2]);
            currentIteration++;
          }
        }
        return gradient;
      };
      Text6.prototype.destroy = function(options) {
        if (typeof options === "boolean") {
          options = {children: options};
        }
        options = Object.assign({}, defaultDestroyOptions, options);
        _super.prototype.destroy.call(this, options);
        if (this._ownCanvas) {
          this.canvas.height = this.canvas.width = 0;
        }
        this.context = null;
        this.canvas = null;
        this._style = null;
      };
      Object.defineProperty(Text6.prototype, "width", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value) {
          this.updateText(true);
          var s3 = utils6.sign(this.scale.x) || 1;
          this.scale.x = s3 * value / this._texture.orig.width;
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text6.prototype, "height", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value) {
          this.updateText(true);
          var s3 = utils6.sign(this.scale.y) || 1;
          this.scale.y = s3 * value / this._texture.orig.height;
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text6.prototype, "style", {
        get: function() {
          return this._style;
        },
        set: function(style) {
          style = style || {};
          if (style instanceof TextStyle) {
            this._style = style;
          } else {
            this._style = new TextStyle(style);
          }
          this.localStyleID = -1;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text6.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text6.prototype, "resolution", {
        get: function() {
          return this._resolution;
        },
        set: function(value) {
          this._autoResolution = false;
          if (this._resolution === value) {
            return;
          }
          this._resolution = value;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      return Text6;
    }(sprite.Sprite);
    exports.Text = Text5;
    exports.TextMetrics = TextMetrics;
    exports.TextStyle = TextStyle;
  });

  // node_modules/@pixi/prepare/dist/cjs/prepare.js
  var require_prepare = __commonJS((exports) => {
    /*!
     * @pixi/prepare - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/prepare is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var settings2 = require_settings();
    var core = require_core();
    var graphics = require_graphics();
    var ticker = require_ticker();
    var display = require_display();
    var text = require_text();
    settings2.settings.UPLOADS_PER_FRAME = 4;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var CountLimiter = function() {
      function CountLimiter2(maxItemsPerFrame) {
        this.maxItemsPerFrame = maxItemsPerFrame;
        this.itemsLeft = 0;
      }
      CountLimiter2.prototype.beginFrame = function() {
        this.itemsLeft = this.maxItemsPerFrame;
      };
      CountLimiter2.prototype.allowedToUpload = function() {
        return this.itemsLeft-- > 0;
      };
      return CountLimiter2;
    }();
    function findMultipleBaseTextures(item, queue) {
      var result = false;
      if (item && item._textures && item._textures.length) {
        for (var i2 = 0; i2 < item._textures.length; i2++) {
          if (item._textures[i2] instanceof core.Texture) {
            var baseTexture = item._textures[i2].baseTexture;
            if (queue.indexOf(baseTexture) === -1) {
              queue.push(baseTexture);
              result = true;
            }
          }
        }
      }
      return result;
    }
    function findBaseTexture(item, queue) {
      if (item.baseTexture instanceof core.BaseTexture) {
        var texture = item.baseTexture;
        if (queue.indexOf(texture) === -1) {
          queue.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTexture(item, queue) {
      if (item._texture && item._texture instanceof core.Texture) {
        var texture = item._texture.baseTexture;
        if (queue.indexOf(texture) === -1) {
          queue.push(texture);
        }
        return true;
      }
      return false;
    }
    function drawText(_helper, item) {
      if (item instanceof text.Text) {
        item.updateText(true);
        return true;
      }
      return false;
    }
    function calculateTextStyle(_helper, item) {
      if (item instanceof text.TextStyle) {
        var font = item.toFontString();
        text.TextMetrics.measureFont(font);
        return true;
      }
      return false;
    }
    function findText(item, queue) {
      if (item instanceof text.Text) {
        if (queue.indexOf(item.style) === -1) {
          queue.push(item.style);
        }
        if (queue.indexOf(item) === -1) {
          queue.push(item);
        }
        var texture = item._texture.baseTexture;
        if (queue.indexOf(texture) === -1) {
          queue.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTextStyle(item, queue) {
      if (item instanceof text.TextStyle) {
        if (queue.indexOf(item) === -1) {
          queue.push(item);
        }
        return true;
      }
      return false;
    }
    var BasePrepare = function() {
      function BasePrepare2(renderer) {
        var _this = this;
        this.limiter = new CountLimiter(settings2.settings.UPLOADS_PER_FRAME);
        this.renderer = renderer;
        this.uploadHookHelper = null;
        this.queue = [];
        this.addHooks = [];
        this.uploadHooks = [];
        this.completes = [];
        this.ticking = false;
        this.delayedTick = function() {
          if (!_this.queue) {
            return;
          }
          _this.prepareItems();
        };
        this.registerFindHook(findText);
        this.registerFindHook(findTextStyle);
        this.registerFindHook(findMultipleBaseTextures);
        this.registerFindHook(findBaseTexture);
        this.registerFindHook(findTexture);
        this.registerUploadHook(drawText);
        this.registerUploadHook(calculateTextStyle);
      }
      BasePrepare2.prototype.upload = function(item, done) {
        if (typeof item === "function") {
          done = item;
          item = null;
        }
        if (item) {
          this.add(item);
        }
        if (this.queue.length) {
          if (done) {
            this.completes.push(done);
          }
          if (!this.ticking) {
            this.ticking = true;
            ticker.Ticker.system.addOnce(this.tick, this, ticker.UPDATE_PRIORITY.UTILITY);
          }
        } else if (done) {
          done();
        }
      };
      BasePrepare2.prototype.tick = function() {
        setTimeout(this.delayedTick, 0);
      };
      BasePrepare2.prototype.prepareItems = function() {
        this.limiter.beginFrame();
        while (this.queue.length && this.limiter.allowedToUpload()) {
          var item = this.queue[0];
          var uploaded = false;
          if (item && !item._destroyed) {
            for (var i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
              if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
                this.queue.shift();
                uploaded = true;
                break;
              }
            }
          }
          if (!uploaded) {
            this.queue.shift();
          }
        }
        if (!this.queue.length) {
          this.ticking = false;
          var completes = this.completes.slice(0);
          this.completes.length = 0;
          for (var i2 = 0, len = completes.length; i2 < len; i2++) {
            completes[i2]();
          }
        } else {
          ticker.Ticker.system.addOnce(this.tick, this, ticker.UPDATE_PRIORITY.UTILITY);
        }
      };
      BasePrepare2.prototype.registerFindHook = function(addHook) {
        if (addHook) {
          this.addHooks.push(addHook);
        }
        return this;
      };
      BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
        if (uploadHook) {
          this.uploadHooks.push(uploadHook);
        }
        return this;
      };
      BasePrepare2.prototype.add = function(item) {
        for (var i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
          if (this.addHooks[i2](item, this.queue)) {
            break;
          }
        }
        if (item instanceof display.Container) {
          for (var i2 = item.children.length - 1; i2 >= 0; i2--) {
            this.add(item.children[i2]);
          }
        }
        return this;
      };
      BasePrepare2.prototype.destroy = function() {
        if (this.ticking) {
          ticker.Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
      };
      return BasePrepare2;
    }();
    function uploadBaseTextures(renderer, item) {
      if (item instanceof core.BaseTexture) {
        if (!item._glTextures[renderer.CONTEXT_UID]) {
          renderer.texture.bind(item);
        }
        return true;
      }
      return false;
    }
    function uploadGraphics(renderer, item) {
      if (!(item instanceof graphics.Graphics)) {
        return false;
      }
      var geometry = item.geometry;
      item.finishPoly();
      geometry.updateBatches();
      var batches = geometry.batches;
      for (var i2 = 0; i2 < batches.length; i2++) {
        var texture = batches[i2].style.texture;
        if (texture) {
          uploadBaseTextures(renderer, texture.baseTexture);
        }
      }
      if (!geometry.batchable) {
        renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
      }
      return true;
    }
    function findGraphics(item, queue) {
      if (item instanceof graphics.Graphics) {
        queue.push(item);
        return true;
      }
      return false;
    }
    var Prepare = function(_super) {
      __extends(Prepare2, _super);
      function Prepare2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.uploadHookHelper = _this.renderer;
        _this.registerFindHook(findGraphics);
        _this.registerUploadHook(uploadBaseTextures);
        _this.registerUploadHook(uploadGraphics);
        return _this;
      }
      return Prepare2;
    }(BasePrepare);
    var TimeLimiter = function() {
      function TimeLimiter2(maxMilliseconds) {
        this.maxMilliseconds = maxMilliseconds;
        this.frameStart = 0;
      }
      TimeLimiter2.prototype.beginFrame = function() {
        this.frameStart = Date.now();
      };
      TimeLimiter2.prototype.allowedToUpload = function() {
        return Date.now() - this.frameStart < this.maxMilliseconds;
      };
      return TimeLimiter2;
    }();
    exports.BasePrepare = BasePrepare;
    exports.CountLimiter = CountLimiter;
    exports.Prepare = Prepare;
    exports.TimeLimiter = TimeLimiter;
  });

  // node_modules/@pixi/spritesheet/dist/cjs/spritesheet.js
  var require_spritesheet = __commonJS((exports) => {
    /*!
     * @pixi/spritesheet - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/spritesheet is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var math = require_math();
    var core = require_core();
    var utils6 = require_utils();
    var loaders = require_loaders();
    var Spritesheet = function() {
      function Spritesheet2(texture, data, resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        this._texture = texture instanceof core.Texture ? texture : null;
        this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;
        this.textures = {};
        this.animations = {};
        this.data = data;
        var resource = this.baseTexture.resource;
        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        var scale = this.data.meta.scale;
        var resolution = utils6.getResolutionOfUrl(resolutionFilename, null);
        if (resolution === null) {
          resolution = scale !== void 0 ? parseFloat(scale) : 1;
        }
        if (resolution !== 1) {
          this.baseTexture.setResolution(resolution);
        }
        return resolution;
      };
      Spritesheet2.prototype.parse = function(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      };
      Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          var i2 = this._frameKeys[frameIndex];
          var data = this._frames[i2];
          var rect = data.frame;
          if (rect) {
            var frame = null;
            var trim = null;
            var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            var orig = new math.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
            if (data.rotated) {
              frame = new math.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
            } else {
              frame = new math.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new math.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            this.textures[i2] = new core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
            core.Texture.addToCache(this.textures[i2], i2);
          }
          frameIndex++;
        }
      };
      Spritesheet2.prototype._processAnimations = function() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
          this.animations[animName] = [];
          for (var i2 = 0; i2 < animations[animName].length; i2++) {
            var frameName = animations[animName][i2];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      };
      Spritesheet2.prototype._parseComplete = function() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      };
      Spritesheet2.prototype._nextBatch = function() {
        var _this = this;
        this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function() {
          if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
            _this._nextBatch();
          } else {
            _this._processAnimations();
            _this._parseComplete();
          }
        }, 0);
      };
      Spritesheet2.prototype.destroy = function(destroyBase) {
        var _a;
        if (destroyBase === void 0) {
          destroyBase = false;
        }
        for (var i2 in this.textures) {
          this.textures[i2].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.destroy();
          this.baseTexture.destroy();
        }
        this._texture = null;
        this.baseTexture = null;
      };
      Spritesheet2.BATCH_SIZE = 1e3;
      return Spritesheet2;
    }();
    var SpritesheetLoader = function() {
      function SpritesheetLoader2() {
      }
      SpritesheetLoader2.use = function(resource, next) {
        var _a, _b;
        var loader = this;
        var imageResourceName = resource.name + "_image";
        if (!resource.data || resource.type !== loaders.LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
          next();
          return;
        }
        var multiPacks = (_b = (_a = resource.data) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.related_multi_packs;
        if (Array.isArray(multiPacks)) {
          var _loop_1 = function(item2) {
            if (typeof item2 !== "string") {
              return "continue";
            }
            var itemName = item2.replace(".json", "");
            var itemUrl = utils6.url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
            if (loader.resources[itemName] || Object.values(loader.resources).some(function(r2) {
              return utils6.url.format(utils6.url.parse(r2.url)) === itemUrl;
            })) {
              return "continue";
            }
            var options = {
              crossOrigin: resource.crossOrigin,
              loadType: loaders.LoaderResource.LOAD_TYPE.XHR,
              xhrType: loaders.LoaderResource.XHR_RESPONSE_TYPE.JSON,
              parentResource: resource
            };
            loader.add(itemName, itemUrl, options);
          };
          for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
            var item = multiPacks_1[_i];
            _loop_1(item);
          }
        }
        var loadOptions = {
          crossOrigin: resource.crossOrigin,
          metadata: resource.metadata.imageMetadata,
          parentResource: resource
        };
        var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
          if (res.error) {
            next(res.error);
            return;
          }
          var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
          spritesheet.parse(function() {
            resource.spritesheet = spritesheet;
            resource.textures = spritesheet.textures;
            next();
          });
        });
      };
      SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
        if (resource.isDataUrl) {
          return resource.data.meta.image;
        }
        return utils6.url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
      };
      return SpritesheetLoader2;
    }();
    exports.Spritesheet = Spritesheet;
    exports.SpritesheetLoader = SpritesheetLoader;
  });

  // node_modules/@pixi/sprite-tiling/dist/cjs/sprite-tiling.js
  var require_sprite_tiling = __commonJS((exports) => {
    /*!
     * @pixi/sprite-tiling - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/sprite-tiling is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var math = require_math();
    var sprite = require_sprite();
    var constants = require_constants();
    var utils6 = require_utils();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var tempPoint = new math.Point();
    var TilingSprite = function(_super) {
      __extends(TilingSprite2, _super);
      function TilingSprite2(texture, width, height) {
        if (width === void 0) {
          width = 100;
        }
        if (height === void 0) {
          height = 100;
        }
        var _this = _super.call(this, texture) || this;
        _this.tileTransform = new math.Transform();
        _this._width = width;
        _this._height = height;
        _this.uvMatrix = _this.texture.uvMatrix || new core.TextureMatrix(texture);
        _this.pluginName = "tilingSprite";
        _this.uvRespectAnchor = false;
        return _this;
      }
      Object.defineProperty(TilingSprite2.prototype, "clampMargin", {
        get: function() {
          return this.uvMatrix.clampMargin;
        },
        set: function(value) {
          this.uvMatrix.clampMargin = value;
          this.uvMatrix.update(true);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "tileScale", {
        get: function() {
          return this.tileTransform.scale;
        },
        set: function(value) {
          this.tileTransform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "tilePosition", {
        get: function() {
          return this.tileTransform.position;
        },
        set: function(value) {
          this.tileTransform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      TilingSprite2.prototype._onTextureUpdate = function() {
        if (this.uvMatrix) {
          this.uvMatrix.texture = this._texture;
        }
        this._cachedTint = 16777215;
      };
      TilingSprite2.prototype._render = function(renderer) {
        var texture = this._texture;
        if (!texture || !texture.valid) {
          return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      TilingSprite2.prototype._calculateBounds = function() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      TilingSprite2.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._width * -this._anchor._x;
          this._bounds.minY = this._height * -this._anchor._y;
          this._bounds.maxX = this._width * (1 - this._anchor._x);
          this._bounds.maxY = this._height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new math.Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      TilingSprite2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor._x;
        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
          var y1 = -height * this.anchor._y;
          if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      TilingSprite2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.tileTransform = null;
        this.uvMatrix = null;
      };
      TilingSprite2.from = function(source, options) {
        return new TilingSprite2(core.Texture.from(source, options), options.width, options.height);
      };
      Object.defineProperty(TilingSprite2.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value) {
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value) {
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      return TilingSprite2;
    }(sprite.Sprite);
    var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n";
    var fragmentSimple = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n";
    var tempMat = new math.Matrix();
    var TilingSpriteRenderer = function(_super) {
      __extends(TilingSpriteRenderer2, _super);
      function TilingSpriteRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        var uniforms = {globals: _this.renderer.globalUniforms};
        _this.shader = core.Shader.from(vertex, fragment, uniforms);
        _this.simpleShader = core.Shader.from(vertex, fragmentSimple, uniforms);
        _this.quad = new core.QuadUv();
        _this.state = core.State.for2d();
        return _this;
      }
      TilingSpriteRenderer2.prototype.render = function(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
        var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
        var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
        vertices = quad.uvs;
        vertices[0] = vertices[6] = -anchorX;
        vertices[1] = vertices[3] = -anchorY;
        vertices[2] = vertices[4] = 1 - anchorX;
        vertices[5] = vertices[7] = 1 - anchorY;
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        if (isSimple) {
          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
            if (baseTex.wrapMode === constants.WRAP_MODES.CLAMP) {
              baseTex.wrapMode = constants.WRAP_MODES.REPEAT;
            }
          } else {
            isSimple = baseTex.wrapMode !== constants.WRAP_MODES.CLAMP;
          }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w2 = tex.width;
        var h2 = tex.height;
        var W = ts._width;
        var H = ts._height;
        tempMat.set(lt.a * w2 / W, lt.b * w2 / H, lt.c * h2 / W, lt.d * h2 / H, lt.tx / W, lt.ty / H);
        tempMat.invert();
        if (isSimple) {
          tempMat.prepend(uv.mapCoord);
        } else {
          shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
          shader.uniforms.uClampFrame = uv.uClampFrame;
          shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = tempMat.toArray(true);
        shader.uniforms.uColor = utils6.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad);
        this.state.blendMode = utils6.correctBlendMode(ts.blendMode, baseTex.alphaMode);
        renderer.state.set(this.state);
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
      };
      return TilingSpriteRenderer2;
    }(core.ObjectRenderer);
    exports.TilingSprite = TilingSprite;
    exports.TilingSpriteRenderer = TilingSpriteRenderer;
  });

  // node_modules/@pixi/mesh/dist/cjs/mesh.js
  var require_mesh = __commonJS((exports) => {
    /*!
     * @pixi/mesh - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/mesh is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var math = require_math();
    var constants = require_constants();
    var display = require_display();
    var settings2 = require_settings();
    var utils6 = require_utils();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var MeshBatchUvs = function() {
      function MeshBatchUvs2(uvBuffer, uvMatrix) {
        this.uvBuffer = uvBuffer;
        this.uvMatrix = uvMatrix;
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
      }
      MeshBatchUvs2.prototype.update = function(forceUpdate) {
        if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
          return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
          this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
      };
      return MeshBatchUvs2;
    }();
    var tempPoint = new math.Point();
    var tempPolygon = new math.Polygon();
    var Mesh = function(_super) {
      __extends(Mesh2, _super);
      function Mesh2(geometry, shader, state, drawMode) {
        if (drawMode === void 0) {
          drawMode = constants.DRAW_MODES.TRIANGLES;
        }
        var _this = _super.call(this) || this;
        _this.geometry = geometry;
        geometry.refCount++;
        _this.shader = shader;
        _this.state = state || core.State.for2d();
        _this.drawMode = drawMode;
        _this.start = 0;
        _this.size = 0;
        _this.uvs = null;
        _this.indices = null;
        _this.vertexData = new Float32Array(1);
        _this.vertexDirty = 0;
        _this._transformID = -1;
        _this._roundPixels = settings2.settings.ROUND_PIXELS;
        _this.batchUvs = null;
        return _this;
      }
      Object.defineProperty(Mesh2.prototype, "uvBuffer", {
        get: function() {
          return this.geometry.buffers[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
        get: function() {
          return this.geometry.buffers[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "material", {
        get: function() {
          return this.shader;
        },
        set: function(value) {
          this.shader = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value) {
          if (this._roundPixels !== value) {
            this._transformID = -1;
          }
          this._roundPixels = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "tint", {
        get: function() {
          return "tint" in this.shader ? this.shader.tint : null;
        },
        set: function(value) {
          this.shader.tint = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "texture", {
        get: function() {
          return "texture" in this.shader ? this.shader.texture : null;
        },
        set: function(value) {
          this.shader.texture = value;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._render = function(renderer) {
        var vertices = this.geometry.buffers[0].data;
        var shader = this.shader;
        if (shader.batchable && this.drawMode === constants.DRAW_MODES.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
          this._renderToBatch(renderer);
        } else {
          this._renderDefault(renderer);
        }
      };
      Mesh2.prototype._renderDefault = function(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
          shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
          shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      };
      Mesh2.prototype._renderToBatch = function(renderer) {
        var geometry = this.geometry;
        var shader = this.shader;
        if (shader.uvMatrix) {
          shader.uvMatrix.update();
          this.calculateUvs();
        }
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = shader._tintRGB;
        this._texture = shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
      };
      Mesh2.prototype.calculateVertices = function() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
          return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
          this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b2 = wt.b;
        var c2 = wt.c;
        var d2 = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i2 = 0; i2 < vertexData.length / 2; i2++) {
          var x2 = vertices[i2 * 2];
          var y2 = vertices[i2 * 2 + 1];
          vertexData[i2 * 2] = a2 * x2 + c2 * y2 + tx;
          vertexData[i2 * 2 + 1] = b2 * x2 + d2 * y2 + ty;
        }
        if (this._roundPixels) {
          var resolution = settings2.settings.RESOLUTION;
          for (var i2 = 0; i2 < vertexData.length; ++i2) {
            vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
          }
        }
        this.vertexDirty = geometry.vertexDirtyId;
      };
      Mesh2.prototype.calculateUvs = function() {
        var geomUvs = this.geometry.buffers[1];
        var shader = this.shader;
        if (!shader.uvMatrix.isSimple) {
          if (!this.batchUvs) {
            this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
          }
          this.batchUvs.update();
          this.uvs = this.batchUvs.data;
        } else {
          this.uvs = geomUvs.data;
        }
      };
      Mesh2.prototype._calculateBounds = function() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      };
      Mesh2.prototype.containsPoint = function(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        var vertices = this.geometry.getBuffer("aVertexPosition").data;
        var points = tempPolygon.points;
        var indices = this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i2 = 0; i2 + 2 < len; i2 += step) {
          var ind0 = indices[i2] * 2;
          var ind1 = indices[i2 + 1] * 2;
          var ind2 = indices[i2 + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return true;
          }
        }
        return false;
      };
      Mesh2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
          this.geometry.dispose();
        }
        if (this._cachedTexture) {
          this._cachedTexture.destroy();
          this._cachedTexture = null;
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
      };
      Mesh2.BATCHABLE_SIZE = 100;
      return Mesh2;
    }(display.Container);
    var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
    var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var MeshMaterial = function(_super) {
      __extends(MeshMaterial2, _super);
      function MeshMaterial2(uSampler, options) {
        var _this = this;
        var uniforms = {
          uSampler,
          alpha: 1,
          uTextureMatrix: math.Matrix.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1])
        };
        options = Object.assign({
          tint: 16777215,
          alpha: 1,
          pluginName: "batch"
        }, options);
        if (options.uniforms) {
          Object.assign(uniforms, options.uniforms);
        }
        _this = _super.call(this, options.program || core.Program.from(vertex, fragment), uniforms) || this;
        _this._colorDirty = false;
        _this.uvMatrix = new core.TextureMatrix(uSampler);
        _this.batchable = options.program === void 0;
        _this.pluginName = options.pluginName;
        _this.tint = options.tint;
        _this.alpha = options.alpha;
        return _this;
      }
      Object.defineProperty(MeshMaterial2.prototype, "texture", {
        get: function() {
          return this.uniforms.uSampler;
        },
        set: function(value) {
          if (this.uniforms.uSampler !== value) {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "alpha", {
        get: function() {
          return this._alpha;
        },
        set: function(value) {
          if (value === this._alpha) {
            return;
          }
          this._alpha = value;
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value) {
          if (value === this._tint) {
            return;
          }
          this._tint = value;
          this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      MeshMaterial2.prototype.update = function() {
        if (this._colorDirty) {
          this._colorDirty = false;
          var baseTexture = this.texture.baseTexture;
          utils6.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
        }
        if (this.uvMatrix.update()) {
          this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
      };
      return MeshMaterial2;
    }(core.Shader);
    var MeshGeometry = function(_super) {
      __extends(MeshGeometry2, _super);
      function MeshGeometry2(vertices, uvs, index) {
        var _this = _super.call(this) || this;
        var verticesBuffer = new core.Buffer(vertices);
        var uvsBuffer = new core.Buffer(uvs, true);
        var indexBuffer = new core.Buffer(index, true, true);
        _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, constants.TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, constants.TYPES.FLOAT).addIndex(indexBuffer);
        _this._updateId = -1;
        return _this;
      }
      Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
        get: function() {
          return this.buffers[0]._updateID;
        },
        enumerable: false,
        configurable: true
      });
      return MeshGeometry2;
    }(core.Geometry);
    exports.Mesh = Mesh;
    exports.MeshBatchUvs = MeshBatchUvs;
    exports.MeshGeometry = MeshGeometry;
    exports.MeshMaterial = MeshMaterial;
  });

  // node_modules/@pixi/text-bitmap/dist/cjs/text-bitmap.js
  var require_text_bitmap = __commonJS((exports) => {
    /*!
     * @pixi/text-bitmap - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/text-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var math = require_math();
    var settings2 = require_settings();
    var mesh = require_mesh();
    var utils6 = require_utils();
    var core = require_core();
    var text = require_text();
    var display = require_display();
    var loaders = require_loaders();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var BitmapFontData = function() {
      function BitmapFontData2() {
        this.info = [];
        this.common = [];
        this.page = [];
        this.char = [];
        this.kerning = [];
      }
      return BitmapFontData2;
    }();
    var TextFormat = function() {
      function TextFormat2() {
      }
      TextFormat2.test = function(data) {
        return typeof data === "string" && data.indexOf("info face=") === 0;
      };
      TextFormat2.parse = function(txt) {
        var items = txt.match(/^[a-z]+\s+.+$/gm);
        var rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: []
        };
        for (var i2 in items) {
          var name = items[i2].match(/^[a-z]+/gm)[0];
          var attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          var itemData = {};
          for (var i_1 in attributeList) {
            var split = attributeList[i_1].split("=");
            var key = split[0];
            var strValue = split[1].replace(/"/gm, "");
            var floatValue = parseFloat(strValue);
            var value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        var font = new BitmapFontData();
        rawData.info.forEach(function(info) {
          return font.info.push({
            face: info.face,
            size: parseInt(info.size, 10)
          });
        });
        rawData.common.forEach(function(common) {
          return font.common.push({
            lineHeight: parseInt(common.lineHeight, 10)
          });
        });
        rawData.page.forEach(function(page) {
          return font.page.push({
            id: parseInt(page.id, 10),
            file: page.file
          });
        });
        rawData.char.forEach(function(char) {
          return font.char.push({
            id: parseInt(char.id, 10),
            page: parseInt(char.page, 10),
            x: parseInt(char.x, 10),
            y: parseInt(char.y, 10),
            width: parseInt(char.width, 10),
            height: parseInt(char.height, 10),
            xoffset: parseInt(char.xoffset, 10),
            yoffset: parseInt(char.yoffset, 10),
            xadvance: parseInt(char.xadvance, 10)
          });
        });
        rawData.kerning.forEach(function(kerning) {
          return font.kerning.push({
            first: parseInt(kerning.first, 10),
            second: parseInt(kerning.second, 10),
            amount: parseInt(kerning.amount, 10)
          });
        });
        return font;
      };
      return TextFormat2;
    }();
    var XMLFormat = function() {
      function XMLFormat2() {
      }
      XMLFormat2.test = function(data) {
        return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
      };
      XMLFormat2.parse = function(xml) {
        var data = new BitmapFontData();
        var info = xml.getElementsByTagName("info");
        var common = xml.getElementsByTagName("common");
        var page = xml.getElementsByTagName("page");
        var char = xml.getElementsByTagName("char");
        var kerning = xml.getElementsByTagName("kerning");
        for (var i2 = 0; i2 < info.length; i2++) {
          data.info.push({
            face: info[i2].getAttribute("face"),
            size: parseInt(info[i2].getAttribute("size"), 10)
          });
        }
        for (var i2 = 0; i2 < common.length; i2++) {
          data.common.push({
            lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
          });
        }
        for (var i2 = 0; i2 < page.length; i2++) {
          data.page.push({
            id: parseInt(page[i2].getAttribute("id"), 10) || 0,
            file: page[i2].getAttribute("file")
          });
        }
        for (var i2 = 0; i2 < char.length; i2++) {
          var letter = char[i2];
          data.char.push({
            id: parseInt(letter.getAttribute("id"), 10),
            page: parseInt(letter.getAttribute("page"), 10) || 0,
            x: parseInt(letter.getAttribute("x"), 10),
            y: parseInt(letter.getAttribute("y"), 10),
            width: parseInt(letter.getAttribute("width"), 10),
            height: parseInt(letter.getAttribute("height"), 10),
            xoffset: parseInt(letter.getAttribute("xoffset"), 10),
            yoffset: parseInt(letter.getAttribute("yoffset"), 10),
            xadvance: parseInt(letter.getAttribute("xadvance"), 10)
          });
        }
        for (var i2 = 0; i2 < kerning.length; i2++) {
          data.kerning.push({
            first: parseInt(kerning[i2].getAttribute("first"), 10),
            second: parseInt(kerning[i2].getAttribute("second"), 10),
            amount: parseInt(kerning[i2].getAttribute("amount"), 10)
          });
        }
        return data;
      };
      return XMLFormat2;
    }();
    var XMLStringFormat = function() {
      function XMLStringFormat2() {
      }
      XMLStringFormat2.test = function(data) {
        if (typeof data === "string" && data.indexOf("<font>") > -1) {
          var xml = new self.DOMParser().parseFromString(data, "text/xml");
          return XMLFormat.test(xml);
        }
        return false;
      };
      XMLStringFormat2.parse = function(xmlTxt) {
        var xml = new self.DOMParser().parseFromString(xmlTxt, "text/xml");
        return XMLFormat.parse(xml);
      };
      return XMLStringFormat2;
    }();
    var formats = [
      TextFormat,
      XMLFormat,
      XMLStringFormat
    ];
    function autoDetectFormat(data) {
      for (var i2 = 0; i2 < formats.length; i2++) {
        if (formats[i2].test(data)) {
          return formats[i2];
        }
      }
      return null;
    }
    function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
      var fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      var gradient;
      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      var padding = style.padding || 0;
      var width = Math.ceil(canvas.width / resolution) - dropShadowCorrection - padding * 2;
      var height = Math.ceil(canvas.height / resolution) - dropShadowCorrection - padding * 2;
      var fill = fillStyle.slice();
      var fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i2 = 1; i2 < lengthPlus1; ++i2) {
          fillGradientStops.push(i2 / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === text.TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
        var lastIterationStop = 0;
        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        var gradStopLineHeight = textHeight / height;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var thisLineTop = metrics.lineHeight * i2;
          for (var j2 = 0; j2 < fill.length; j2++) {
            var lineStop = 0;
            if (typeof fillGradientStops[j2] === "number") {
              lineStop = fillGradientStops[j2];
            } else {
              lineStop = j2 / fill.length;
            }
            var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
            var clampedStop = Math.max(lastIterationStop, globalStop);
            clampedStop = Math.min(clampedStop, 1);
            gradient.addColorStop(clampedStop, fill[j2]);
            lastIterationStop = clampedStop;
          }
        }
      } else {
        gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i2 = 0; i2 < fill.length; i2++) {
          var stop = void 0;
          if (typeof fillGradientStops[i2] === "number") {
            stop = fillGradientStops[i2];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i2]);
          currentIteration++;
        }
      }
      return gradient;
    }
    function drawGlyph(canvas, context, metrics, x2, y2, resolution, style) {
      var char = metrics.text;
      var fontProperties = metrics.fontProperties;
      context.translate(x2, y2);
      context.scale(resolution, resolution);
      var tx = style.strokeThickness / 2;
      var ty = -(style.strokeThickness / 2);
      context.font = style.toFontString();
      context.lineWidth = style.strokeThickness;
      context.textBaseline = style.textBaseline;
      context.lineJoin = style.lineJoin;
      context.miterLimit = style.miterLimit;
      context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);
      context.strokeStyle = style.stroke;
      context.font = style.toFontString();
      context.lineWidth = style.strokeThickness;
      context.textBaseline = style.textBaseline;
      context.lineJoin = style.lineJoin;
      context.miterLimit = style.miterLimit;
      context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);
      context.strokeStyle = style.stroke;
      var dropShadowColor = style.dropShadowColor;
      var rgb = utils6.hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : utils6.string2hex(dropShadowColor));
      if (style.dropShadow) {
        context.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context.shadowBlur = style.dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
      } else {
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      if (style.stroke && style.strokeThickness) {
        context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      if (style.fill) {
        context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.fillStyle = "rgba(0, 0, 0, 0)";
    }
    function resolveCharacters(chars) {
      if (typeof chars === "string") {
        chars = [chars];
      }
      var result = [];
      for (var i2 = 0, j2 = chars.length; i2 < j2; i2++) {
        var item = chars[i2];
        if (Array.isArray(item)) {
          if (item.length !== 2) {
            throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
          }
          var startCode = item[0].charCodeAt(0);
          var endCode = item[1].charCodeAt(0);
          if (endCode < startCode) {
            throw new Error("[BitmapFont]: Invalid character range.");
          }
          for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
            result.push(String.fromCharCode(i_1));
          }
        } else {
          result.push.apply(result, item.split(""));
        }
      }
      if (result.length === 0) {
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
      }
      return result;
    }
    var BitmapFont = function() {
      function BitmapFont2(data, textures, ownsTextures) {
        var info = data.info[0];
        var common = data.common[0];
        var page = data.page[0];
        var res = utils6.getResolutionOfUrl(page.file);
        var pageTextures = {};
        this._ownsTextures = ownsTextures;
        this.font = info.face;
        this.size = info.size;
        this.lineHeight = common.lineHeight / res;
        this.chars = {};
        this.pageTextures = pageTextures;
        for (var i2 = 0; i2 < data.page.length; i2++) {
          var _a = data.page[i2], id = _a.id, file = _a.file;
          pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file];
        }
        for (var i2 = 0; i2 < data.char.length; i2++) {
          var _b = data.char[i2], id = _b.id, page_1 = _b.page;
          var _c = data.char[i2], x2 = _c.x, y2 = _c.y, width = _c.width, height = _c.height, xoffset = _c.xoffset, yoffset = _c.yoffset, xadvance = _c.xadvance;
          x2 /= res;
          y2 /= res;
          width /= res;
          height /= res;
          xoffset /= res;
          yoffset /= res;
          xadvance /= res;
          var rect = new math.Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width, height);
          this.chars[id] = {
            xOffset: xoffset,
            yOffset: yoffset,
            xAdvance: xadvance,
            kerning: {},
            texture: new core.Texture(pageTextures[page_1].baseTexture, rect),
            page: page_1
          };
        }
        for (var i2 = 0; i2 < data.kerning.length; i2++) {
          var _d = data.kerning[i2], first = _d.first, second = _d.second, amount = _d.amount;
          first /= res;
          second /= res;
          amount /= res;
          if (this.chars[second]) {
            this.chars[second].kerning[first] = amount;
          }
        }
      }
      BitmapFont2.prototype.destroy = function() {
        for (var id in this.chars) {
          this.chars[id].texture.destroy();
          this.chars[id].texture = null;
        }
        for (var id in this.pageTextures) {
          if (this._ownsTextures) {
            this.pageTextures[id].destroy(true);
          }
          this.pageTextures[id] = null;
        }
        this.chars = null;
        this.pageTextures = null;
      };
      BitmapFont2.install = function(data, textures, ownsTextures) {
        var fontData;
        if (data instanceof BitmapFontData) {
          fontData = data;
        } else {
          var format = autoDetectFormat(data);
          if (!format) {
            throw new Error("Unrecognized data format for font.");
          }
          fontData = format.parse(data);
        }
        if (textures instanceof core.Texture) {
          textures = [textures];
        }
        var font = new BitmapFont2(fontData, textures, ownsTextures);
        BitmapFont2.available[font.font] = font;
        return font;
      };
      BitmapFont2.uninstall = function(name) {
        var font = BitmapFont2.available[name];
        if (!font) {
          throw new Error("No font found named '" + name + "'");
        }
        font.destroy();
        delete BitmapFont2.available[name];
      };
      BitmapFont2.from = function(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFont] Property `name` is required.");
        }
        var _a = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a.chars, padding = _a.padding, resolution = _a.resolution, textureWidth = _a.textureWidth, textureHeight = _a.textureHeight;
        var charsList = resolveCharacters(chars);
        var style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);
        var lineWidth = textureWidth;
        var fontData = new BitmapFontData();
        fontData.info[0] = {
          face: style.fontFamily,
          size: style.fontSize
        };
        fontData.common[0] = {
          lineHeight: style.fontSize
        };
        var positionX = 0;
        var positionY = 0;
        var canvas;
        var context;
        var baseTexture;
        var maxCharHeight = 0;
        var textures = [];
        for (var i2 = 0; i2 < charsList.length; i2++) {
          if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.width = textureWidth;
            canvas.height = textureHeight;
            context = canvas.getContext("2d");
            baseTexture = new core.BaseTexture(canvas, {resolution});
            textures.push(new core.Texture(baseTexture));
            fontData.page.push({
              id: textures.length - 1,
              file: ""
            });
          }
          var metrics = text.TextMetrics.measureText(charsList[i2], style, false, canvas);
          var width = metrics.width;
          var height = Math.ceil(metrics.height);
          var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
          if (positionY >= textureHeight - height * resolution) {
            if (positionY === 0) {
              throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
            }
            --i2;
            canvas = null;
            context = null;
            baseTexture = null;
            positionY = 0;
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
          if (textureGlyphWidth * resolution + positionX >= lineWidth) {
            --i2;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
          var id = metrics.text.charCodeAt(0);
          fontData.char.push({
            id,
            page: textures.length - 1,
            x: positionX / resolution,
            y: positionY / resolution,
            width: textureGlyphWidth,
            height,
            xoffset: 0,
            yoffset: 0,
            xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
          });
          positionX += (textureGlyphWidth + 2 * padding) * resolution;
          positionX = Math.ceil(positionX);
        }
        for (var i2 = 0, len = charsList.length; i2 < len; i2++) {
          var first = charsList[i2];
          for (var j2 = 0; j2 < len; j2++) {
            var second = charsList[j2];
            var c1 = context.measureText(first).width;
            var c2 = context.measureText(second).width;
            var total = context.measureText(first + second).width;
            var amount = total - (c1 + c2);
            if (amount) {
              fontData.kerning.push({
                first: first.charCodeAt(0),
                second: second.charCodeAt(0),
                amount
              });
            }
          }
        }
        var font = new BitmapFont2(fontData, textures, true);
        if (BitmapFont2.available[name] !== void 0) {
          BitmapFont2.uninstall(name);
        }
        BitmapFont2.available[name] = font;
        return font;
      };
      BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
      BitmapFont2.NUMERIC = [["0", "9"]];
      BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      BitmapFont2.ASCII = [[" ", "~"]];
      BitmapFont2.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: BitmapFont2.ALPHANUMERIC
      };
      BitmapFont2.available = {};
      return BitmapFont2;
    }();
    var pageMeshDataPool = [];
    var charRenderDataPool = [];
    var BitmapText = function(_super) {
      __extends(BitmapText2, _super);
      function BitmapText2(text2, style) {
        if (style === void 0) {
          style = {};
        }
        var _this = _super.call(this) || this;
        _this._tint = 16777215;
        var _a = Object.assign({}, BitmapText2.styleDefaults, style), align = _a.align, tint = _a.tint, maxWidth = _a.maxWidth, letterSpacing = _a.letterSpacing, fontName = _a.fontName, fontSize = _a.fontSize;
        if (!BitmapFont.available[fontName]) {
          throw new Error('Missing BitmapFont "' + fontName + '"');
        }
        _this._activePagesMeshData = [];
        _this._textWidth = 0;
        _this._textHeight = 0;
        _this._align = align;
        _this._tint = tint;
        _this._fontName = fontName;
        _this._fontSize = fontSize || BitmapFont.available[fontName].size;
        _this._text = text2;
        _this._maxWidth = maxWidth;
        _this._maxLineHeight = 0;
        _this._letterSpacing = letterSpacing;
        _this._anchor = new math.ObservablePoint(function() {
          _this.dirty = true;
        }, _this, 0, 0);
        _this._roundPixels = settings2.settings.ROUND_PIXELS;
        _this.dirty = true;
        _this._textureCache = {};
        return _this;
      }
      BitmapText2.prototype.updateText = function() {
        var _a;
        var data = BitmapFont.available[this._fontName];
        var scale = this._fontSize / data.size;
        var pos = new math.Point();
        var chars = [];
        var lineWidths = [];
        var lineSpaces = [];
        var text2 = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
        var textLength = text2.length;
        var maxWidth = this._maxWidth * data.size / this._fontSize;
        var prevCharCode = null;
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var line = 0;
        var lastBreakPos = -1;
        var lastBreakWidth = 0;
        var spacesRemoved = 0;
        var maxLineHeight = 0;
        var spaceCount = 0;
        for (var i2 = 0; i2 < textLength; i2++) {
          var charCode = text2.charCodeAt(i2);
          var char = text2.charAt(i2);
          if (/(?:\s)/.test(char)) {
            lastBreakPos = i2;
            lastBreakWidth = lastLineWidth;
            spaceCount++;
          }
          if (char === "\r" || char === "\n") {
            lineWidths.push(lastLineWidth);
            lineSpaces.push(-1);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            ++line;
            ++spacesRemoved;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
            continue;
          }
          var charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          var charRenderData = charRenderDataPool.pop() || {
            texture: core.Texture.EMPTY,
            line: 0,
            charCode: 0,
            prevSpaces: 0,
            position: new math.Point()
          };
          charRenderData.texture = charData.texture;
          charRenderData.line = line;
          charRenderData.charCode = charCode;
          charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
          charRenderData.position.y = pos.y + charData.yOffset;
          charRenderData.prevSpaces = spaceCount;
          chars.push(charRenderData);
          pos.x += charData.xAdvance + this._letterSpacing;
          lastLineWidth = pos.x;
          maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
          prevCharCode = charCode;
          if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
            ++spacesRemoved;
            utils6.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
            i2 = lastBreakPos;
            lastBreakPos = -1;
            lineWidths.push(lastBreakWidth);
            lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
            maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
          }
        }
        var lastChar = text2.charAt(text2.length - 1);
        if (lastChar !== "\r" && lastChar !== "\n") {
          if (/(?:\s)/.test(lastChar)) {
            lastLineWidth = lastBreakWidth;
          }
          lineWidths.push(lastLineWidth);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          lineSpaces.push(-1);
        }
        var lineAlignOffsets = [];
        for (var i2 = 0; i2 <= line; i2++) {
          var alignOffset = 0;
          if (this._align === "right") {
            alignOffset = maxLineWidth - lineWidths[i2];
          } else if (this._align === "center") {
            alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
          } else if (this._align === "justify") {
            alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];
          }
          lineAlignOffsets.push(alignOffset);
        }
        var lenChars = chars.length;
        var pagesMeshData = {};
        var newPagesMeshData = [];
        var activePagesMeshData = this._activePagesMeshData;
        for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
          pageMeshDataPool.push(activePagesMeshData[i2]);
        }
        for (var i2 = 0; i2 < lenChars; i2++) {
          var texture = chars[i2].texture;
          var baseTextureUid = texture.baseTexture.uid;
          if (!pagesMeshData[baseTextureUid]) {
            var pageMeshData = pageMeshDataPool.pop();
            if (!pageMeshData) {
              var geometry = new mesh.MeshGeometry();
              var material = new mesh.MeshMaterial(core.Texture.EMPTY);
              var mesh$1 = new mesh.Mesh(geometry, material);
              pageMeshData = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh: mesh$1,
                vertices: null,
                uvs: null,
                indices: null
              };
            }
            pageMeshData.index = 0;
            pageMeshData.indexCount = 0;
            pageMeshData.vertexCount = 0;
            pageMeshData.uvsCount = 0;
            pageMeshData.total = 0;
            var _textureCache = this._textureCache;
            _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture);
            pageMeshData.mesh.texture = _textureCache[baseTextureUid];
            pageMeshData.mesh.tint = this._tint;
            newPagesMeshData.push(pageMeshData);
            pagesMeshData[baseTextureUid] = pageMeshData;
          }
          pagesMeshData[baseTextureUid].total++;
        }
        for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
          if (newPagesMeshData.indexOf(activePagesMeshData[i2]) === -1) {
            this.removeChild(activePagesMeshData[i2].mesh);
          }
        }
        for (var i2 = 0; i2 < newPagesMeshData.length; i2++) {
          if (newPagesMeshData[i2].mesh.parent !== this) {
            this.addChild(newPagesMeshData[i2].mesh);
          }
        }
        this._activePagesMeshData = newPagesMeshData;
        for (var i2 in pagesMeshData) {
          var pageMeshData = pagesMeshData[i2];
          var total = pageMeshData.total;
          if (!(((_a = pageMeshData.indices) === null || _a === void 0 ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2) {
            pageMeshData.vertices = new Float32Array(4 * 2 * total);
            pageMeshData.uvs = new Float32Array(4 * 2 * total);
            pageMeshData.indices = new Uint16Array(6 * total);
          } else {
            var total_1 = pageMeshData.total;
            var vertices = pageMeshData.vertices;
            for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
              vertices[i_1] = 0;
            }
          }
          pageMeshData.mesh.size = 6 * total;
        }
        for (var i2 = 0; i2 < lenChars; i2++) {
          var char = chars[i2];
          var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
          if (this._roundPixels) {
            offset = Math.round(offset);
          }
          var xPos = offset * scale;
          var yPos = char.position.y * scale;
          var texture = char.texture;
          var pageMesh = pagesMeshData[texture.baseTexture.uid];
          var textureFrame = texture.frame;
          var textureUvs = texture._uvs;
          var index = pageMesh.index++;
          pageMesh.indices[index * 6 + 0] = 0 + index * 4;
          pageMesh.indices[index * 6 + 1] = 1 + index * 4;
          pageMesh.indices[index * 6 + 2] = 2 + index * 4;
          pageMesh.indices[index * 6 + 3] = 0 + index * 4;
          pageMesh.indices[index * 6 + 4] = 2 + index * 4;
          pageMesh.indices[index * 6 + 5] = 3 + index * 4;
          pageMesh.vertices[index * 8 + 0] = xPos;
          pageMesh.vertices[index * 8 + 1] = yPos;
          pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 3] = yPos;
          pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
          pageMesh.vertices[index * 8 + 6] = xPos;
          pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
          pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
          pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
          pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
          pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
          pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
          pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
          pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
          pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (var i2 in pagesMeshData) {
          var pageMeshData = pagesMeshData[i2];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            var vertexCount = 0;
            var anchorOffsetX = this._textWidth * this.anchor.x;
            var anchorOffsetY = this._textHeight * this.anchor.y;
            for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
          }
          this._maxLineHeight = maxLineHeight * scale;
          var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
          var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
          var indexBuffer = pageMeshData.mesh.geometry.getIndex();
          vertexBuffer.data = pageMeshData.vertices;
          textureBuffer.data = pageMeshData.uvs;
          indexBuffer.data = pageMeshData.indices;
          vertexBuffer.update();
          textureBuffer.update();
          indexBuffer.update();
        }
        for (var i2 = 0; i2 < chars.length; i2++) {
          charRenderDataPool.push(chars[i2]);
        }
      };
      BitmapText2.prototype.updateTransform = function() {
        this.validate();
        this.containerUpdateTransform();
      };
      BitmapText2.prototype.getLocalBounds = function() {
        this.validate();
        return _super.prototype.getLocalBounds.call(this);
      };
      BitmapText2.prototype.validate = function() {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
      };
      Object.defineProperty(BitmapText2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value) {
          if (this._tint === value) {
            return;
          }
          this._tint = value;
          for (var i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
            this._activePagesMeshData[i2].mesh.tint = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(value) {
          if (this._align !== value) {
            this._align = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "fontName", {
        get: function() {
          return this._fontName;
        },
        set: function(value) {
          if (!BitmapFont.available[value]) {
            throw new Error('Missing BitmapFont "' + value + '"');
          }
          if (this._fontName !== value) {
            this._fontName = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(value) {
          if (this._fontSize !== value) {
            this._fontSize = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value) {
          if (typeof value === "number") {
            this._anchor.set(value);
          } else {
            this._anchor.copyFrom(value);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text2) {
          text2 = String(text2 === null || text2 === void 0 ? "" : text2);
          if (this._text === text2) {
            return;
          }
          this._text = text2;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "maxWidth", {
        get: function() {
          return this._maxWidth;
        },
        set: function(value) {
          if (this._maxWidth === value) {
            return;
          }
          this._maxWidth = value;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "maxLineHeight", {
        get: function() {
          this.validate();
          return this._maxLineHeight;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "textWidth", {
        get: function() {
          this.validate();
          return this._textWidth;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(value) {
          if (this._letterSpacing !== value) {
            this._letterSpacing = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value) {
          if (value !== this._roundPixels) {
            this._roundPixels = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "textHeight", {
        get: function() {
          this.validate();
          return this._textHeight;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText2.prototype.destroy = function(options) {
        var _textureCache = this._textureCache;
        for (var id in _textureCache) {
          var texture = _textureCache[id];
          texture.destroy();
          delete _textureCache[id];
        }
        this._textureCache = null;
        _super.prototype.destroy.call(this, options);
      };
      BitmapText2.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
      };
      return BitmapText2;
    }(display.Container);
    var BitmapFontLoader = function() {
      function BitmapFontLoader2() {
      }
      BitmapFontLoader2.add = function() {
        loaders.LoaderResource.setExtensionXhrType("fnt", loaders.LoaderResource.XHR_RESPONSE_TYPE.TEXT);
      };
      BitmapFontLoader2.use = function(resource, next) {
        var format = autoDetectFormat(resource.data);
        if (!format) {
          next();
          return;
        }
        var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
        var data = format.parse(resource.data);
        var textures = {};
        var completed = function(page) {
          textures[page.metadata.pageFile] = page.texture;
          if (Object.keys(textures).length === data.page.length) {
            resource.bitmapFont = BitmapFont.install(data, textures, true);
            next();
          }
        };
        for (var i2 = 0; i2 < data.page.length; ++i2) {
          var pageFile = data.page[i2].file;
          var url = baseUrl + pageFile;
          var exists = false;
          for (var name in this.resources) {
            var bitmapResource = this.resources[name];
            if (bitmapResource.url === url) {
              bitmapResource.metadata.pageFile = pageFile;
              if (bitmapResource.texture) {
                completed(bitmapResource);
              } else {
                bitmapResource.onAfterMiddleware.add(completed);
              }
              exists = true;
              break;
            }
          }
          if (!exists) {
            var options = {
              crossOrigin: resource.crossOrigin,
              loadType: loaders.LoaderResource.LOAD_TYPE.IMAGE,
              metadata: Object.assign({pageFile}, resource.metadata.imageMetadata),
              parentResource: resource
            };
            this.add(url, options, completed);
          }
        }
      };
      BitmapFontLoader2.getBaseUrl = function(loader, resource) {
        var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
        if (resource.isDataUrl) {
          if (resUrl === ".") {
            resUrl = "";
          }
          if (loader.baseUrl && resUrl) {
            if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
              resUrl += "/";
            }
          }
        }
        resUrl = resUrl.replace(loader.baseUrl, "");
        if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
          resUrl += "/";
        }
        return resUrl;
      };
      BitmapFontLoader2.dirname = function(url) {
        var dir = url.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
        if (dir === url) {
          return ".";
        } else if (dir === "") {
          return "/";
        }
        return dir;
      };
      return BitmapFontLoader2;
    }();
    exports.BitmapFont = BitmapFont;
    exports.BitmapFontData = BitmapFontData;
    exports.BitmapFontLoader = BitmapFontLoader;
    exports.BitmapText = BitmapText;
  });

  // node_modules/@pixi/filter-alpha/dist/cjs/filter-alpha.js
  var require_filter_alpha = __commonJS((exports) => {
    /*!
     * @pixi/filter-alpha - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-alpha is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
    var AlphaFilter = function(_super) {
      __extends(AlphaFilter2, _super);
      function AlphaFilter2(alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        var _this = _super.call(this, core.defaultVertex, fragment, {uAlpha: 1}) || this;
        _this.alpha = alpha;
        return _this;
      }
      Object.defineProperty(AlphaFilter2.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value) {
          this.uniforms.uAlpha = value;
        },
        enumerable: false,
        configurable: true
      });
      return AlphaFilter2;
    }(core.Filter);
    exports.AlphaFilter = AlphaFilter;
  });

  // node_modules/@pixi/filter-blur/dist/cjs/filter-blur.js
  var require_filter_blur = __commonJS((exports) => {
    /*!
     * @pixi/filter-blur - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-blur is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var settings2 = require_settings();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
    function generateBlurVertSource(kernelSize, x2) {
      var halfLength = Math.ceil(kernelSize / 2);
      var vertSource = vertTemplate;
      var blurLoop = "";
      var template;
      if (x2) {
        template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
      } else {
        template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
      }
      for (var i2 = 0; i2 < kernelSize; i2++) {
        var blur = template.replace("%index%", i2.toString());
        blur = blur.replace("%sampleIndex%", i2 - (halfLength - 1) + ".0");
        blurLoop += blur;
        blurLoop += "\n";
      }
      vertSource = vertSource.replace("%blur%", blurLoop);
      vertSource = vertSource.replace("%size%", kernelSize.toString());
      return vertSource;
    }
    var GAUSSIAN_VALUES = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
      15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
    };
    var fragTemplate = [
      "varying vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uSampler;",
      "void main(void)",
      "{",
      "    gl_FragColor = vec4(0.0);",
      "    %blur%",
      "}"
    ].join("\n");
    function generateBlurFragSource(kernelSize) {
      var kernel = GAUSSIAN_VALUES[kernelSize];
      var halfLength = kernel.length;
      var fragSource = fragTemplate;
      var blurLoop = "";
      var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
      var value;
      for (var i2 = 0; i2 < kernelSize; i2++) {
        var blur = template.replace("%index%", i2.toString());
        value = i2;
        if (i2 >= halfLength) {
          value = kernelSize - i2 - 1;
        }
        blur = blur.replace("%value%", kernel[value].toString());
        blurLoop += blur;
        blurLoop += "\n";
      }
      fragSource = fragSource.replace("%blur%", blurLoop);
      fragSource = fragSource.replace("%size%", kernelSize.toString());
      return fragSource;
    }
    var ENV;
    (function(ENV2) {
      ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
      ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    })(ENV || (ENV = {}));
    var RENDERER_TYPE;
    (function(RENDERER_TYPE2) {
      RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    })(RENDERER_TYPE || (RENDERER_TYPE = {}));
    var BUFFER_BITS;
    (function(BUFFER_BITS2) {
      BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    })(BUFFER_BITS || (BUFFER_BITS = {}));
    var BLEND_MODES;
    (function(BLEND_MODES2) {
      BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
      BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
      BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
      BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
      BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
      BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    })(BLEND_MODES || (BLEND_MODES = {}));
    var DRAW_MODES;
    (function(DRAW_MODES2) {
      DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
      DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
      DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(DRAW_MODES || (DRAW_MODES = {}));
    var FORMATS;
    (function(FORMATS2) {
      FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
      FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
      FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
      FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(FORMATS || (FORMATS = {}));
    var TARGETS;
    (function(TARGETS2) {
      TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(TARGETS || (TARGETS = {}));
    var TYPES;
    (function(TYPES2) {
      TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
      TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(TYPES || (TYPES = {}));
    var SCALE_MODES3;
    (function(SCALE_MODES4) {
      SCALE_MODES4[SCALE_MODES4["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES4[SCALE_MODES4["LINEAR"] = 1] = "LINEAR";
    })(SCALE_MODES3 || (SCALE_MODES3 = {}));
    var WRAP_MODES;
    (function(WRAP_MODES2) {
      WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(WRAP_MODES || (WRAP_MODES = {}));
    var MIPMAP_MODES;
    (function(MIPMAP_MODES2) {
      MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
      MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
      MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
      MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
    })(MIPMAP_MODES || (MIPMAP_MODES = {}));
    var ALPHA_MODES;
    (function(ALPHA_MODES2) {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(ALPHA_MODES || (ALPHA_MODES = {}));
    var CLEAR_MODES;
    (function(CLEAR_MODES2) {
      CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
      CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
      CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
      CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
      CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    })(CLEAR_MODES || (CLEAR_MODES = {}));
    var GC_MODES;
    (function(GC_MODES2) {
      GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
      GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    })(GC_MODES || (GC_MODES = {}));
    var PRECISION;
    (function(PRECISION2) {
      PRECISION2["LOW"] = "lowp";
      PRECISION2["MEDIUM"] = "mediump";
      PRECISION2["HIGH"] = "highp";
    })(PRECISION || (PRECISION = {}));
    var MASK_TYPES;
    (function(MASK_TYPES2) {
      MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
      MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    })(MASK_TYPES || (MASK_TYPES = {}));
    var MSAA_QUALITY;
    (function(MSAA_QUALITY2) {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    })(MSAA_QUALITY || (MSAA_QUALITY = {}));
    var BlurFilterPass = function(_super) {
      __extends(BlurFilterPass2, _super);
      function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings2.settings.FILTER_RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = this;
        var vertSrc = generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = generateBlurFragSource(kernelSize);
        _this = _super.call(this, vertSrc, fragSrc) || this;
        _this.horizontal = horizontal;
        _this.resolution = resolution;
        _this._quality = 0;
        _this.quality = quality;
        _this.blur = strength;
        return _this;
      }
      BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
        if (output) {
          if (this.horizontal) {
            this.uniforms.strength = 1 / output.width * (output.width / input.width);
          } else {
            this.uniforms.strength = 1 / output.height * (output.height / input.height);
          }
        } else {
          if (this.horizontal) {
            this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
          } else {
            this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
          }
        }
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
          filterManager.applyFilter(this, input, output, clearMode);
        } else {
          var renderTarget = filterManager.getFilterTexture();
          var renderer = filterManager.renderer;
          var flip = input;
          var flop = renderTarget;
          this.state.blend = false;
          filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
          for (var i2 = 1; i2 < this.passes - 1; i2++) {
            filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
            this.uniforms.uSampler = flop;
            var temp = flop;
            flop = flip;
            flip = temp;
            renderer.shader.bind(this);
            renderer.geometry.draw(5);
          }
          this.state.blend = true;
          filterManager.applyFilter(this, flop, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        }
      };
      Object.defineProperty(BlurFilterPass2.prototype, "blur", {
        get: function() {
          return this.strength;
        },
        set: function(value) {
          this.padding = 1 + Math.abs(value) * 2;
          this.strength = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilterPass2.prototype, "quality", {
        get: function() {
          return this._quality;
        },
        set: function(value) {
          this._quality = value;
          this.passes = value;
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilterPass2;
    }(core.Filter);
    var BlurFilter = function(_super) {
      __extends(BlurFilter2, _super);
      function BlurFilter2(strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings2.settings.FILTER_RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = _super.call(this) || this;
        _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
        _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
        _this.resolution = resolution;
        _this.quality = quality;
        _this.blur = strength;
        _this.repeatEdgePixels = false;
        return _this;
      }
      BlurFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
          var renderTarget = filterManager.getFilterTexture();
          this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
          this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        } else if (yStrength) {
          this.blurYFilter.apply(filterManager, input, output, clearMode);
        } else {
          this.blurXFilter.apply(filterManager, input, output, clearMode);
        }
      };
      BlurFilter2.prototype.updatePadding = function() {
        if (this._repeatEdgePixels) {
          this.padding = 0;
        } else {
          this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
      };
      Object.defineProperty(BlurFilter2.prototype, "blur", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value) {
          this.blurXFilter.blur = this.blurYFilter.blur = value;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter2.prototype, "quality", {
        get: function() {
          return this.blurXFilter.quality;
        },
        set: function(value) {
          this.blurXFilter.quality = this.blurYFilter.quality = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter2.prototype, "blurX", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value) {
          this.blurXFilter.blur = value;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter2.prototype, "blurY", {
        get: function() {
          return this.blurYFilter.blur;
        },
        set: function(value) {
          this.blurYFilter.blur = value;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter2.prototype, "blendMode", {
        get: function() {
          return this.blurYFilter.blendMode;
        },
        set: function(value) {
          this.blurYFilter.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter2.prototype, "repeatEdgePixels", {
        get: function() {
          return this._repeatEdgePixels;
        },
        set: function(value) {
          this._repeatEdgePixels = value;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilter2;
    }(core.Filter);
    exports.BlurFilter = BlurFilter;
    exports.BlurFilterPass = BlurFilterPass;
  });

  // node_modules/@pixi/filter-color-matrix/dist/cjs/filter-color-matrix.js
  var require_filter_color_matrix = __commonJS((exports) => {
    /*!
     * @pixi/filter-color-matrix - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-color-matrix is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
    var ColorMatrixFilter = function(_super) {
      __extends(ColorMatrixFilter2, _super);
      function ColorMatrixFilter2() {
        var _this = this;
        var uniforms = {
          m: new Float32Array([
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ]),
          uAlpha: 1
        };
        _this = _super.call(this, core.defaultFilterVertex, fragment, uniforms) || this;
        _this.alpha = 1;
        return _this;
      }
      ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
        if (multiply === void 0) {
          multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.uniforms.m, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.uniforms.m = newMatrix;
      };
      ColorMatrixFilter2.prototype._multiply = function(out, a2, b2) {
        out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
        out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
        out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
        out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
        out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
        out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
        out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
        out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
        out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
        out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
        out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
        out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
        out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
        out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
        out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
        out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
        out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
        out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
        out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
        out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
        return out;
      };
      ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
        var m2 = new Float32Array(matrix);
        m2[4] /= 255;
        m2[9] /= 255;
        m2[14] /= 255;
        m2[19] /= 255;
        return m2;
      };
      ColorMatrixFilter2.prototype.brightness = function(b2, multiply) {
        var matrix = [
          b2,
          0,
          0,
          0,
          0,
          0,
          b2,
          0,
          0,
          0,
          0,
          0,
          b2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
        var matrix = [
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
        var matrix = [
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        var w2 = 1 / 3;
        var sqrW = sqrt(w2);
        var a00 = cosR + (1 - cosR) * w2;
        var a01 = w2 * (1 - cosR) - sqrW * sinR;
        var a02 = w2 * (1 - cosR) + sqrW * sinR;
        var a10 = w2 * (1 - cosR) + sqrW * sinR;
        var a11 = cosR + w2 * (1 - cosR);
        var a12 = w2 * (1 - cosR) - sqrW * sinR;
        var a20 = w2 * (1 - cosR) - sqrW * sinR;
        var a21 = w2 * (1 - cosR) + sqrW * sinR;
        var a22 = cosR + w2 * (1 - cosR);
        var matrix = [
          a00,
          a01,
          a02,
          0,
          0,
          a10,
          a11,
          a12,
          0,
          0,
          a20,
          a21,
          a22,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
        var v2 = (amount || 0) + 1;
        var o2 = -0.5 * (v2 - 1);
        var matrix = [
          v2,
          0,
          0,
          0,
          o2,
          0,
          v2,
          0,
          0,
          o2,
          0,
          0,
          v2,
          0,
          o2,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
        if (amount === void 0) {
          amount = 0;
        }
        var x2 = amount * 2 / 3 + 1;
        var y2 = (x2 - 1) * -0.5;
        var matrix = [
          x2,
          y2,
          y2,
          0,
          0,
          y2,
          x2,
          y2,
          0,
          0,
          y2,
          y2,
          x2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.desaturate = function() {
        this.saturate(-1);
      };
      ColorMatrixFilter2.prototype.negative = function(multiply) {
        var matrix = [
          -1,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          -1,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.sepia = function(multiply) {
        var matrix = [
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.technicolor = function(multiply) {
        var matrix = [
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.polaroid = function(multiply) {
        var matrix = [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.toBGR = function(multiply) {
        var matrix = [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
        var matrix = [
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.browni = function(multiply) {
        var matrix = [
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.vintage = function(multiply) {
        var matrix = [
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 16770432;
        darkColor = darkColor || 3375104;
        var lR = (lightColor >> 16 & 255) / 255;
        var lG = (lightColor >> 8 & 255) / 255;
        var lB = (lightColor & 255) / 255;
        var dR = (darkColor >> 16 & 255) / 255;
        var dG = (darkColor >> 8 & 255) / 255;
        var dB = (darkColor & 255) / 255;
        var matrix = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          lR,
          lG,
          lB,
          desaturation,
          0,
          dR,
          dG,
          dB,
          toned,
          0,
          lR - dR,
          lG - dG,
          lB - dB,
          0,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
          intensity * -2,
          -intensity,
          0,
          0,
          0,
          -intensity,
          0,
          intensity,
          0,
          0,
          0,
          intensity,
          intensity * 2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
        var matrix = [
          11.224130630493164 * amount,
          -4.794486999511719 * amount,
          -2.8746118545532227 * amount,
          0 * amount,
          0.40342438220977783 * amount,
          -3.6330697536468506 * amount,
          9.193157196044922 * amount,
          -2.951810836791992 * amount,
          0 * amount,
          -1.316135048866272 * amount,
          -3.2184197902679443 * amount,
          -4.2375030517578125 * amount,
          7.476448059082031 * amount,
          0 * amount,
          0.8044459223747253 * amount,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.lsd = function(multiply) {
        var matrix = [
          2,
          -0.4,
          0.5,
          0,
          0,
          -0.5,
          2,
          -0.4,
          0,
          0,
          -0.4,
          -0.5,
          3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.reset = function() {
        var matrix = [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, false);
      };
      Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
        get: function() {
          return this.uniforms.m;
        },
        set: function(value) {
          this.uniforms.m = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value) {
          this.uniforms.uAlpha = value;
        },
        enumerable: false,
        configurable: true
      });
      return ColorMatrixFilter2;
    }(core.Filter);
    ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
    exports.ColorMatrixFilter = ColorMatrixFilter;
  });

  // node_modules/@pixi/filter-displacement/dist/cjs/filter-displacement.js
  var require_filter_displacement = __commonJS((exports) => {
    /*!
     * @pixi/filter-displacement - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-displacement is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var math = require_math();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
    var vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
    var DisplacementFilter = function(_super) {
      __extends(DisplacementFilter2, _super);
      function DisplacementFilter2(sprite, scale) {
        var _this = this;
        var maskMatrix = new math.Matrix();
        sprite.renderable = false;
        _this = _super.call(this, vertex, fragment, {
          mapSampler: sprite._texture,
          filterMatrix: maskMatrix,
          scale: {x: 1, y: 1},
          rotation: new Float32Array([1, 0, 0, 1])
        }) || this;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        if (scale === null || scale === void 0) {
          scale = 20;
        }
        _this.scale = new math.Point(scale, scale);
        return _this;
      }
      DisplacementFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        var wt = this.maskSprite.worldTransform;
        var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
        var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
        if (lenX !== 0 && lenY !== 0) {
          this.uniforms.rotation[0] = wt.a / lenX;
          this.uniforms.rotation[1] = wt.b / lenX;
          this.uniforms.rotation[2] = wt.c / lenY;
          this.uniforms.rotation[3] = wt.d / lenY;
        }
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(DisplacementFilter2.prototype, "map", {
        get: function() {
          return this.uniforms.mapSampler;
        },
        set: function(value) {
          this.uniforms.mapSampler = value;
        },
        enumerable: false,
        configurable: true
      });
      return DisplacementFilter2;
    }(core.Filter);
    exports.DisplacementFilter = DisplacementFilter;
  });

  // node_modules/@pixi/filter-fxaa/dist/cjs/filter-fxaa.js
  var require_filter_fxaa = __commonJS((exports) => {
    /*!
     * @pixi/filter-fxaa - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-fxaa is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
    var fragment = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputPixel;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
    var FXAAFilter = function(_super) {
      __extends(FXAAFilter2, _super);
      function FXAAFilter2() {
        return _super.call(this, vertex, fragment) || this;
      }
      return FXAAFilter2;
    }(core.Filter);
    exports.FXAAFilter = FXAAFilter;
  });

  // node_modules/@pixi/filter-noise/dist/cjs/filter-noise.js
  var require_filter_noise = __commonJS((exports) => {
    /*!
     * @pixi/filter-noise - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/filter-noise is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
    var NoiseFilter = function(_super) {
      __extends(NoiseFilter2, _super);
      function NoiseFilter2(noise, seed) {
        if (noise === void 0) {
          noise = 0.5;
        }
        if (seed === void 0) {
          seed = Math.random();
        }
        var _this = _super.call(this, core.defaultFilterVertex, fragment, {
          uNoise: 0,
          uSeed: 0
        }) || this;
        _this.noise = noise;
        _this.seed = seed;
        return _this;
      }
      Object.defineProperty(NoiseFilter2.prototype, "noise", {
        get: function() {
          return this.uniforms.uNoise;
        },
        set: function(value) {
          this.uniforms.uNoise = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NoiseFilter2.prototype, "seed", {
        get: function() {
          return this.uniforms.uSeed;
        },
        set: function(value) {
          this.uniforms.uSeed = value;
        },
        enumerable: false,
        configurable: true
      });
      return NoiseFilter2;
    }(core.Filter);
    exports.NoiseFilter = NoiseFilter;
  });

  // node_modules/@pixi/mixin-cache-as-bitmap/dist/cjs/mixin-cache-as-bitmap.js
  var require_mixin_cache_as_bitmap = __commonJS((exports) => {
    /*!
     * @pixi/mixin-cache-as-bitmap - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var sprite = require_sprite();
    var display = require_display();
    var math = require_math();
    var utils6 = require_utils();
    var settings2 = require_settings();
    var _tempMatrix = new math.Matrix();
    display.DisplayObject.prototype._cacheAsBitmap = false;
    display.DisplayObject.prototype._cacheData = null;
    display.DisplayObject.prototype._cacheAsBitmapResolution = null;
    var CacheData = function() {
      function CacheData2() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.originalContainsPoint = null;
        this.sprite = null;
      }
      return CacheData2;
    }();
    Object.defineProperties(display.DisplayObject.prototype, {
      cacheAsBitmapResolution: {
        get: function() {
          return this._cacheAsBitmapResolution;
        },
        set: function(resolution) {
          if (resolution === this._cacheAsBitmapResolution) {
            return;
          }
          this._cacheAsBitmapResolution = resolution;
          if (this.cacheAsBitmap) {
            this.cacheAsBitmap = false;
            this.cacheAsBitmap = true;
          }
        }
      },
      cacheAsBitmap: {
        get: function() {
          return this._cacheAsBitmap;
        },
        set: function(value) {
          if (this._cacheAsBitmap === value) {
            return;
          }
          this._cacheAsBitmap = value;
          var data;
          if (value) {
            if (!this._cacheData) {
              this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
          } else {
            data = this._cacheData;
            if (data.sprite) {
              this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
          }
        }
      }
    });
    display.DisplayObject.prototype._renderCached = function _renderCached(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObject(renderer);
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._render(renderer);
    };
    display.DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      renderer.batch.flush();
      var bounds = this.getLocalBounds(null, true).clone();
      if (this.filters) {
        var padding = this.filters[0].padding;
        bounds.pad(padding);
      }
      bounds.ceil(settings2.settings.RESOLUTION);
      var cachedRenderTexture = renderer.renderTexture.current;
      var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
      var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
      var cachedProjectionTransform = renderer.projection.transform;
      var renderTexture = core.RenderTexture.create({
        width: bounds.width,
        height: bounds.height,
        resolution: this.cacheAsBitmapResolution || renderer.resolution
      });
      var textureCacheId = "cacheAsBitmap_" + utils6.uid();
      this._cacheData.textureCacheId = textureCacheId;
      core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      core.Texture.addToCache(renderTexture, textureCacheId);
      var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
      this.render = this._cacheData.originalRender;
      renderer.render(this, {renderTexture, clear: true, transform: m2, skipUpdateTransform: false});
      renderer.projection.transform = cachedProjectionTransform;
      renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
      this.render = this._renderCached;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new sprite.Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.enableTempParent();
        this.updateTransform();
        this.disableTempParent(null);
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    display.DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObjectCanvas(renderer);
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._renderCanvas(renderer);
    };
    display.DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var bounds = this.getLocalBounds(null, true);
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      var cachedRenderTarget = renderer.context;
      var cachedProjectionTransform = renderer._projTransform;
      bounds.ceil(settings2.settings.RESOLUTION);
      var renderTexture = core.RenderTexture.create({width: bounds.width, height: bounds.height});
      var textureCacheId = "cacheAsBitmap_" + utils6.uid();
      this._cacheData.textureCacheId = textureCacheId;
      core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      core.Texture.addToCache(renderTexture, textureCacheId);
      var m2 = _tempMatrix;
      this.transform.localTransform.copyTo(m2);
      m2.invert();
      m2.tx -= bounds.x;
      m2.ty -= bounds.y;
      this.renderCanvas = this._cacheData.originalRenderCanvas;
      renderer.render(this, {renderTexture, clear: true, transform: m2, skipUpdateTransform: false});
      renderer.context = cachedRenderTarget;
      renderer._projTransform = cachedProjectionTransform;
      this.renderCanvas = this._renderCachedCanvas;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new sprite.Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    display.DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
      this._bounds.clear();
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite._calculateBounds();
      this._bounds.updateID = this._boundsID;
    };
    display.DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
      return this._cacheData.sprite.getLocalBounds(null);
    };
    display.DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
      this._cacheData.sprite._texture.destroy(true);
      this._cacheData.sprite = null;
      core.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
      core.Texture.removeFromCache(this._cacheData.textureCacheId);
      this._cacheData.textureCacheId = null;
    };
    display.DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
      this.cacheAsBitmap = false;
      this.destroy(options);
    };
    exports.CacheData = CacheData;
  });

  // node_modules/@pixi/mixin-get-child-by-name/dist/cjs/mixin-get-child-by-name.js
  var require_mixin_get_child_by_name = __commonJS(() => {
    /*!
     * @pixi/mixin-get-child-by-name - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/mixin-get-child-by-name is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    var display = require_display();
    display.DisplayObject.prototype.name = null;
    display.Container.prototype.getChildByName = function getChildByName(name, deep) {
      for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
        if (this.children[i2].name === name) {
          return this.children[i2];
        }
      }
      if (deep) {
        for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
          var child = this.children[i2];
          if (!child.getChildByName) {
            continue;
          }
          var target = this.children[i2].getChildByName(name, true);
          if (target) {
            return target;
          }
        }
      }
      return null;
    };
  });

  // node_modules/@pixi/mixin-get-global-position/dist/cjs/mixin-get-global-position.js
  var require_mixin_get_global_position = __commonJS(() => {
    /*!
     * @pixi/mixin-get-global-position - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/mixin-get-global-position is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    var display = require_display();
    var math = require_math();
    display.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
      if (point === void 0) {
        point = new math.Point();
      }
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (this.parent) {
        this.parent.toGlobal(this.position, point, skipUpdate);
      } else {
        point.x = this.position.x;
        point.y = this.position.y;
      }
      return point;
    };
  });

  // node_modules/@pixi/mesh-extras/dist/cjs/mesh-extras.js
  var require_mesh_extras = __commonJS((exports) => {
    /*!
     * @pixi/mesh-extras - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/mesh-extras is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var mesh = require_mesh();
    var constants = require_constants();
    var core = require_core();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var PlaneGeometry = function(_super) {
      __extends(PlaneGeometry2, _super);
      function PlaneGeometry2(width, height, segWidth, segHeight) {
        if (width === void 0) {
          width = 100;
        }
        if (height === void 0) {
          height = 100;
        }
        if (segWidth === void 0) {
          segWidth = 10;
        }
        if (segHeight === void 0) {
          segHeight = 10;
        }
        var _this = _super.call(this) || this;
        _this.segWidth = segWidth;
        _this.segHeight = segHeight;
        _this.width = width;
        _this.height = height;
        _this.build();
        return _this;
      }
      PlaneGeometry2.prototype.build = function() {
        var total = this.segWidth * this.segHeight;
        var verts = [];
        var uvs = [];
        var indices = [];
        var segmentsX = this.segWidth - 1;
        var segmentsY = this.segHeight - 1;
        var sizeX = this.width / segmentsX;
        var sizeY = this.height / segmentsY;
        for (var i2 = 0; i2 < total; i2++) {
          var x2 = i2 % this.segWidth;
          var y2 = i2 / this.segWidth | 0;
          verts.push(x2 * sizeX, y2 * sizeY);
          uvs.push(x2 / segmentsX, y2 / segmentsY);
        }
        var totalSub = segmentsX * segmentsY;
        for (var i2 = 0; i2 < totalSub; i2++) {
          var xpos = i2 % segmentsX;
          var ypos = i2 / segmentsX | 0;
          var value = ypos * this.segWidth + xpos;
          var value2 = ypos * this.segWidth + xpos + 1;
          var value3 = (ypos + 1) * this.segWidth + xpos;
          var value4 = (ypos + 1) * this.segWidth + xpos + 1;
          indices.push(value, value2, value3, value2, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      };
      return PlaneGeometry2;
    }(mesh.MeshGeometry);
    var RopeGeometry = function(_super) {
      __extends(RopeGeometry2, _super);
      function RopeGeometry2(width, points, textureScale) {
        if (width === void 0) {
          width = 200;
        }
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
        _this.points = points;
        _this._width = width;
        _this.textureScale = textureScale;
        _this.build();
        return _this;
      }
      Object.defineProperty(RopeGeometry2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      RopeGeometry2.prototype.build = function() {
        var points = this.points;
        if (!points) {
          return;
        }
        var vertexBuffer = this.getBuffer("aVertexPosition");
        var uvBuffer = this.getBuffer("aTextureCoord");
        var indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        var amount = 0;
        var prev = points[0];
        var textureWidth = this._width * this.textureScale;
        var total = points.length;
        for (var i2 = 0; i2 < total; i2++) {
          var index = i2 * 4;
          if (this.textureScale > 0) {
            var dx = prev.x - points[i2].x;
            var dy = prev.y - points[i2].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i2];
            amount += distance / textureWidth;
          } else {
            amount = i2 / (total - 1);
          }
          uvs[index] = amount;
          uvs[index + 1] = 0;
          uvs[index + 2] = amount;
          uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i2 = 0; i2 < total - 1; i2++) {
          var index = i2 * 2;
          indices[indexCount++] = index;
          indices[indexCount++] = index + 1;
          indices[indexCount++] = index + 2;
          indices[indexCount++] = index + 2;
          indices[indexCount++] = index + 1;
          indices[indexCount++] = index + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      };
      RopeGeometry2.prototype.updateVertices = function() {
        var points = this.points;
        if (points.length < 1) {
          return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i2 = 0; i2 < total; i2++) {
          var point = points[i2];
          var index = i2 * 4;
          if (i2 < points.length - 1) {
            nextPoint = points[i2 + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= num;
          perpY *= num;
          vertices[index] = point.x + perpX;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - perpX;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      };
      RopeGeometry2.prototype.update = function() {
        if (this.textureScale > 0) {
          this.build();
        } else {
          this.updateVertices();
        }
      };
      return RopeGeometry2;
    }(mesh.MeshGeometry);
    var SimpleRope = function(_super) {
      __extends(SimpleRope2, _super);
      function SimpleRope2(texture, points, textureScale) {
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = this;
        var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
        var meshMaterial = new mesh.MeshMaterial(texture);
        if (textureScale > 0) {
          texture.baseTexture.wrapMode = constants.WRAP_MODES.REPEAT;
        }
        _this = _super.call(this, ropeGeometry, meshMaterial) || this;
        _this.autoUpdate = true;
        return _this;
      }
      SimpleRope2.prototype._render = function(renderer) {
        var geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
          geometry._width = this.shader.texture.height;
          geometry.update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleRope2;
    }(mesh.Mesh);
    var SimplePlane = function(_super) {
      __extends(SimplePlane2, _super);
      function SimplePlane2(texture, verticesX, verticesY) {
        var _this = this;
        var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        var meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);
        _this = _super.call(this, planeGeometry, meshMaterial) || this;
        _this.texture = texture;
        return _this;
      }
      SimplePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        var geometry = this.geometry;
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      };
      Object.defineProperty(SimplePlane2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value) {
          if (this.shader.texture === value) {
            return;
          }
          this.shader.texture = value;
          this._textureID = -1;
          if (value.baseTexture.valid) {
            this.textureUpdated();
          } else {
            value.once("update", this.textureUpdated, this);
          }
        },
        enumerable: false,
        configurable: true
      });
      SimplePlane2.prototype._render = function(renderer) {
        if (this._textureID !== this.shader.texture._updateID) {
          this.textureUpdated();
        }
        _super.prototype._render.call(this, renderer);
      };
      SimplePlane2.prototype.destroy = function(options) {
        this.shader.texture.off("update", this.textureUpdated, this);
        _super.prototype.destroy.call(this, options);
      };
      return SimplePlane2;
    }(mesh.Mesh);
    var SimpleMesh = function(_super) {
      __extends(SimpleMesh2, _super);
      function SimpleMesh2(texture, vertices, uvs, indices, drawMode) {
        if (texture === void 0) {
          texture = core.Texture.EMPTY;
        }
        var _this = this;
        var geometry = new mesh.MeshGeometry(vertices, uvs, indices);
        geometry.getBuffer("aVertexPosition").static = false;
        var meshMaterial = new mesh.MeshMaterial(texture);
        _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
        _this.autoUpdate = true;
        return _this;
      }
      Object.defineProperty(SimpleMesh2.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value) {
          this.geometry.getBuffer("aVertexPosition").data = value;
        },
        enumerable: false,
        configurable: true
      });
      SimpleMesh2.prototype._render = function(renderer) {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aVertexPosition").update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleMesh2;
    }(mesh.Mesh);
    var DEFAULT_BORDER_SIZE = 10;
    var NineSlicePlane = function(_super) {
      __extends(NineSlicePlane2, _super);
      function NineSlicePlane2(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        if (leftWidth === void 0) {
          leftWidth = DEFAULT_BORDER_SIZE;
        }
        if (topHeight === void 0) {
          topHeight = DEFAULT_BORDER_SIZE;
        }
        if (rightWidth === void 0) {
          rightWidth = DEFAULT_BORDER_SIZE;
        }
        if (bottomHeight === void 0) {
          bottomHeight = DEFAULT_BORDER_SIZE;
        }
        var _this = _super.call(this, core.Texture.WHITE, 4, 4) || this;
        _this._origWidth = texture.orig.width;
        _this._origHeight = texture.orig.height;
        _this._width = _this._origWidth;
        _this._height = _this._origHeight;
        _this._leftWidth = leftWidth;
        _this._rightWidth = rightWidth;
        _this._topHeight = topHeight;
        _this._bottomHeight = bottomHeight;
        _this.texture = texture;
        return _this;
      }
      NineSlicePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
      };
      Object.defineProperty(NineSlicePlane2.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value) {
          this.geometry.getBuffer("aVertexPosition").data = value;
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane2.prototype.updateHorizontalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
      };
      NineSlicePlane2.prototype.updateVerticalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
      };
      NineSlicePlane2.prototype._getMinScale = function() {
        var w2 = this._leftWidth + this._rightWidth;
        var scaleW = this._width > w2 ? 1 : this._width / w2;
        var h2 = this._topHeight + this._bottomHeight;
        var scaleH = this._height > h2 ? 1 : this._height / h2;
        var scale = Math.min(scaleW, scaleH);
        return scale;
      };
      Object.defineProperty(NineSlicePlane2.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value) {
          this._width = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value) {
          this._height = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "leftWidth", {
        get: function() {
          return this._leftWidth;
        },
        set: function(value) {
          this._leftWidth = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "rightWidth", {
        get: function() {
          return this._rightWidth;
        },
        set: function(value) {
          this._rightWidth = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "topHeight", {
        get: function() {
          return this._topHeight;
        },
        set: function(value) {
          this._topHeight = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "bottomHeight", {
        get: function() {
          return this._bottomHeight;
        },
        set: function(value) {
          this._bottomHeight = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane2.prototype._refresh = function() {
        var texture = this.texture;
        var uvs = this.geometry.buffers[1].data;
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        var _uvw = 1 / this._origWidth;
        var _uvh = 1 / this._origHeight;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.updateHorizontalVertices();
        this.updateVerticalVertices();
        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
      };
      return NineSlicePlane2;
    }(SimplePlane);
    exports.NineSlicePlane = NineSlicePlane;
    exports.PlaneGeometry = PlaneGeometry;
    exports.RopeGeometry = RopeGeometry;
    exports.SimpleMesh = SimpleMesh;
    exports.SimplePlane = SimplePlane;
    exports.SimpleRope = SimpleRope;
  });

  // node_modules/@pixi/sprite-animated/dist/cjs/sprite-animated.js
  var require_sprite_animated = __commonJS((exports) => {
    /*!
     * @pixi/sprite-animated - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * @pixi/sprite-animated is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var core = require_core();
    var sprite = require_sprite();
    var ticker = require_ticker();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2)) {
            d3[p2] = b3[p2];
          }
        }
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var AnimatedSprite4 = function(_super) {
      __extends(AnimatedSprite5, _super);
      function AnimatedSprite5(textures, autoUpdate) {
        if (autoUpdate === void 0) {
          autoUpdate = true;
        }
        var _this = _super.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture) || this;
        _this._textures = null;
        _this._durations = null;
        _this._autoUpdate = autoUpdate;
        _this._isConnectedToTicker = false;
        _this.animationSpeed = 1;
        _this.loop = true;
        _this.updateAnchor = false;
        _this.onComplete = null;
        _this.onFrameChange = null;
        _this.onLoop = null;
        _this._currentTime = 0;
        _this._playing = false;
        _this._previousFrame = null;
        _this.textures = textures;
        return _this;
      }
      AnimatedSprite5.prototype.stop = function() {
        if (!this._playing) {
          return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
          ticker.Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      AnimatedSprite5.prototype.play = function() {
        if (this._playing) {
          return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
          ticker.Ticker.shared.add(this.update, this, ticker.UPDATE_PRIORITY.HIGH);
          this._isConnectedToTicker = true;
        }
      };
      AnimatedSprite5.prototype.gotoAndStop = function(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
      };
      AnimatedSprite5.prototype.gotoAndPlay = function(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
        this.play();
      };
      AnimatedSprite5.prototype.update = function(deltaTime) {
        if (!this._playing) {
          return;
        }
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
          var lag = this._currentTime % 1 * this._durations[this.currentFrame];
          lag += elapsed / 60 * 1e3;
          while (lag < 0) {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
          }
          var sign = Math.sign(this.animationSpeed * deltaTime);
          this._currentTime = Math.floor(this._currentTime);
          while (lag >= this._durations[this.currentFrame]) {
            lag -= this._durations[this.currentFrame] * sign;
            this._currentTime += sign;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
          this.gotoAndStop(0);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          this.gotoAndStop(this._textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (previousFrame !== this.currentFrame) {
          if (this.loop && this.onLoop) {
            if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
              this.onLoop();
            } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
              this.onLoop();
            }
          }
          this.updateTexture();
        }
      };
      AnimatedSprite5.prototype.updateTexture = function() {
        var currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
          return;
        }
        this._previousFrame = currentFrame;
        this._texture = this._textures[currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
          this._anchor.copyFrom(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
          this.onFrameChange(this.currentFrame);
        }
      };
      AnimatedSprite5.prototype.destroy = function(options) {
        this.stop();
        _super.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
      };
      AnimatedSprite5.fromFrames = function(frames) {
        var textures = [];
        for (var i2 = 0; i2 < frames.length; ++i2) {
          textures.push(core.Texture.from(frames[i2]));
        }
        return new AnimatedSprite5(textures);
      };
      AnimatedSprite5.fromImages = function(images) {
        var textures = [];
        for (var i2 = 0; i2 < images.length; ++i2) {
          textures.push(core.Texture.from(images[i2]));
        }
        return new AnimatedSprite5(textures);
      };
      Object.defineProperty(AnimatedSprite5.prototype, "totalFrames", {
        get: function() {
          return this._textures.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite5.prototype, "textures", {
        get: function() {
          return this._textures;
        },
        set: function(value) {
          if (value[0] instanceof core.Texture) {
            this._textures = value;
            this._durations = null;
          } else {
            this._textures = [];
            this._durations = [];
            for (var i2 = 0; i2 < value.length; i2++) {
              this._textures.push(value[i2].texture);
              this._durations.push(value[i2].time);
            }
          }
          this._previousFrame = null;
          this.gotoAndStop(0);
          this.updateTexture();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite5.prototype, "currentFrame", {
        get: function() {
          var currentFrame = Math.floor(this._currentTime) % this._textures.length;
          if (currentFrame < 0) {
            currentFrame += this._textures.length;
          }
          return currentFrame;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite5.prototype, "playing", {
        get: function() {
          return this._playing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite5.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              ticker.Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
              ticker.Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return AnimatedSprite5;
    }(sprite.Sprite);
    exports.AnimatedSprite = AnimatedSprite4;
  });

  // node_modules/pixi.js/dist/cjs/pixi.js
  var require_pixi = __commonJS((exports) => {
    /*!
     * pixi.js - v6.0.2
     * Compiled Mon, 05 Apr 2021 18:17:46 UTC
     *
     * pixi.js is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    require_polyfill();
    var utils6 = require_utils();
    var accessibility = require_accessibility();
    var interaction = require_interaction();
    var app = require_app();
    var core = require_core();
    var extract = require_extract();
    var loaders = require_loaders();
    var compressedTextures = require_compressed_textures();
    var particles = require_particles();
    var prepare = require_prepare();
    var spritesheet = require_spritesheet();
    var spriteTiling = require_sprite_tiling();
    var textBitmap = require_text_bitmap();
    var ticker = require_ticker();
    var filterAlpha = require_filter_alpha();
    var filterBlur = require_filter_blur();
    var filterColorMatrix = require_filter_color_matrix();
    var filterDisplacement = require_filter_displacement();
    var filterFxaa = require_filter_fxaa();
    var filterNoise = require_filter_noise();
    require_mixin_cache_as_bitmap();
    require_mixin_get_child_by_name();
    require_mixin_get_global_position();
    var constants = require_constants();
    var display = require_display();
    var graphics = require_graphics();
    var math = require_math();
    var mesh = require_mesh();
    var meshExtras = require_mesh_extras();
    var runner = require_runner();
    var sprite = require_sprite();
    var spriteAnimated = require_sprite_animated();
    var text = require_text();
    var settings2 = require_settings();
    core.Renderer.registerPlugin("accessibility", accessibility.AccessibilityManager);
    core.Renderer.registerPlugin("extract", extract.Extract);
    core.Renderer.registerPlugin("interaction", interaction.InteractionManager);
    core.Renderer.registerPlugin("particle", particles.ParticleRenderer);
    core.Renderer.registerPlugin("prepare", prepare.Prepare);
    core.Renderer.registerPlugin("batch", core.BatchRenderer);
    core.Renderer.registerPlugin("tilingSprite", spriteTiling.TilingSpriteRenderer);
    loaders.Loader.registerPlugin(textBitmap.BitmapFontLoader);
    loaders.Loader.registerPlugin(compressedTextures.CompressedTextureLoader);
    loaders.Loader.registerPlugin(compressedTextures.DDSLoader);
    loaders.Loader.registerPlugin(compressedTextures.KTXLoader);
    loaders.Loader.registerPlugin(spritesheet.SpritesheetLoader);
    app.Application.registerPlugin(ticker.TickerPlugin);
    app.Application.registerPlugin(loaders.AppLoaderPlugin);
    var VERSION2 = "6.0.2";
    var filters = {
      AlphaFilter: filterAlpha.AlphaFilter,
      BlurFilter: filterBlur.BlurFilter,
      BlurFilterPass: filterBlur.BlurFilterPass,
      ColorMatrixFilter: filterColorMatrix.ColorMatrixFilter,
      DisplacementFilter: filterDisplacement.DisplacementFilter,
      FXAAFilter: filterFxaa.FXAAFilter,
      NoiseFilter: filterNoise.NoiseFilter
    };
    Object.keys(accessibility).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return accessibility[k2];
          }
        });
    });
    Object.keys(interaction).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return interaction[k2];
          }
        });
    });
    Object.keys(app).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return app[k2];
          }
        });
    });
    Object.keys(core).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return core[k2];
          }
        });
    });
    Object.keys(extract).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return extract[k2];
          }
        });
    });
    Object.keys(loaders).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return loaders[k2];
          }
        });
    });
    Object.keys(compressedTextures).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return compressedTextures[k2];
          }
        });
    });
    Object.keys(particles).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return particles[k2];
          }
        });
    });
    Object.keys(prepare).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return prepare[k2];
          }
        });
    });
    Object.keys(spritesheet).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return spritesheet[k2];
          }
        });
    });
    Object.keys(spriteTiling).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return spriteTiling[k2];
          }
        });
    });
    Object.keys(textBitmap).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return textBitmap[k2];
          }
        });
    });
    Object.keys(ticker).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return ticker[k2];
          }
        });
    });
    Object.keys(constants).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return constants[k2];
          }
        });
    });
    Object.keys(display).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return display[k2];
          }
        });
    });
    Object.keys(graphics).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return graphics[k2];
          }
        });
    });
    Object.keys(math).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return math[k2];
          }
        });
    });
    Object.keys(mesh).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return mesh[k2];
          }
        });
    });
    Object.keys(meshExtras).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return meshExtras[k2];
          }
        });
    });
    Object.keys(runner).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return runner[k2];
          }
        });
    });
    Object.keys(sprite).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return sprite[k2];
          }
        });
    });
    Object.keys(spriteAnimated).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return spriteAnimated[k2];
          }
        });
    });
    Object.keys(text).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return text[k2];
          }
        });
    });
    Object.keys(settings2).forEach(function(k2) {
      if (k2 !== "default")
        Object.defineProperty(exports, k2, {
          enumerable: true,
          get: function() {
            return settings2[k2];
          }
        });
    });
    exports.utils = utils6;
    exports.VERSION = VERSION2;
    exports.filters = filters;
  });

  // node_modules/lodash.clonedeep/index.js
  var require_lodash = __commonJS((exports, module) => {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache2 = this.__data__;
      if (cache2 instanceof ListCache) {
        var pairs = cache2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache2 = this.__data__ = new MapCache(pairs);
      }
      cache2.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  });

  // node_modules/lodash.get/index.js
  var require_lodash2 = __commonJS((exports, module) => {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get2;
  });

  // node_modules/lodash.set/index.js
  var require_lodash3 = __commonJS((exports, module) => {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = isKey(path, object) ? [path] : castPath(path);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function set2(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    module.exports = set2;
  });

  // node_modules/yallist/iterator.js
  var require_iterator = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  });

  // node_modules/yallist/yallist.js
  var require_yallist = __commonJS((exports, module) => {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
          self2.push(arguments[i2]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        push(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        unshift(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i2 = 0; walker !== null; i2++) {
        fn.call(thisp, walker.value, i2, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
        fn.call(thisp, walker.value, i2, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n2) {
      for (var i2 = 0, walker = this.head; walker !== null && i2 < n2; i2++) {
        walker = walker.next;
      }
      if (i2 === n2 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n2) {
      for (var i2 = 0, walker = this.tail; walker !== null && i2 < n2; i2++) {
        walker = walker.prev;
      }
      if (i2 === n2 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = 0; walker !== null; i2++) {
        acc = fn(acc, walker.value, i2);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = this.length - 1; walker !== null; i2--) {
        acc = fn(acc, walker.value, i2);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.head; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
        walker = walker.next;
      }
      for (; walker !== null && i2 < to; i2++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
        walker = walker.prev;
      }
      for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i2 = 0; walker && i2 < deleteCount; i2++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i2 = 0; i2 < nodes.length; i2++) {
        walker = insert(this, walker, nodes[i2]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p2 = walker.prev;
        walker.prev = walker.next;
        walker.next = p2;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  });

  // node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS((exports, module) => {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = {max: options};
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k2) => k2.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k2) => k2.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h2) => h2);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l2 = arr.length - 1; l2 >= 0; l2--) {
          const hit = arr[l2];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  });

  // assets/scripts/helpers/RoomSpawner.class.js
  var require_RoomSpawner_class = __commonJS((exports, module) => {
    var _RoomSpawner = class {
      constructor(size = 10, options = {}) {
        this.floorSize = size;
        this.maxRooms = options.maxRooms || 10;
        this.minRooms = options.minRooms || 6;
        this.maxBoss = options.maxBoss || 1;
        this.specialRooms = options.specialRooms || 1;
        this.includeSecretRoom = options.includeSecretRoom || false;
        this.tileSize = options.tileSize || 16;
        this.roomWidth = (options.roomWidth || 10) * this.tileSize;
        this.roomHeight = (options.roomHeight || 10) * this.tileSize;
        this.reset();
      }
      get size() {
        return this.floorSize * this.floorSize;
      }
      reset() {
        this.started = false;
        this.endRoom = null;
        this.endRooms = [];
        this.cellQueue = [];
        this.floorPlan = [];
        for (let i2 = 0; i2 <= this.size; i2++) {
          this.floorPlan[i2] = 0;
        }
        this.floorPlanCount = 0;
        this.startPosition = Math.floor(this.size / 2 - this.floorSize / 2);
      }
      randomEndRoom() {
        const index = Math.floor(Math.random() * this.endRooms.length);
        const i2 = this.endRooms[index];
        this.endRooms.splice(index, 1);
        return i2;
      }
      isGivenRoomNeighbour(room, i2) {
        return room === i2 - 1 || room === i2 + 1 || room === i2 + this.floorSize || room === i2 - this.floorSize;
      }
      pickSecretRoom() {
        for (let tentative = 0; tentative < 900; tentative++) {
          const x2 = Math.floor(Math.random() * 9) + 1;
          const y2 = Math.floor(Math.random() * 8) + 2;
          const i2 = y2 * this.floorSize + x2;
          if (this.floorPlan[i2] || this.isGivenRoomNeighbour(this.endRoom, i2)) {
            continue;
          }
          const nCount = this.neighboursCount(i2);
          if (nCount >= 3 || tentative > 300 && nCount >= 2 || tentative > 600 && nCount >= 1) {
            return i2;
          }
        }
      }
      neighboursCount(i2) {
        return this.floorPlan[i2 - this.floorSize] + this.floorPlan[i2 - 1] + this.floorPlan[i2 + 1] + this.floorPlan[i2 + this.floorSize];
      }
      visit(i2) {
        if (this.floorPlan[i2]) {
          return false;
        }
        const neighbours = this.neighboursCount(i2);
        if (neighbours > 1 || this.floorPlanCount >= this.maxRooms || Math.random() < 0.5 && i2 !== this.startPosition) {
          return false;
        }
        this.cellQueue.push(i2);
        this.floorPlan[i2] = 1;
        this.floorPlanCount += 1;
        return true;
      }
      reDraw() {
        this.reset();
        this.draw();
      }
      draw() {
        if (this.started) {
          return;
        }
        this.started = true;
        this.visit(this.startPosition);
        while (this.cellQueue.length > 0) {
          const i2 = this.cellQueue.shift();
          const x2 = i2 % this.floorSize;
          let created = false;
          if (x2 > 1) {
            created = created | this.visit(i2 - 1);
          }
          if (x2 < 9) {
            created = created | this.visit(i2 + 1);
          }
          if (i2 > 20) {
            created = created | this.visit(i2 - this.floorSize);
          }
          if (i2 < 70) {
            created = created | this.visit(i2 + this.floorSize);
          }
          if (!created) {
            this.endRooms.push(i2);
          }
        }
        if (this.floorPlanCount < this.minRooms) {
          return this.reDraw();
        }
        for (let i2 = 0; i2 < this.maxBoss; i2++) {
          const bossRoom = this.endRooms.pop();
          if (!bossRoom) {
            return this.reDraw();
          }
          if (i2 === 0) {
            this.endRoom = bossRoom;
            this.floorPlan[bossRoom] = _RoomSpawner.EndRoom;
          } else {
            this.floorPlan[bossRoom] = _RoomSpawner.BossRoom;
          }
        }
        for (let i2 = 0; i2 < this.specialRooms; i2++) {
          const position = this.randomEndRoom();
          if (!position) {
            return this.reDraw();
          }
          this.floorPlan[position] = _RoomSpawner.SpecialRoom;
        }
        if (this.includeSecretRoom) {
          const secretRoom = this.pickSecretRoom();
          if (!secretRoom) {
            return this.reDraw();
          }
          this.floorPlan[secretRoom] = _RoomSpawner.SecretRoom;
        }
        this.floorPlan[this.startPosition] = _RoomSpawner.StartRoom;
      }
      print() {
        for (let i2 = 0; i2 < this.size; i2++) {
          if (i2 % this.floorSize === 0) {
            process.stdout.write("\n");
          }
          const kind = this.floorPlan[i2];
          process.stdout.write((kind === 0 ? " " : String(kind)) + " ");
        }
      }
      getNeighboursNodes(i2) {
        return {
          top: this.floorPlan[i2 - this.floorSize],
          left: this.floorPlan[i2 - 1],
          right: this.floorPlan[i2 + 1],
          bottom: this.floorPlan[i2 + this.floorSize]
        };
      }
      *explore(i2, x2, y2, visitedNodes) {
        if (visitedNodes.has(i2)) {
          return;
        }
        visitedNodes.add(i2);
        const neighbours = this.getNeighboursNodes(i2);
        const hasLeft = neighbours.left !== 0;
        const hasRight = neighbours.right !== 0;
        const hasTop = neighbours.top !== 0;
        const hasBottom = neighbours.bottom !== 0;
        yield {
          x: x2,
          y: y2,
          doors: [hasTop, hasRight, hasBottom, hasLeft],
          type: _RoomSpawner.RoomName[this.floorPlan[i2]]
        };
        if (hasLeft) {
          yield* this.explore(i2 - 1, x2 - this.roomWidth, y2, visitedNodes);
        }
        if (hasRight) {
          yield* this.explore(i2 + 1, x2 + this.roomWidth, y2, visitedNodes);
        }
        if (hasTop) {
          yield* this.explore(i2 - this.floorSize, x2, y2 + this.roomHeight, visitedNodes);
        }
        if (hasBottom) {
          yield* this.explore(i2 + this.floorSize, x2, y2 - this.roomHeight, visitedNodes);
        }
      }
      *getWorldRooms() {
        const visited = new Set();
        try {
          yield* this.explore(this.startPosition, 0, 0, visited);
        } finally {
          visited.clear();
        }
      }
    };
    var RoomSpawner2 = _RoomSpawner;
    __publicField(RoomSpawner2, "BossRoom", "B");
    __publicField(RoomSpawner2, "SecretRoom", "S");
    __publicField(RoomSpawner2, "EndRoom", "E");
    __publicField(RoomSpawner2, "SpecialRoom", "L");
    __publicField(RoomSpawner2, "StartRoom", "X");
    __publicField(RoomSpawner2, "RoomName", Object.freeze({
      [_RoomSpawner.BossRoom]: "boss",
      [_RoomSpawner.SecretRoom]: "secret",
      [_RoomSpawner.EndRoom]: "end",
      [_RoomSpawner.SpecialRoom]: "special",
      [_RoomSpawner.StartRoom]: "start",
      1: "room"
    }));
    module.exports = RoomSpawner2;
  });

  // node_modules/pixi-layers/dist/pixi-layers.js
  var require_pixi_layers = __commonJS((exports) => {
    var pixi_display;
    (function(pixi_display2) {
      Object.assign(PIXI.Container.prototype, {
        render: function(renderer) {
          if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer) {
            return;
          }
          if (!this.visible) {
            this.displayOrder = 0;
            return;
          }
          this.displayOrder = renderer.incDisplayOrder();
          if (this.worldAlpha <= 0 || !this.renderable) {
            return;
          }
          renderer._activeLayer = null;
          this.containerRenderWebGL(renderer);
          renderer._activeLayer = this._activeParentLayer;
        },
        renderCanvas: function(renderer) {
          if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer) {
            return;
          }
          if (!this.visible) {
            this.displayOrder = 0;
            return;
          }
          this.displayOrder = renderer.incDisplayOrder();
          if (this.worldAlpha <= 0 || !this.renderable) {
            return;
          }
          renderer._activeLayer = null;
          this.containerRenderCanvas(renderer);
          renderer._activeLayer = this._activeParentLayer;
        },
        containerRenderWebGL: PIXI.Container.prototype.render,
        containerRenderCanvas: PIXI.Container.prototype.renderCanvas
      });
    })(pixi_display || (pixi_display = {}));
    Object.assign(PIXI.DisplayObject.prototype, {
      parentLayer: null,
      _activeParentLayer: null,
      parentGroup: null,
      zOrder: 0,
      zIndex: 0,
      updateOrder: 0,
      displayOrder: 0,
      layerableChildren: true,
      isLayer: false
    });
    if (PIXI.ParticleContainer) {
      PIXI.ParticleContainer.prototype.layerableChildren = false;
    } else if (PIXI.ParticleContainer) {
      PIXI.ParticleContainer.prototype.layerableChildren = false;
    }
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (b3.hasOwnProperty(p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var pixi_display;
    (function(pixi_display2) {
      var utils6 = PIXI.utils;
      var Group = function(_super) {
        __extends(Group2, _super);
        function Group2(zIndex, sorting) {
          var _this = _super.call(this) || this;
          _this._activeLayer = null;
          _this._activeStage = null;
          _this._activeChildren = [];
          _this._lastUpdateId = -1;
          _this.useRenderTexture = false;
          _this.useDoubleBuffer = false;
          _this.sortPriority = 0;
          _this.clearColor = new Float32Array([0, 0, 0, 0]);
          _this.canDrawWithoutLayer = false;
          _this.canDrawInParentStage = true;
          _this.zIndex = 0;
          _this.enableSort = false;
          _this._tempResult = [];
          _this._tempZero = [];
          _this.useZeroOptimization = false;
          _this.zIndex = zIndex;
          _this.enableSort = !!sorting;
          if (typeof sorting === "function") {
            _this.on("sort", sorting);
          }
          return _this;
        }
        Group2.prototype.doSort = function(layer, sorted) {
          if (this.listeners("sort", true)) {
            for (var i2 = 0; i2 < sorted.length; i2++) {
              this.emit("sort", sorted[i2]);
            }
          }
          if (this.useZeroOptimization) {
            this.doSortWithZeroOptimization(layer, sorted);
          } else {
            sorted.sort(Group2.compareZIndex);
          }
        };
        Group2.compareZIndex = function(a2, b2) {
          if (a2.zOrder < b2.zOrder) {
            return -1;
          }
          if (a2.zOrder > b2.zOrder) {
            return 1;
          }
          return a2.updateOrder - b2.updateOrder;
        };
        Group2.prototype.doSortWithZeroOptimization = function(layer, sorted) {
          throw new Error("not implemented yet");
        };
        Group2.prototype.clear = function() {
          this._activeLayer = null;
          this._activeStage = null;
          this._activeChildren.length = 0;
        };
        Group2.prototype.addDisplayObject = function(stage, displayObject) {
          this.check(stage);
          displayObject._activeParentLayer = this._activeLayer;
          if (this._activeLayer) {
            this._activeLayer._activeChildren.push(displayObject);
          } else {
            this._activeChildren.push(displayObject);
          }
        };
        Group2.prototype.foundLayer = function(stage, layer) {
          this.check(stage);
          if (this._activeLayer != null) {
            Group2.conflict();
          }
          this._activeLayer = layer;
          this._activeStage = stage;
        };
        Group2.prototype.foundStage = function(stage) {
          if (!this._activeLayer && !this.canDrawInParentStage) {
            this.clear();
          }
        };
        Group2.prototype.check = function(stage) {
          if (this._lastUpdateId < Group2._layerUpdateId) {
            this._lastUpdateId = Group2._layerUpdateId;
            this.clear();
            this._activeStage = stage;
          } else if (this.canDrawInParentStage) {
            var current = this._activeStage;
            while (current && current != stage) {
              current = current._activeParentStage;
            }
            this._activeStage = current;
            if (current == null) {
              this.clear();
              return;
            }
          }
        };
        Group2.conflict = function() {
          if (Group2._lastLayerConflict + 5e3 < Date.now()) {
            Group2._lastLayerConflict = Date.now();
            console.log("PIXI-display plugin found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it");
          }
        };
        Group2._layerUpdateId = 0;
        Group2._lastLayerConflict = 0;
        return Group2;
      }(utils6.EventEmitter);
      pixi_display2.Group = Group;
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      function processInteractive51(strangeStuff, displayObject, func, hitTest, interactive) {
        if (!this.search) {
          this.search = new pixi_display2.LayersTreeSearch();
        }
        this.search.findHit(strangeStuff, displayObject, func, hitTest);
        var delayedEvents = this.delayedEvents;
        if (delayedEvents && delayedEvents.length) {
          strangeStuff.stopPropagationHint = false;
          var delayedLen = delayedEvents.length;
          this.delayedEvents = [];
          for (var i2 = 0; i2 < delayedLen; i2++) {
            var _a = delayedEvents[i2], displayObject_1 = _a.displayObject, eventString = _a.eventString, eventData = _a.eventData;
            if (eventData.stopsPropagatingAt === displayObject_1) {
              eventData.stopPropagationHint = true;
            }
            this.dispatchEvent(displayObject_1, eventString, eventData);
          }
        }
      }
      pixi_display2.processInteractive51 = processInteractive51;
      function patchInteractionManager(interactionManager) {
        if (!interactionManager) {
          return;
        }
        if (interactionManager.search) {
          if (!interactionManager.search.worksWithDisplay) {
            interactionManager.search = new pixi_display2.LayersTreeSearch();
          }
        } else {
          interactionManager.processInteractive = processInteractive51;
        }
      }
      pixi_display2.patchInteractionManager = patchInteractionManager;
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      var LayerTextureCache = function() {
        function LayerTextureCache2(layer) {
          this.layer = layer;
          this.renderTexture = null;
          this.doubleBuffer = null;
          this.currentBufferIndex = 0;
          this._tempRenderTarget = null;
          this._tempRenderTargetSource = new PIXI.Rectangle();
        }
        LayerTextureCache2.prototype.initRenderTexture = function(renderer) {
          var width = renderer ? renderer.screen.width : 100;
          var height = renderer ? renderer.screen.height : 100;
          var resolution = renderer ? renderer.resolution : PIXI.settings.RESOLUTION;
          this.renderTexture = PIXI.RenderTexture.create({width, height, resolution});
          if (this.layer.group.useDoubleBuffer) {
            this.doubleBuffer = [
              PIXI.RenderTexture.create({width, height, resolution}),
              PIXI.RenderTexture.create({width, height, resolution})
            ];
          }
        };
        LayerTextureCache2.prototype.getRenderTexture = function() {
          if (!this.renderTexture) {
            this.initRenderTexture();
          }
          return this.renderTexture;
        };
        LayerTextureCache2.prototype.pushTexture = function(renderer) {
          var screen = renderer.screen;
          if (!this.renderTexture) {
            this.initRenderTexture(renderer);
          }
          var rt = this.renderTexture;
          var group = this.layer.group;
          var db = this.doubleBuffer;
          if (rt.width !== screen.width || rt.height !== screen.height || rt.baseTexture.resolution !== renderer.resolution) {
            rt.baseTexture.resolution = renderer.resolution;
            rt.resize(screen.width, screen.height);
            if (db) {
              db[0].baseTexture.resolution = renderer.resolution;
              db[0].resize(screen.width, screen.height);
              db[1].baseTexture.resolution = renderer.resolution;
              db[1].resize(screen.width, screen.height);
            }
          }
          this._tempRenderTarget = renderer.renderTexture.current;
          this._tempRenderTargetSource.copyFrom(renderer.renderTexture.sourceFrame);
          renderer.batch.flush();
          if (group.useDoubleBuffer) {
            var buffer = db[this.currentBufferIndex];
            if (!buffer.baseTexture._glTextures[renderer.CONTEXT_UID]) {
              renderer.renderTexture.bind(buffer, void 0, void 0);
              renderer.texture.bind(buffer);
              if (group.clearColor) {
                renderer.renderTexture.clear(group.clearColor);
              }
            }
            renderer.texture.unbind(rt.baseTexture);
            rt.baseTexture._glTextures = buffer.baseTexture._glTextures;
            rt.baseTexture.framebuffer = buffer.baseTexture.framebuffer;
            buffer = db[1 - this.currentBufferIndex];
            renderer.renderTexture.bind(buffer, void 0, void 0);
          } else {
            renderer.renderTexture.bind(rt, void 0, void 0);
          }
          if (group.clearColor) {
            renderer.renderTexture.clear(group.clearColor);
          }
          var filterStack = renderer.filter.defaultFilterStack;
          if (filterStack.length > 1) {
            filterStack[filterStack.length - 1].renderTexture = renderer.renderTexture.current;
          }
        };
        LayerTextureCache2.prototype.popTexture = function(renderer) {
          renderer.batch.flush();
          var filterStack = renderer.filter.defaultFilterStack;
          if (filterStack.length > 1) {
            filterStack[filterStack.length - 1].renderTexture = this._tempRenderTarget;
          }
          renderer.renderTexture.bind(this._tempRenderTarget, this._tempRenderTargetSource, void 0);
          this._tempRenderTarget = null;
          var rt = this.renderTexture;
          var group = this.layer.group;
          var db = this.doubleBuffer;
          if (group.useDoubleBuffer) {
            renderer.texture.unbind(rt.baseTexture);
            this.currentBufferIndex = 1 - this.currentBufferIndex;
            var buffer = db[this.currentBufferIndex];
            rt.baseTexture._glTextures = buffer.baseTexture._glTextures;
            rt.baseTexture.framebuffer = buffer.baseTexture.framebuffer;
          }
        };
        LayerTextureCache2.prototype.destroy = function() {
          if (this.renderTexture) {
            this.renderTexture.destroy();
            if (this.doubleBuffer) {
              this.doubleBuffer[0].destroy(true);
              this.doubleBuffer[1].destroy(true);
            }
          }
        };
        return LayerTextureCache2;
      }();
      pixi_display2.LayerTextureCache = LayerTextureCache;
      var Layer = function(_super) {
        __extends(Layer2, _super);
        function Layer2(group) {
          if (group === void 0) {
            group = null;
          }
          var _this = _super.call(this) || this;
          _this.isLayer = true;
          _this.group = null;
          _this._activeChildren = [];
          _this._tempChildren = null;
          _this._activeStageParent = null;
          _this._sortedChildren = [];
          _this._tempLayerParent = null;
          _this.insertChildrenBeforeActive = true;
          _this.insertChildrenAfterActive = true;
          if (group != null) {
            _this.group = group;
            _this.zIndex = group.zIndex;
          } else {
            _this.group = new pixi_display2.Group(0, false);
          }
          _this._tempChildren = _this.children;
          return _this;
        }
        Layer2.prototype.beginWork = function(stage) {
          var active = this._activeChildren;
          this._activeStageParent = stage;
          this.group.foundLayer(stage, this);
          var groupChildren = this.group._activeChildren;
          active.length = 0;
          for (var i2 = 0; i2 < groupChildren.length; i2++) {
            groupChildren[i2]._activeParentLayer = this;
            active.push(groupChildren[i2]);
          }
          groupChildren.length = 0;
        };
        Layer2.prototype.endWork = function() {
          var children = this.children;
          var active = this._activeChildren;
          var sorted = this._sortedChildren;
          for (var i2 = 0; i2 < active.length; i2++) {
            this.emit("display", active[i2]);
          }
          sorted.length = 0;
          if (this.insertChildrenBeforeActive) {
            for (var i2 = 0; i2 < children.length; i2++) {
              sorted.push(children[i2]);
            }
          }
          for (var i2 = 0; i2 < active.length; i2++) {
            sorted.push(active[i2]);
          }
          if (!this.insertChildrenBeforeActive && this.insertChildrenAfterActive) {
            for (var i2 = 0; i2 < children.length; i2++) {
              sorted.push(children[i2]);
            }
          }
          if (this.group.enableSort) {
            this.doSort();
          }
        };
        Object.defineProperty(Layer2.prototype, "useRenderTexture", {
          get: function() {
            return this.group.useRenderTexture;
          },
          set: function(value) {
            this.group.useRenderTexture = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Layer2.prototype, "useDoubleBuffer", {
          get: function() {
            return this.group.useDoubleBuffer;
          },
          set: function(value) {
            this.group.useDoubleBuffer = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Layer2.prototype, "clearColor", {
          get: function() {
            return this.group.clearColor;
          },
          set: function(value) {
            this.group.clearColor = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Layer2.prototype, "sortPriority", {
          get: function() {
            return this.group.sortPriority;
          },
          set: function(value) {
            this.group.sortPriority = value;
          },
          enumerable: false,
          configurable: true
        });
        Layer2.prototype.getRenderTexture = function() {
          if (!this.textureCache) {
            this.textureCache = new LayerTextureCache(this);
          }
          return this.textureCache.getRenderTexture();
        };
        Layer2.prototype.updateDisplayLayers = function() {
        };
        Layer2.prototype.doSort = function() {
          this.group.doSort(this, this._sortedChildren);
        };
        Layer2.prototype._preRender = function(renderer) {
          if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer) {
            return false;
          }
          if (!this.visible) {
            this.displayOrder = 0;
            return false;
          }
          this.displayOrder = renderer.incDisplayOrder();
          if (this.worldAlpha <= 0 || !this.renderable) {
            return false;
          }
          if (this.children !== this._sortedChildren && this._tempChildren != this.children) {
            this._tempChildren = this.children;
          }
          this._boundsID++;
          this.children = this._sortedChildren;
          this._tempLayerParent = renderer._activeLayer;
          renderer._activeLayer = this;
          return true;
        };
        Layer2.prototype._postRender = function(renderer) {
          this.children = this._tempChildren;
          renderer._activeLayer = this._tempLayerParent;
          this._tempLayerParent = null;
        };
        Layer2.prototype.render = function(renderer) {
          if (!this._preRender(renderer)) {
            return;
          }
          if (this.group.useRenderTexture) {
            if (!this.textureCache) {
              this.textureCache = new LayerTextureCache(this);
            }
            this.textureCache.pushTexture(renderer);
          }
          this.containerRenderWebGL(renderer);
          this._postRender(renderer);
          if (this.group.useRenderTexture) {
            this.textureCache.popTexture(renderer);
          }
        };
        Layer2.prototype.destroy = function(options) {
          if (this.textureCache) {
            this.textureCache.destroy();
            this.textureCache = null;
          }
          _super.prototype.destroy.call(this, options);
        };
        return Layer2;
      }(PIXI.Container);
      pixi_display2.Layer = Layer;
      Layer.prototype.renderCanvas = function(renderer) {
        if (this._preRender(renderer)) {
          this.containerRenderCanvas(renderer);
          this._postRender(renderer);
        }
      };
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      var Point2 = PIXI.Point;
      var LayersTreeSearch = function() {
        function LayersTreeSearch2() {
          this._tempPoint = new Point2();
          this._queue = [[], []];
          this._eventDisplayOrder = 0;
          this.worksWithDisplay = true;
        }
        LayersTreeSearch2.prototype.recursiveFindHit = function(point, displayObject, hitTestOrder, interactive, outOfMask) {
          if (!displayObject || !displayObject.visible) {
            return 0;
          }
          var hit = 0, interactiveParent = interactive = displayObject.interactive || interactive;
          if (displayObject.hitArea) {
            interactiveParent = false;
          }
          if (displayObject._activeParentLayer) {
            outOfMask = false;
          }
          var mask = displayObject._mask;
          if (hitTestOrder < Infinity && mask) {
            if (!mask.containsPoint(point)) {
              outOfMask = true;
            }
          }
          if (hitTestOrder < Infinity && displayObject.filterArea) {
            if (!displayObject.filterArea.contains(point.x, point.y)) {
              outOfMask = true;
            }
          }
          var children = displayObject.children;
          if (displayObject.interactiveChildren && children) {
            for (var i2 = children.length - 1; i2 >= 0; i2--) {
              var child = children[i2];
              var hitChild = this.recursiveFindHit(point, child, hitTestOrder, interactiveParent, outOfMask);
              if (hitChild) {
                if (!child.parent) {
                  continue;
                }
                hit = hitChild;
                hitTestOrder = hitChild;
              }
            }
          }
          if (interactive) {
            if (!outOfMask) {
              if (hitTestOrder < displayObject.displayOrder) {
                if (displayObject.hitArea) {
                  displayObject.worldTransform.applyInverse(point, this._tempPoint);
                  if (displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hit = displayObject.displayOrder;
                  }
                } else if (displayObject.containsPoint) {
                  if (displayObject.containsPoint(point)) {
                    hit = displayObject.displayOrder;
                  }
                }
              }
              if (displayObject.interactive) {
                this._queueAdd(displayObject, hit === Infinity ? 0 : hit);
              }
            } else {
              if (displayObject.interactive) {
                this._queueAdd(displayObject, 0);
              }
            }
          }
          return hit;
        };
        LayersTreeSearch2.prototype.findHit = function(strangeStuff, displayObject, func, hitTest) {
          var interactionEvent = null;
          var point = null;
          if (strangeStuff.data && strangeStuff.data.global) {
            interactionEvent = strangeStuff;
            point = interactionEvent.data.global;
          } else {
            point = strangeStuff;
          }
          this._startInteractionProcess();
          this.recursiveFindHit(point, displayObject, hitTest ? 0 : Infinity, false, false);
          this._finishInteractionProcess(interactionEvent, func);
        };
        LayersTreeSearch2.prototype._startInteractionProcess = function() {
          this._eventDisplayOrder = 1;
          if (!this._queue) {
            this._queue = [[], []];
          }
          this._queue[0].length = 0;
          this._queue[1].length = 0;
        };
        LayersTreeSearch2.prototype._queueAdd = function(displayObject, order) {
          var queue = this._queue;
          if (order < this._eventDisplayOrder) {
            queue[0].push(displayObject);
          } else {
            if (order > this._eventDisplayOrder) {
              this._eventDisplayOrder = order;
              var q = queue[1];
              for (var i2 = 0, l2 = q.length; i2 < l2; i2++) {
                queue[0].push(q[i2]);
              }
              queue[1].length = 0;
            }
            queue[1].push(displayObject);
          }
        };
        LayersTreeSearch2.prototype._finishInteractionProcess = function(event, func) {
          var queue = this._queue;
          var q = queue[0];
          for (var i2 = 0, l2 = q.length; i2 < l2; i2++) {
            if (event) {
              if (func) {
                func(event, q[i2], false);
              }
            } else {
              func(q[i2], false);
            }
          }
          q = queue[1];
          for (var i2 = 0, l2 = q.length; i2 < l2; i2++) {
            if (event) {
              if (!event.target) {
                event.target = q[i2];
              }
              if (func) {
                func(event, q[i2], true);
              }
            } else {
              func(q[i2], true);
            }
          }
        };
        return LayersTreeSearch2;
      }();
      pixi_display2.LayersTreeSearch = LayersTreeSearch;
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      var Stage = function(_super) {
        __extends(Stage2, _super);
        function Stage2() {
          var _this = _super.call(this) || this;
          _this.isStage = true;
          _this._tempGroups = [];
          _this._activeLayers = [];
          _this._activeParentStage = null;
          return _this;
        }
        Stage2.prototype.clear = function() {
          this._activeLayers.length = 0;
          this._tempGroups.length = 0;
        };
        Stage2.prototype.destroy = function(options) {
          this.clear();
          _super.prototype.destroy.call(this, options);
        };
        Stage2.prototype._addRecursive = function(displayObject) {
          if (!displayObject.visible) {
            return;
          }
          if (displayObject.isLayer) {
            var layer_1 = displayObject;
            this._activeLayers.push(layer_1);
            layer_1.beginWork(this);
          }
          if (displayObject != this && displayObject.isStage) {
            var stage = displayObject;
            stage.updateAsChildStage(this);
            return;
          }
          var group = displayObject.parentGroup;
          if (group != null) {
            group.addDisplayObject(this, displayObject);
          }
          var layer = displayObject.parentLayer;
          if (layer != null) {
            group = layer.group;
            group.addDisplayObject(this, displayObject);
          }
          displayObject.updateOrder = ++Stage2._updateOrderCounter;
          if (displayObject.alpha <= 0 || !displayObject.renderable || !displayObject.layerableChildren || group && group.sortPriority) {
            return;
          }
          var children = displayObject.children;
          if (children && children.length) {
            for (var i2 = 0; i2 < children.length; i2++) {
              this._addRecursive(children[i2]);
            }
          }
        };
        Stage2.prototype._addRecursiveChildren = function(displayObject) {
          if (displayObject.alpha <= 0 || !displayObject.renderable || !displayObject.layerableChildren) {
            return;
          }
          var children = displayObject.children;
          if (children && children.length) {
            for (var i2 = 0; i2 < children.length; i2++) {
              this._addRecursive(children[i2]);
            }
          }
        };
        Stage2.prototype._updateStageInner = function() {
          this.clear();
          this._addRecursive(this);
          var layers = this._activeLayers;
          for (var i2 = 0; i2 < layers.length; i2++) {
            var layer = layers[i2];
            if (layer.group.sortPriority) {
              layer.endWork();
              var sorted = layer._sortedChildren;
              for (var j2 = 0; j2 < sorted.length; j2++) {
                this._addRecursiveChildren(sorted[j2]);
              }
            }
          }
          for (var i2 = 0; i2 < layers.length; i2++) {
            var layer = layers[i2];
            if (!layer.group.sortPriority) {
              layer.endWork();
            }
          }
        };
        Stage2.prototype.updateAsChildStage = function(stage) {
          this._activeParentStage = stage;
          Stage2._updateOrderCounter = 0;
          this._updateStageInner();
        };
        Stage2.prototype.updateStage = function() {
          this._activeParentStage = null;
          pixi_display2.Group._layerUpdateId++;
          this._updateStageInner();
        };
        ;
        Stage2._updateOrderCounter = 0;
        return Stage2;
      }(pixi_display2.Layer);
      pixi_display2.Stage = Stage;
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      Object.assign(PIXI.Renderer.prototype, {
        _lastDisplayOrder: 0,
        _activeLayer: null,
        incDisplayOrder: function() {
          return ++this._lastDisplayOrder;
        },
        _oldRender: PIXI.Renderer.prototype.render,
        render: function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
          if (!renderTexture) {
            this._lastDisplayOrder = 0;
          }
          this._activeLayer = null;
          if (displayObject.isStage) {
            displayObject.updateStage();
          }
          pixi_display2.patchInteractionManager(this.plugins.interaction);
          this._oldRender(displayObject, renderTexture, clear, transform, skipUpdateTransform);
        }
      });
      var canvasRenderer = PIXI.CanvasRenderer;
      if (canvasRenderer) {
        Object.assign(canvasRenderer.prototype, {
          _lastDisplayOrder: 0,
          _activeLayer: null,
          incDisplayOrder: function() {
            return ++this._lastDisplayOrder;
          },
          _oldRender: canvasRenderer.prototype.render,
          render: function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
            if (!renderTexture) {
              this._lastDisplayOrder = 0;
            }
            this._activeLayer = null;
            if (displayObject.isStage) {
              displayObject.updateStage();
            }
            pixi_display2.patchInteractionManager(this.plugins.interaction);
            this._oldRender(displayObject, renderTexture, clear, transform, skipUpdateTransform);
          }
        });
      }
    })(pixi_display || (pixi_display = {}));
    var pixi_display;
    (function(pixi_display2) {
      PIXI.display = pixi_display2;
    })(pixi_display || (pixi_display = {}));
  });

  // node_modules/@pixi/sound/dist/pixi-sound.esm.js
  var import_loaders = __toModule(require_loaders());
  var import_utils = __toModule(require_utils());
  var import_ticker = __toModule(require_ticker());
  var import_core = __toModule(require_core());
  /*!
   * @pixi/sound - v4.0.1
   * https://github.com/pixijs/pixi-sound
   * Compiled Thu, 08 Apr 2021 19:48:35 UTC
   *
   * @pixi/sound is licensed under the MIT license.
   * http://www.opensource.org/licenses/mit-license
   */
  var r;
  function s2() {
    return r;
  }
  var u = function(t2, e2) {
    return (u = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var n2 in e3)
        Object.prototype.hasOwnProperty.call(e3, n2) && (t3[n2] = e3[n2]);
    })(t2, e2);
  };
  function a(t2, e2) {
    if (typeof e2 != "function" && e2 !== null)
      throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
    function n2() {
      this.constructor = t2;
    }
    u(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
  }
  var c = function() {
    return (c = Object.assign || function(t2) {
      for (var e2, n2 = 1, o2 = arguments.length; n2 < o2; n2++)
        for (var i2 in e2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
      return t2;
    }).apply(this, arguments);
  };
  var p = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"];
  var h = {};
  function l(t2) {
    var e2 = c({m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"'}, t2 || {}), n2 = document.createElement("audio"), o2 = {}, i2 = /^no$/;
    p.forEach(function(t3) {
      var r2 = n2.canPlayType("audio/" + t3).replace(i2, ""), s3 = e2[t3] ? n2.canPlayType(e2[t3]).replace(i2, "") : "";
      o2[t3] = !!r2 || !!s3;
    }), Object.assign(h, o2);
  }
  l();
  var d = /\.(\{([^\}]+)\})(\?.*)?$/;
  function f(t2) {
    var e2 = d, n2 = typeof t2 == "string" ? t2 : t2.url;
    if (!e2.test(n2))
      return n2;
    for (var o2 = e2.exec(n2), i2 = o2[2].split(","), r2 = i2[i2.length - 1], s3 = 0, u2 = i2.length; s3 < u2; s3++) {
      var a2 = i2[s3];
      if (h[a2]) {
        r2 = a2;
        break;
      }
    }
    var c2 = n2.replace(o2[1], r2);
    if (typeof t2 != "string") {
      var p2 = t2;
      p2.extension = r2, p2.url = c2;
    }
    return c2;
  }
  var _ = function() {
    function e2() {
    }
    return e2.add = function() {
      e2.setLegacy(s2().useLegacy);
    }, e2.setLegacy = function(e3) {
      var n2 = p;
      e3 ? n2.forEach(function(e4) {
        import_loaders.LoaderResource.setExtensionXhrType(e4, import_loaders.LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), import_loaders.LoaderResource.setExtensionLoadType(e4, import_loaders.LoaderResource.LOAD_TYPE.AUDIO);
      }) : n2.forEach(function(e4) {
        import_loaders.LoaderResource.setExtensionXhrType(e4, import_loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER), import_loaders.LoaderResource.setExtensionLoadType(e4, import_loaders.LoaderResource.LOAD_TYPE.XHR);
      });
    }, e2.pre = function(t2, e3) {
      f(t2), e3();
    }, e2.use = function(t2, e3) {
      t2.data && p.indexOf(t2.extension) > -1 ? t2.sound = s2().add(t2.name, {loaded: e3, preload: true, url: t2.url, source: t2.data}) : e3();
    }, e2;
  }();
  var y = 0;
  var m = function(t2) {
    function e2(e3) {
      var n2 = t2.call(this) || this;
      return n2.id = y++, n2.init(e3), n2;
    }
    return a(e2, t2), e2.prototype.set = function(t3, e3) {
      if (this[t3] === void 0)
        throw new Error("Property with name " + t3 + " does not exist.");
      switch (t3) {
        case "speed":
          this.speed = e3;
          break;
        case "volume":
          this.volume = e3;
          break;
        case "paused":
          this.paused = e3;
          break;
        case "loop":
          this.loop = e3;
          break;
        case "muted":
          this.muted = e3;
      }
      return this;
    }, Object.defineProperty(e2.prototype, "progress", {get: function() {
      return this._source.currentTime / this._duration;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "paused", {get: function() {
      return this._paused;
    }, set: function(t3) {
      this._paused = t3, this.refreshPaused();
    }, enumerable: false, configurable: true}), e2.prototype._onPlay = function() {
      this._playing = true;
    }, e2.prototype._onPause = function() {
      this._playing = false;
    }, e2.prototype.init = function(t3) {
      this._playing = false, this._duration = t3.source.duration;
      var e3 = this._source = t3.source.cloneNode(false);
      e3.src = t3.parent.url, e3.onplay = this._onPlay.bind(this), e3.onpause = this._onPause.bind(this), t3.context.on("refresh", this.refresh, this), t3.context.on("refreshPaused", this.refreshPaused, this), this._media = t3;
    }, e2.prototype._internalStop = function() {
      this._source && this._playing && (this._source.onended = null, this._source.pause());
    }, e2.prototype.stop = function() {
      this._internalStop(), this._source && this.emit("stop");
    }, Object.defineProperty(e2.prototype, "speed", {get: function() {
      return this._speed;
    }, set: function(t3) {
      this._speed = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "volume", {get: function() {
      return this._volume;
    }, set: function(t3) {
      this._volume = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "loop", {get: function() {
      return this._loop;
    }, set: function(t3) {
      this._loop = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "muted", {get: function() {
      return this._muted;
    }, set: function(t3) {
      this._muted = t3, this.refresh();
    }, enumerable: false, configurable: true}), e2.prototype.refresh = function() {
      var t3 = this._media.context, e3 = this._media.parent;
      this._source.loop = this._loop || e3.loop;
      var n2 = t3.volume * (t3.muted ? 0 : 1), o2 = e3.volume * (e3.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);
      this._source.volume = i2 * n2 * o2, this._source.playbackRate = this._speed * t3.speed * e3.speed;
    }, e2.prototype.refreshPaused = function() {
      var t3 = this._media.context, e3 = this._media.parent, n2 = this._paused || e3.paused || t3.paused;
      n2 !== this._pausedReal && (this._pausedReal = n2, n2 ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop})), this.emit("pause", n2));
    }, e2.prototype.play = function(t3) {
      var n2 = this, i2 = t3.start, r2 = t3.end, s3 = t3.speed, u2 = t3.loop, a2 = t3.volume, c2 = t3.muted;
      this._speed = s3, this._volume = a2, this._loop = !!u2, this._muted = c2, this.refresh(), this.loop && r2 !== null && (this.loop = false), this._start = i2, this._end = r2 || this._duration, this._start = Math.max(0, this._start - e2.PADDING), this._end = Math.min(this._end + e2.PADDING, this._duration), this._source.onloadedmetadata = function() {
        n2._source && (n2._source.currentTime = i2, n2._source.onloadedmetadata = null, n2.emit("progress", i2, n2._duration), import_ticker.Ticker.shared.add(n2._onUpdate, n2));
      }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
    }, e2.prototype._onUpdate = function() {
      this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
    }, e2.prototype._onComplete = function() {
      import_ticker.Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
    }, e2.prototype.destroy = function() {
      import_ticker.Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
      var t3 = this._source;
      t3 && (t3.onended = null, t3.onplay = null, t3.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = false, this._end = null, this._start = 0, this._duration = 0, this._playing = false, this._pausedReal = false, this._paused = false, this._muted = false, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
    }, e2.prototype.toString = function() {
      return "[HTMLAudioInstance id=" + this.id + "]";
    }, e2.PADDING = 0.1, e2;
  }(import_utils.EventEmitter);
  var b = function(t2) {
    function e2() {
      return t2 !== null && t2.apply(this, arguments) || this;
    }
    return a(e2, t2), e2.prototype.init = function(t3) {
      this.parent = t3, this._source = t3.options.source || new Audio(), t3.url && (this._source.src = t3.url);
    }, e2.prototype.create = function() {
      return new m(this);
    }, Object.defineProperty(e2.prototype, "isPlayable", {get: function() {
      return !!this._source && this._source.readyState === 4;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "duration", {get: function() {
      return this._source.duration;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "context", {get: function() {
      return this.parent.context;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "filters", {get: function() {
      return null;
    }, set: function(t3) {
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
    }, Object.defineProperty(e2.prototype, "source", {get: function() {
      return this._source;
    }, enumerable: false, configurable: true}), e2.prototype.load = function(t3) {
      var e3 = this._source, n2 = this.parent;
      if (e3.readyState !== 4)
        if (n2.url) {
          e3.src = n2.url;
          var o2 = function() {
            s3(), n2.isLoaded = true;
            var e4 = n2.autoPlayStart();
            t3 && t3(null, n2, e4);
          }, i2 = function() {
            s3(), t3 && t3(new Error("Sound loading has been aborted"));
          }, r2 = function() {
            s3();
            var n3 = "Failed to load audio element (code: " + e3.error.code + ")";
            t3 && t3(new Error(n3));
          }, s3 = function() {
            e3.removeEventListener("canplaythrough", o2), e3.removeEventListener("load", o2), e3.removeEventListener("abort", i2), e3.removeEventListener("error", r2);
          };
          e3.addEventListener("canplaythrough", o2, false), e3.addEventListener("load", o2, false), e3.addEventListener("abort", i2, false), e3.addEventListener("error", r2, false), e3.load();
        } else
          t3(new Error("sound.url or sound.source must be set"));
      else {
        n2.isLoaded = true;
        var u2 = n2.autoPlayStart();
        t3 && setTimeout(function() {
          t3(null, n2, u2);
        }, 0);
      }
    }, e2;
  }(import_utils.EventEmitter);
  var g = function() {
    function t2(t3, e2) {
      this.parent = t3, Object.assign(this, e2), this.duration = this.end - this.start;
    }
    return t2.prototype.play = function(t3) {
      return this.parent.play({complete: t3, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop});
    }, t2.prototype.destroy = function() {
      this.parent = null;
    }, t2;
  }();
  var v = function() {
    function t2() {
    }
    return t2.setParamValue = function(t3, e2) {
      if (t3.setValueAtTime) {
        var n2 = s2().context;
        t3.setValueAtTime(e2, n2.audioContext.currentTime);
      } else
        t3.value = e2;
      return e2;
    }, t2;
  }();
  var P = 0;
  var x = function(t2) {
    function e2(e3) {
      var n2 = t2.call(this) || this;
      return n2.id = P++, n2._media = null, n2._paused = false, n2._muted = false, n2._elapsed = 0, n2.init(e3), n2;
    }
    return a(e2, t2), e2.prototype.set = function(t3, e3) {
      if (this[t3] === void 0)
        throw new Error("Property with name " + t3 + " does not exist.");
      switch (t3) {
        case "speed":
          this.speed = e3;
          break;
        case "volume":
          this.volume = e3;
          break;
        case "muted":
          this.muted = e3;
          break;
        case "loop":
          this.loop = e3;
          break;
        case "paused":
          this.paused = e3;
      }
      return this;
    }, e2.prototype.stop = function() {
      this._source && (this._internalStop(), this.emit("stop"));
    }, Object.defineProperty(e2.prototype, "speed", {get: function() {
      return this._speed;
    }, set: function(t3) {
      this._speed = t3, this.refresh(), this._update(true);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "volume", {get: function() {
      return this._volume;
    }, set: function(t3) {
      this._volume = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "muted", {get: function() {
      return this._muted;
    }, set: function(t3) {
      this._muted = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "loop", {get: function() {
      return this._loop;
    }, set: function(t3) {
      this._loop = t3, this.refresh();
    }, enumerable: false, configurable: true}), e2.prototype.refresh = function() {
      if (this._source) {
        var t3 = this._media.context, e3 = this._media.parent;
        this._source.loop = this._loop || e3.loop;
        var n2 = t3.volume * (t3.muted ? 0 : 1), o2 = e3.volume * (e3.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);
        v.setParamValue(this._gain.gain, i2 * o2 * n2), v.setParamValue(this._source.playbackRate, this._speed * e3.speed * t3.speed);
      }
    }, e2.prototype.refreshPaused = function() {
      var t3 = this._media.context, e3 = this._media.parent, n2 = this._paused || e3.paused || t3.paused;
      n2 !== this._pausedReal && (this._pausedReal = n2, n2 ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume})), this.emit("pause", n2));
    }, e2.prototype.play = function(t3) {
      var e3 = t3.start, n2 = t3.end, o2 = t3.speed, i2 = t3.loop, r2 = t3.volume, s3 = t3.muted;
      this._paused = false;
      var u2 = this._media.nodes.cloneBufferSource(), a2 = u2.source, c2 = u2.gain;
      this._source = a2, this._gain = c2, this._speed = o2, this._volume = r2, this._loop = !!i2, this._muted = s3, this.refresh();
      var p2 = this._source.buffer.duration;
      this._duration = p2, this._end = n2, this._lastUpdate = this._now(), this._elapsed = e3, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n2, this._source.loopStart = e3, this._source.start(0, e3)) : n2 ? this._source.start(0, e3, n2 - e3) : this._source.start(0, e3), this.emit("start"), this._update(true), this.enableTicker(true);
    }, e2.prototype.enableTicker = function(t3) {
      import_ticker.Ticker.shared.remove(this._updateListener, this), t3 && import_ticker.Ticker.shared.add(this._updateListener, this);
    }, Object.defineProperty(e2.prototype, "progress", {get: function() {
      return this._progress;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "paused", {get: function() {
      return this._paused;
    }, set: function(t3) {
      this._paused = t3, this.refreshPaused();
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), this._end = null, this._speed = 1, this._volume = 1, this._loop = false, this._elapsed = 0, this._duration = 0, this._paused = false, this._muted = false, this._pausedReal = false;
    }, e2.prototype.toString = function() {
      return "[WebAudioInstance id=" + this.id + "]";
    }, e2.prototype._now = function() {
      return this._media.context.audioContext.currentTime;
    }, e2.prototype._updateListener = function() {
      this._update();
    }, e2.prototype._update = function(t3) {
      if (t3 === void 0 && (t3 = false), this._source) {
        var e3 = this._now(), n2 = e3 - this._lastUpdate;
        if (n2 > 0 || t3) {
          var o2 = this._source.playbackRate.value;
          this._elapsed += n2 * o2, this._lastUpdate = e3;
          var i2 = this._duration, r2 = void 0;
          if (this._source.loopStart) {
            var s3 = this._source.loopEnd - this._source.loopStart;
            r2 = (this._source.loopStart + this._elapsed % s3) / i2;
          } else
            r2 = this._elapsed % i2 / i2;
          this._progress = r2, this.emit("progress", this._progress, i2);
        }
      }
    }, e2.prototype.init = function(t3) {
      this._media = t3, t3.context.events.on("refresh", this.refresh, this), t3.context.events.on("refreshPaused", this.refreshPaused, this);
    }, e2.prototype._internalStop = function() {
      this._source && (this.enableTicker(false), this._source.onended = null, this._source.stop(0), this._source.disconnect(), this._source = null);
    }, e2.prototype._onComplete = function() {
      this._source && (this.enableTicker(false), this._source.onended = null, this._source.disconnect()), this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
    }, e2;
  }(import_utils.EventEmitter);
  var O = function() {
    function t2(t3, e2) {
      this._output = e2, this._input = t3;
    }
    return Object.defineProperty(t2.prototype, "destination", {get: function() {
      return this._input;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "filters", {get: function() {
      return this._filters;
    }, set: function(t3) {
      var e2 = this;
      if (this._filters && (this._filters.forEach(function(t4) {
        t4 && t4.disconnect();
      }), this._filters = null, this._input.connect(this._output)), t3 && t3.length) {
        this._filters = t3.slice(0), this._input.disconnect();
        var n2 = null;
        t3.forEach(function(t4) {
          n2 === null ? e2._input.connect(t4.destination) : n2.connect(t4.destination), n2 = t4;
        }), n2.connect(this._output);
      }
    }, enumerable: false, configurable: true}), t2.prototype.destroy = function() {
      this.filters = null, this._input = null, this._output = null;
    }, t2;
  }();
  var j = function(t2) {
    function e2(e3) {
      var n2 = this, o2 = e3.audioContext, i2 = o2.createBufferSource(), r2 = o2.createGain(), s3 = o2.createAnalyser();
      return i2.connect(s3), s3.connect(r2), r2.connect(e3.destination), (n2 = t2.call(this, s3, r2) || this).context = e3, n2.bufferSource = i2, n2.gain = r2, n2.analyser = s3, n2;
    }
    return a(e2, t2), Object.defineProperty(e2.prototype, "script", {get: function() {
      return this._script || (this._script = this.context.audioContext.createScriptProcessor(e2.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
    }, e2.prototype.cloneBufferSource = function() {
      var t3 = this.bufferSource, e3 = this.context.audioContext.createBufferSource();
      e3.buffer = t3.buffer, v.setParamValue(e3.playbackRate, t3.playbackRate.value), e3.loop = t3.loop;
      var n2 = this.context.audioContext.createGain();
      return e3.connect(n2), n2.connect(this.destination), {source: e3, gain: n2};
    }, Object.defineProperty(e2.prototype, "bufferSize", {get: function() {
      return this.script.bufferSize;
    }, enumerable: false, configurable: true}), e2.BUFFER_SIZE = 0, e2;
  }(O);
  var w = function() {
    function t2() {
    }
    return t2.prototype.init = function(t3) {
      this.parent = t3, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t3.options.source;
    }, t2.prototype.destroy = function() {
      this.parent = null, this._nodes.destroy(), this._nodes = null, this._source = null, this.source = null;
    }, t2.prototype.create = function() {
      return new x(this);
    }, Object.defineProperty(t2.prototype, "context", {get: function() {
      return this.parent.context;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "isPlayable", {get: function() {
      return !!this._source && !!this._source.buffer;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "filters", {get: function() {
      return this._nodes.filters;
    }, set: function(t3) {
      this._nodes.filters = t3;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "duration", {get: function() {
      return this._source.buffer.duration;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "buffer", {get: function() {
      return this._source.buffer;
    }, set: function(t3) {
      this._source.buffer = t3;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "nodes", {get: function() {
      return this._nodes;
    }, enumerable: false, configurable: true}), t2.prototype.load = function(t3) {
      this.source ? this._decode(this.source, t3) : this.parent.url ? this._loadUrl(t3) : t3 && t3(new Error("sound.url or sound.source must be set"));
    }, t2.prototype._loadUrl = function(t3) {
      var e2 = this, n2 = new XMLHttpRequest(), o2 = this.parent.url;
      n2.open("GET", o2, true), n2.responseType = "arraybuffer", n2.onload = function() {
        e2.source = n2.response, e2._decode(n2.response, t3);
      }, n2.send();
    }, t2.prototype._decode = function(t3, e2) {
      var n2 = this;
      this.parent.context.decode(t3, function(t4, o2) {
        if (t4)
          e2 && e2(t4);
        else {
          n2.parent.isLoaded = true, n2.buffer = o2;
          var i2 = n2.parent.autoPlayStart();
          e2 && e2(null, n2.parent, i2);
        }
      });
    }, t2;
  }();
  var A = function() {
    function t2(t3, e2) {
      this.media = t3, this.options = e2, this._instances = [], this._sprites = {}, this.media.init(this);
      var n2 = e2.complete;
      this._autoPlayOptions = n2 ? {complete: n2} : null, this.isLoaded = false, this.isPlaying = false, this.autoPlay = e2.autoPlay, this.singleInstance = e2.singleInstance, this.preload = e2.preload || this.autoPlay, this.url = e2.url, this.speed = e2.speed, this.volume = e2.volume, this.loop = e2.loop, e2.sprites && this.addSprites(e2.sprites), this.preload && this._preload(e2.loaded);
    }
    return t2.from = function(e2) {
      var n2 = {};
      return typeof e2 == "string" ? n2.url = e2 : e2 instanceof ArrayBuffer || e2 instanceof HTMLAudioElement ? n2.source = e2 : n2 = e2, (n2 = c({autoPlay: false, singleInstance: false, url: null, source: null, preload: false, volume: 1, speed: 1, complete: null, loaded: null, loop: false}, n2)).url && (n2.url = f(n2.url)), Object.freeze(n2), new t2(s2().useLegacy ? new b() : new w(), n2);
    }, Object.defineProperty(t2.prototype, "context", {get: function() {
      return s2().context;
    }, enumerable: false, configurable: true}), t2.prototype.pause = function() {
      return this.isPlaying = false, this.paused = true, this;
    }, t2.prototype.resume = function() {
      return this.isPlaying = this._instances.length > 0, this.paused = false, this;
    }, Object.defineProperty(t2.prototype, "paused", {get: function() {
      return this._paused;
    }, set: function(t3) {
      this._paused = t3, this.refreshPaused();
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "speed", {get: function() {
      return this._speed;
    }, set: function(t3) {
      this._speed = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "filters", {get: function() {
      return this.media.filters;
    }, set: function(t3) {
      this.media.filters = t3;
    }, enumerable: false, configurable: true}), t2.prototype.addSprites = function(t3, e2) {
      if (typeof t3 == "object") {
        var n2 = {};
        for (var o2 in t3)
          n2[o2] = this.addSprites(o2, t3[o2]);
        return n2;
      }
      var i2 = new g(this, e2);
      return this._sprites[t3] = i2, i2;
    }, t2.prototype.destroy = function() {
      this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
    }, t2.prototype.removeSprites = function(t3) {
      if (t3) {
        var e2 = this._sprites[t3];
        e2 !== void 0 && (e2.destroy(), delete this._sprites[t3]);
      } else
        for (var n2 in this._sprites)
          this.removeSprites(n2);
      return this;
    }, Object.defineProperty(t2.prototype, "isPlayable", {get: function() {
      return this.isLoaded && this.media && this.media.isPlayable;
    }, enumerable: false, configurable: true}), t2.prototype.stop = function() {
      if (!this.isPlayable)
        return this.autoPlay = false, this._autoPlayOptions = null, this;
      this.isPlaying = false;
      for (var t3 = this._instances.length - 1; t3 >= 0; t3--)
        this._instances[t3].stop();
      return this;
    }, t2.prototype.play = function(t3, e2) {
      var n2, o2 = this;
      typeof t3 == "string" ? n2 = {sprite: r2 = t3, loop: this.loop, complete: e2} : typeof t3 == "function" ? (n2 = {}).complete = t3 : n2 = t3;
      if ((n2 = c({complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: false, loop: false}, n2 || {})).sprite) {
        var i2 = n2.sprite, r2 = this._sprites[i2];
        n2.start = r2.start, n2.end = r2.end, n2.speed = r2.speed || 1, n2.loop = r2.loop || n2.loop, delete n2.sprite;
      }
      if (n2.offset && (n2.start = n2.offset), !this.isLoaded)
        return new Promise(function(t4, e3) {
          o2.autoPlay = true, o2._autoPlayOptions = n2, o2._preload(function(o3, i3, r3) {
            o3 ? e3(o3) : (n2.loaded && n2.loaded(o3, i3, r3), t4(r3));
          });
        });
      this.singleInstance && this._removeInstances();
      var s3 = this._createInstance();
      return this._instances.push(s3), this.isPlaying = true, s3.once("end", function() {
        n2.complete && n2.complete(o2), o2._onComplete(s3);
      }), s3.once("stop", function() {
        o2._onComplete(s3);
      }), s3.play(n2), s3;
    }, t2.prototype.refresh = function() {
      for (var t3 = this._instances.length, e2 = 0; e2 < t3; e2++)
        this._instances[e2].refresh();
    }, t2.prototype.refreshPaused = function() {
      for (var t3 = this._instances.length, e2 = 0; e2 < t3; e2++)
        this._instances[e2].refreshPaused();
    }, Object.defineProperty(t2.prototype, "volume", {get: function() {
      return this._volume;
    }, set: function(t3) {
      this._volume = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "muted", {get: function() {
      return this._muted;
    }, set: function(t3) {
      this._muted = t3, this.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "loop", {get: function() {
      return this._loop;
    }, set: function(t3) {
      this._loop = t3, this.refresh();
    }, enumerable: false, configurable: true}), t2.prototype._preload = function(t3) {
      this.media.load(t3);
    }, Object.defineProperty(t2.prototype, "instances", {get: function() {
      return this._instances;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "sprites", {get: function() {
      return this._sprites;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "duration", {get: function() {
      return this.media.duration;
    }, enumerable: false, configurable: true}), t2.prototype.autoPlayStart = function() {
      var t3;
      return this.autoPlay && (t3 = this.play(this._autoPlayOptions)), t3;
    }, t2.prototype._removeInstances = function() {
      for (var t3 = this._instances.length - 1; t3 >= 0; t3--)
        this._poolInstance(this._instances[t3]);
      this._instances.length = 0;
    }, t2.prototype._onComplete = function(t3) {
      if (this._instances) {
        var e2 = this._instances.indexOf(t3);
        e2 > -1 && this._instances.splice(e2, 1), this.isPlaying = this._instances.length > 0;
      }
      this._poolInstance(t3);
    }, t2.prototype._createInstance = function() {
      if (t2._pool.length > 0) {
        var e2 = t2._pool.pop();
        return e2.init(this.media), e2;
      }
      return this.media.create();
    }, t2.prototype._poolInstance = function(e2) {
      e2.destroy(), t2._pool.indexOf(e2) < 0 && t2._pool.push(e2);
    }, t2._pool = [], t2;
  }();
  var F = function(t2) {
    function e2() {
      var e3 = t2 !== null && t2.apply(this, arguments) || this;
      return e3.speed = 1, e3.muted = false, e3.volume = 1, e3.paused = false, e3;
    }
    return a(e2, t2), e2.prototype.refresh = function() {
      this.emit("refresh");
    }, e2.prototype.refreshPaused = function() {
      this.emit("refreshPaused");
    }, Object.defineProperty(e2.prototype, "filters", {get: function() {
      return null;
    }, set: function(t3) {
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "audioContext", {get: function() {
      return null;
    }, enumerable: false, configurable: true}), e2.prototype.toggleMute = function() {
      return this.muted = !this.muted, this.refresh(), this.muted;
    }, e2.prototype.togglePause = function() {
      return this.paused = !this.paused, this.refreshPaused(), this.paused;
    }, e2.prototype.destroy = function() {
      this.removeAllListeners();
    }, e2;
  }(import_utils.EventEmitter);
  var C = function(t2) {
    function e2() {
      var o2 = this, i2 = window, r2 = new e2.AudioContext(), s3 = r2.createDynamicsCompressor(), u2 = r2.createAnalyser();
      return u2.connect(s3), s3.connect(r2.destination), (o2 = t2.call(this, u2, s3) || this)._ctx = r2, o2._offlineCtx = new e2.OfflineAudioContext(1, 2, i2.OfflineAudioContext ? r2.sampleRate : 44100), o2._unlocked = false, o2.compressor = s3, o2.analyser = u2, o2.events = new import_utils.EventEmitter(), o2.volume = 1, o2.speed = 1, o2.muted = false, o2.paused = false, r2.state !== "running" && (o2._unlock(), o2._unlock = o2._unlock.bind(o2), document.addEventListener("mousedown", o2._unlock, true), document.addEventListener("touchstart", o2._unlock, true), document.addEventListener("touchend", o2._unlock, true)), o2;
    }
    return a(e2, t2), e2.prototype._unlock = function() {
      this._unlocked || (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, true), document.removeEventListener("touchend", this._unlock, true), document.removeEventListener("touchstart", this._unlock, true), this._unlocked = true));
    }, e2.prototype.playEmptySound = function() {
      var t3 = this._ctx.createBufferSource();
      t3.buffer = this._ctx.createBuffer(1, 1, 22050), t3.connect(this._ctx.destination), t3.start(0, 0, 0), t3.context.state === "suspended" && t3.context.resume();
    }, Object.defineProperty(e2, "AudioContext", {get: function() {
      var t3 = window;
      return t3.AudioContext || t3.webkitAudioContext || null;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2, "OfflineAudioContext", {get: function() {
      var t3 = window;
      return t3.OfflineAudioContext || t3.webkitOfflineAudioContext || null;
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this);
      var e3 = this._ctx;
      e3.close !== void 0 && e3.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
    }, Object.defineProperty(e2.prototype, "audioContext", {get: function() {
      return this._ctx;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "offlineContext", {get: function() {
      return this._offlineCtx;
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "paused", {get: function() {
      return this._paused;
    }, set: function(t3) {
      t3 && this._ctx.state === "running" ? this._ctx.suspend() : t3 || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = t3;
    }, enumerable: false, configurable: true}), e2.prototype.refresh = function() {
      this.events.emit("refresh");
    }, e2.prototype.refreshPaused = function() {
      this.events.emit("refreshPaused");
    }, e2.prototype.toggleMute = function() {
      return this.muted = !this.muted, this.refresh(), this.muted;
    }, e2.prototype.togglePause = function() {
      return this.paused = !this.paused, this.refreshPaused(), this._paused;
    }, e2.prototype.decode = function(t3, e3) {
      var n2 = function(t4) {
        e3(new Error(t4.message || "Unable to decode file"));
      }, o2 = this._offlineCtx.decodeAudioData(t3, function(t4) {
        e3(null, t4);
      }, n2);
      o2 && o2.catch(n2);
    }, e2;
  }(O);
  var E = function() {
    function t2() {
      this.init();
    }
    return t2.prototype.init = function() {
      return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;
    }, Object.defineProperty(t2.prototype, "context", {get: function() {
      return this._context;
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "filtersAll", {get: function() {
      return this.useLegacy ? [] : this._context.filters;
    }, set: function(t3) {
      this.useLegacy || (this._context.filters = t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "supported", {get: function() {
      return C.AudioContext !== null;
    }, enumerable: false, configurable: true}), t2.prototype.add = function(t3, e2) {
      if (typeof t3 == "object") {
        var n2 = {};
        for (var o2 in t3) {
          var i2 = this._getOptions(t3[o2], e2);
          n2[o2] = this.add(o2, i2);
        }
        return n2;
      }
      if (e2 instanceof A)
        return this._sounds[t3] = e2, e2;
      var r2 = this._getOptions(e2), s3 = A.from(r2);
      return this._sounds[t3] = s3, s3;
    }, t2.prototype._getOptions = function(t3, e2) {
      var n2;
      return n2 = typeof t3 == "string" ? {url: t3} : t3 instanceof ArrayBuffer || t3 instanceof HTMLAudioElement ? {source: t3} : t3, n2 = c(c({}, n2), e2 || {});
    }, Object.defineProperty(t2.prototype, "useLegacy", {get: function() {
      return this._useLegacy;
    }, set: function(t3) {
      _.setLegacy(t3), this._useLegacy = t3, this._context = !t3 && this.supported ? this._webAudioContext : this._htmlAudioContext;
    }, enumerable: false, configurable: true}), t2.prototype.remove = function(t3) {
      return this.exists(t3, true), this._sounds[t3].destroy(), delete this._sounds[t3], this;
    }, Object.defineProperty(t2.prototype, "volumeAll", {get: function() {
      return this._context.volume;
    }, set: function(t3) {
      this._context.volume = t3, this._context.refresh();
    }, enumerable: false, configurable: true}), Object.defineProperty(t2.prototype, "speedAll", {get: function() {
      return this._context.speed;
    }, set: function(t3) {
      this._context.speed = t3, this._context.refresh();
    }, enumerable: false, configurable: true}), t2.prototype.togglePauseAll = function() {
      return this._context.togglePause();
    }, t2.prototype.pauseAll = function() {
      return this._context.paused = true, this._context.refreshPaused(), this;
    }, t2.prototype.resumeAll = function() {
      return this._context.paused = false, this._context.refreshPaused(), this;
    }, t2.prototype.toggleMuteAll = function() {
      return this._context.toggleMute();
    }, t2.prototype.muteAll = function() {
      return this._context.muted = true, this._context.refresh(), this;
    }, t2.prototype.unmuteAll = function() {
      return this._context.muted = false, this._context.refresh(), this;
    }, t2.prototype.removeAll = function() {
      for (var t3 in this._sounds)
        this._sounds[t3].destroy(), delete this._sounds[t3];
      return this;
    }, t2.prototype.stopAll = function() {
      for (var t3 in this._sounds)
        this._sounds[t3].stop();
      return this;
    }, t2.prototype.exists = function(t3, e2) {
      return e2 === void 0 && (e2 = false), !!this._sounds[t3];
    }, t2.prototype.find = function(t3) {
      return this.exists(t3, true), this._sounds[t3];
    }, t2.prototype.play = function(t3, e2) {
      return this.find(t3).play(e2);
    }, t2.prototype.stop = function(t3) {
      return this.find(t3).stop();
    }, t2.prototype.pause = function(t3) {
      return this.find(t3).pause();
    }, t2.prototype.resume = function(t3) {
      return this.find(t3).resume();
    }, t2.prototype.volume = function(t3, e2) {
      var n2 = this.find(t3);
      return e2 !== void 0 && (n2.volume = e2), n2.volume;
    }, t2.prototype.speed = function(t3, e2) {
      var n2 = this.find(t3);
      return e2 !== void 0 && (n2.speed = e2), n2.speed;
    }, t2.prototype.duration = function(t3) {
      return this.find(t3).duration;
    }, t2.prototype.close = function() {
      return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
    }, t2;
  }();
  var S = function() {
    function t2(t3, e2) {
      this.init(t3, e2);
    }
    return t2.prototype.init = function(t3, e2) {
      this.destination = t3, this.source = e2 || t3;
    }, t2.prototype.connect = function(t3) {
      this.source.connect(t3);
    }, t2.prototype.disconnect = function() {
      this.source.disconnect();
    }, t2.prototype.destroy = function() {
      this.disconnect(), this.destination = null, this.source = null;
    }, t2;
  }();
  var k = {Filter: S, EqualizerFilter: function(t2) {
    function e2(n2, o2, i2, r2, u2, a2, c2, p2, h2, l2) {
      n2 === void 0 && (n2 = 0), o2 === void 0 && (o2 = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), u2 === void 0 && (u2 = 0), a2 === void 0 && (a2 = 0), c2 === void 0 && (c2 = 0), p2 === void 0 && (p2 = 0), h2 === void 0 && (h2 = 0), l2 === void 0 && (l2 = 0);
      var d2 = this;
      if (!s2().useLegacy) {
        var f2 = [{f: e2.F32, type: "lowshelf", gain: n2}, {f: e2.F64, type: "peaking", gain: o2}, {f: e2.F125, type: "peaking", gain: i2}, {f: e2.F250, type: "peaking", gain: r2}, {f: e2.F500, type: "peaking", gain: u2}, {f: e2.F1K, type: "peaking", gain: a2}, {f: e2.F2K, type: "peaking", gain: c2}, {f: e2.F4K, type: "peaking", gain: p2}, {f: e2.F8K, type: "peaking", gain: h2}, {f: e2.F16K, type: "highshelf", gain: l2}].map(function(t3) {
          var e3 = s2().context.audioContext.createBiquadFilter();
          return e3.type = t3.type, v.setParamValue(e3.Q, 1), e3.frequency.value = t3.f, v.setParamValue(e3.gain, t3.gain), e3;
        });
        (d2 = t2.call(this, f2[0], f2[f2.length - 1]) || this).bands = f2, d2.bandsMap = {};
        for (var _2 = 0; _2 < d2.bands.length; _2++) {
          var y2 = d2.bands[_2];
          _2 > 0 && d2.bands[_2 - 1].connect(y2), d2.bandsMap[y2.frequency.value] = y2;
        }
        return d2;
      }
      d2 = t2.call(this, null) || this;
    }
    return a(e2, t2), e2.prototype.setGain = function(t3, e3) {
      if (e3 === void 0 && (e3 = 0), !this.bandsMap[t3])
        throw new Error("No band found for frequency " + t3);
      v.setParamValue(this.bandsMap[t3].gain, e3);
    }, e2.prototype.getGain = function(t3) {
      if (!this.bandsMap[t3])
        throw new Error("No band found for frequency " + t3);
      return this.bandsMap[t3].gain.value;
    }, Object.defineProperty(e2.prototype, "f32", {get: function() {
      return this.getGain(e2.F32);
    }, set: function(t3) {
      this.setGain(e2.F32, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f64", {get: function() {
      return this.getGain(e2.F64);
    }, set: function(t3) {
      this.setGain(e2.F64, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f125", {get: function() {
      return this.getGain(e2.F125);
    }, set: function(t3) {
      this.setGain(e2.F125, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f250", {get: function() {
      return this.getGain(e2.F250);
    }, set: function(t3) {
      this.setGain(e2.F250, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f500", {get: function() {
      return this.getGain(e2.F500);
    }, set: function(t3) {
      this.setGain(e2.F500, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f1k", {get: function() {
      return this.getGain(e2.F1K);
    }, set: function(t3) {
      this.setGain(e2.F1K, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f2k", {get: function() {
      return this.getGain(e2.F2K);
    }, set: function(t3) {
      this.setGain(e2.F2K, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f4k", {get: function() {
      return this.getGain(e2.F4K);
    }, set: function(t3) {
      this.setGain(e2.F4K, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f8k", {get: function() {
      return this.getGain(e2.F8K);
    }, set: function(t3) {
      this.setGain(e2.F8K, t3);
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "f16k", {get: function() {
      return this.getGain(e2.F16K);
    }, set: function(t3) {
      this.setGain(e2.F16K, t3);
    }, enumerable: false, configurable: true}), e2.prototype.reset = function() {
      this.bands.forEach(function(t3) {
        v.setParamValue(t3.gain, 0);
      });
    }, e2.prototype.destroy = function() {
      this.bands.forEach(function(t3) {
        t3.disconnect();
      }), this.bands = null, this.bandsMap = null;
    }, e2.F32 = 32, e2.F64 = 64, e2.F125 = 125, e2.F250 = 250, e2.F500 = 500, e2.F1K = 1e3, e2.F2K = 2e3, e2.F4K = 4e3, e2.F8K = 8e3, e2.F16K = 16e3, e2;
  }(S), DistortionFilter: function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = 0);
      var n2 = this;
      if (!s2().useLegacy) {
        var o2 = s2().context.audioContext.createWaveShaper();
        return (n2 = t2.call(this, o2) || this)._distortion = o2, n2.amount = e3, n2;
      }
      n2 = t2.call(this, null) || this;
    }
    return a(e2, t2), Object.defineProperty(e2.prototype, "amount", {get: function() {
      return this._amount;
    }, set: function(t3) {
      t3 *= 1e3, this._amount = t3;
      for (var e3, n2 = 44100, o2 = new Float32Array(n2), i2 = Math.PI / 180, r2 = 0; r2 < n2; ++r2)
        e3 = 2 * r2 / n2 - 1, o2[r2] = (3 + t3) * e3 * 20 * i2 / (Math.PI + t3 * Math.abs(e3));
      this._distortion.curve = o2, this._distortion.oversample = "4x";
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      this._distortion = null, t2.prototype.destroy.call(this);
    }, e2;
  }(S), StereoFilter: function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = 0);
      var n2 = this;
      if (!s2().useLegacy) {
        var o2, i2, r2, u2 = s2().context.audioContext;
        return u2.createStereoPanner ? r2 = o2 = u2.createStereoPanner() : ((i2 = u2.createPanner()).panningModel = "equalpower", r2 = i2), (n2 = t2.call(this, r2) || this)._stereo = o2, n2._panner = i2, n2.pan = e3, n2;
      }
      n2 = t2.call(this, null) || this;
    }
    return a(e2, t2), Object.defineProperty(e2.prototype, "pan", {get: function() {
      return this._pan;
    }, set: function(t3) {
      this._pan = t3, this._stereo ? v.setParamValue(this._stereo.pan, t3) : this._panner.setPosition(t3, 0, 1 - Math.abs(t3));
    }, enumerable: false, configurable: true}), e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this), this._stereo = null, this._panner = null;
    }, e2;
  }(S), ReverbFilter: function(t2) {
    function e2(e3, n2, o2) {
      e3 === void 0 && (e3 = 3), n2 === void 0 && (n2 = 2), o2 === void 0 && (o2 = false);
      var i2 = this;
      if (!s2().useLegacy)
        return (i2 = t2.call(this, null) || this)._seconds = i2._clamp(e3, 1, 50), i2._decay = i2._clamp(n2, 0, 100), i2._reverse = o2, i2._rebuild(), i2;
      i2 = t2.call(this, null) || this;
    }
    return a(e2, t2), e2.prototype._clamp = function(t3, e3, n2) {
      return Math.min(n2, Math.max(e3, t3));
    }, Object.defineProperty(e2.prototype, "seconds", {get: function() {
      return this._seconds;
    }, set: function(t3) {
      this._seconds = this._clamp(t3, 1, 50), this._rebuild();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "decay", {get: function() {
      return this._decay;
    }, set: function(t3) {
      this._decay = this._clamp(t3, 0, 100), this._rebuild();
    }, enumerable: false, configurable: true}), Object.defineProperty(e2.prototype, "reverse", {get: function() {
      return this._reverse;
    }, set: function(t3) {
      this._reverse = t3, this._rebuild();
    }, enumerable: false, configurable: true}), e2.prototype._rebuild = function() {
      for (var t3, e3 = s2().context.audioContext, n2 = e3.sampleRate, o2 = n2 * this._seconds, i2 = e3.createBuffer(2, o2, n2), r2 = i2.getChannelData(0), u2 = i2.getChannelData(1), a2 = 0; a2 < o2; a2++)
        t3 = this._reverse ? o2 - a2 : a2, r2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t3 / o2, this._decay), u2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t3 / o2, this._decay);
      var c2 = s2().context.audioContext.createConvolver();
      c2.buffer = i2, this.init(c2);
    }, e2;
  }(S), MonoFilter: function(t2) {
    function e2() {
      var e3 = this;
      if (!s2().useLegacy) {
        var n2 = s2().context.audioContext, o2 = n2.createChannelSplitter(), i2 = n2.createChannelMerger();
        return i2.connect(o2), (e3 = t2.call(this, i2, o2) || this)._merger = i2, e3;
      }
      e3 = t2.call(this, null) || this;
    }
    return a(e2, t2), e2.prototype.destroy = function() {
      this._merger.disconnect(), this._merger = null, t2.prototype.destroy.call(this);
    }, e2;
  }(S), TelephoneFilter: function(t2) {
    function e2() {
      if (!s2().useLegacy) {
        var e3 = s2().context.audioContext, n2 = e3.createBiquadFilter(), o2 = e3.createBiquadFilter(), i2 = e3.createBiquadFilter(), r2 = e3.createBiquadFilter();
        return n2.type = "lowpass", v.setParamValue(n2.frequency, 2e3), o2.type = "lowpass", v.setParamValue(o2.frequency, 2e3), i2.type = "highpass", v.setParamValue(i2.frequency, 500), r2.type = "highpass", v.setParamValue(r2.frequency, 500), n2.connect(o2), o2.connect(i2), i2.connect(r2), t2.call(this, n2, r2) || this;
      }
      t2.call(this, null);
    }
    return a(e2, t2), e2;
  }(S)};
  var I = function(t2) {
    return r = t2, t2;
  }(new E());
  import_loaders.Loader.registerPlugin(_);

  // assets/scripts/ECS/actor.class.js
  var PIXI12 = __toModule(require_pixi());

  // assets/scripts/ECS/scriptbehavior.js
  var PIXI4 = __toModule(require_pixi());

  // assets/scripts/ECS/helpers.js
  var PIXI3 = __toModule(require_pixi());

  // assets/scripts/ECS/state.class.js
  var PIXI2 = __toModule(require_pixi());
  var import_lodash = __toModule(require_lodash());
  var import_lodash2 = __toModule(require_lodash2());
  var import_lodash3 = __toModule(require_lodash3());
  var State = class extends PIXI2.utils.EventEmitter {
    constructor(name, defaultState = {}) {
      super();
      if (typeof name !== "string") {
        throw new TypeError("name must be a string");
      }
      this.name = name;
      this.defaultState = (0, import_lodash.default)(defaultState);
      this.load();
    }
    load() {
      const stateStr = localStorage.getItem(`state:${this.name}`);
      this.data = stateStr === null ? (0, import_lodash.default)(this.defaultState) : JSON.parse(stateStr);
    }
    reset() {
      this.data = (0, import_lodash.default)(this.defaultState);
      this.save();
      this.emit("reset");
    }
    setState(key, value = null) {
      (0, import_lodash3.default)(this.data, key, value);
      this.emit(key, value);
      this.save();
    }
    getState(key) {
      return (0, import_lodash2.default)(this.data, key);
    }
    attachToBehavior(behavior, config = {}) {
      if (typeof config === "undefined") {
        throw new TypeError("config must be set!");
      }
      for (const [behaviorKey, stateKey] of Object.entries(config)) {
        const defaultValue = behavior[behaviorKey] || null;
        const currentStateValue = this.getState(stateKey);
        this.setState(stateKey, currentStateValue || defaultValue);
        Object.defineProperty(behavior, behaviorKey, {
          get: () => this.getState(stateKey),
          set: (newValue) => {
            this.setState(stateKey, newValue);
          }
        });
      }
    }
    save() {
      localStorage.setItem(`state:${this.name}`, JSON.stringify(this.data));
    }
  };
  var state_class_default = State;

  // assets/scripts/ECS/helpers.js
  function getActor(name) {
    return game.rootScene.findChild(name, true);
  }
  function findAsset(assetName) {
    return game.app.loader.resources[assetName];
  }
  function getCurrentState() {
    return game.state;
  }
  function hitTestRectangle(r1, r2) {
    r1.centerX = r1.x + r1.width / 2;
    r1.centerY = r1.y + r1.height / 2;
    r2.centerX = r2.x + r2.width / 2;
    r2.centerY = r2.y + r2.height / 2;
    r1.halfWidth = r1.width / 2;
    r1.halfHeight = r1.height / 2;
    r2.halfWidth = r2.width / 2;
    r2.halfHeight = r2.height / 2;
    const vx = Math.abs(r1.centerX - r2.centerX);
    const vy = Math.abs(r1.centerY - r2.centerY);
    const combinedHalfWidths = r1.halfWidth + r2.halfWidth;
    const combinedHalfHeights = r1.halfHeight + r2.halfHeight;
    if (vx < combinedHalfWidths) {
      if (vy < combinedHalfHeights) {
        return true;
      }
    }
    return false;
  }

  // assets/scripts/ECS/scriptbehavior.js
  var voidFunction = () => void 0;
  var _ScriptBehavior = class extends PIXI4.utils.EventEmitter {
    static define(behaviorName, classInstance) {
      this.cache.set(behaviorName, classInstance);
    }
    constructor(state = null) {
      super();
      this.actor = null;
      if (state !== null) {
        this.once("awake", () => {
          getCurrentState().attachToBehavior(this, state);
        });
      }
      for (const methodName of _ScriptBehavior.AvailableMethods) {
        if (typeof this[methodName] !== "function") {
          this[methodName] = voidFunction;
        }
      }
    }
    sendMessage(name, ...args) {
      if (typeof this[name] === "function") {
        this[name](...args);
        this.emit(name, ...args);
      }
    }
  };
  var ScriptBehavior = _ScriptBehavior;
  __publicField(ScriptBehavior, "cache", new Map());
  var scriptbehavior_default = ScriptBehavior;
  ScriptBehavior.AvailableMethods = new Set(["awake", "start", "update", "destroy"]);

  // assets/scripts/ECS/actortree.class.js
  var PIXI5 = __toModule(require_pixi());
  var import_lru_cache = __toModule(require_lru_cache());
  var ActorTree = class extends PIXI5.Container {
    constructor(options = {}) {
      super();
      this.useLRUCache = options.useLRUCache || false;
      this.actorsCache = this.useLRUCache ? new import_lru_cache.default({max: 50}) : null;
      this.actors = new Map();
      this.sortableChildren = true;
    }
    cleanupTree() {
      for (const childrenActor of this.actors.values()) {
        childrenActor.triggerBehaviorEvent("destroy");
        childrenActor.cleanupTree();
      }
      this.emit("cleanup");
      this.emitEventForAllActors("destroy");
      this.actors.clear();
    }
    appendActor(actor) {
      this.actors.set(actor.name, actor);
      this.addChild(actor);
      this.emit("appendActor", actor);
      return this;
    }
    *getActors(recursive = false) {
      for (const actor of this.actors.values()) {
        yield actor;
        if (recursive) {
          yield* actor.getActors(recursive);
        }
      }
    }
    *getActorsFromComponents() {
      if (!this.components) {
        return;
      }
      const containers = this.components.filter((comp) => comp instanceof PIXI5.Container);
      for (const container of containers) {
        if (container instanceof actor_class_default) {
          yield* container.getActors(true);
          break;
        }
        for (const displayObject of container.children) {
          if (displayObject.constructor.name === "Actor") {
            yield displayObject;
          }
        }
      }
    }
    findChild(actorName, recursive = false) {
      if (this.actors.has(actorName)) {
        return this.actors.get(actorName);
      } else if (this.useLRUCache && this.actorsCache.has(actorName)) {
        return this.actorsCache.get(actorName);
      }
      for (const actor of this.getActorsFromComponents()) {
        if (actor.name === actorName) {
          if (this.useLRUCache) {
            this.actorsCache.set(actorName, actor);
          }
          return actor;
        }
      }
      for (const actor of this.actors.values()) {
        const childActor = actor.findChild(actorName, recursive);
        if (childActor !== null) {
          if (this.useLRUCache) {
            this.actorsCache.set(actorName, childActor);
          }
          return childActor;
        }
      }
      if (Array.isArray(this.childScenes)) {
        for (const scene of this.childScenes) {
          const actor = scene.findChild(actorName, recursive);
          if (actor !== null) {
            return actor;
          }
        }
      }
      return null;
    }
    emitEventForAllActors(eventName, ...args) {
      for (const actor of this.getActorsFromComponents()) {
        actor.triggerBehaviorEvent(eventName, ...args);
      }
      for (const actor of this.actors.values()) {
        actor.triggerBehaviorEvent(eventName, ...args);
      }
      if (this.childScenes) {
        for (const scene of this.childScenes) {
          scene.emitEventForAllActors(eventName, ...args);
        }
      }
    }
  };
  var actortree_class_default = ActorTree;

  // assets/scripts/ECS/component.js
  var PIXI11 = __toModule(require_pixi());

  // assets/scripts/ECS/components/animatedsprite.class.js
  var PIXI6 = __toModule(require_pixi());
  var AnimatedSpriteEx = class extends PIXI6.AnimatedSprite {
    static pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    constructor(spritesheetName, options = {}) {
      const {spritesheet} = findAsset(spritesheetName);
      const {animationSpeed = 0.1, defaultAnimation} = options;
      super(spritesheet.animations[defaultAnimation]);
      assignSymbols(this);
      this.texture.baseTexture.scaleMode = PIXI6.SCALE_MODES.NEAREST;
      this.animationBook = new Map();
      this.locked = false;
      this.animationSpeed = animationSpeed;
      this.play();
      this.spritesheet = spritesheet;
      this.defaultAnimation = defaultAnimation;
      this.currentAnimationName = defaultAnimation;
      this.anchor.set(0.5, 0.5);
    }
    oneToMany(newAnimationName, listOfAnimations, pickFunction = AnimatedSpriteEx.pickRandom) {
      this.animationBook.set(newAnimationName, {
        listOfAnimations,
        pickOne: () => pickFunction(listOfAnimations)
      });
      return this;
    }
    reset() {
      this.unlock();
      this.playAnimation(this.defaultAnimation);
      return this;
    }
    lock() {
      this.locked = true;
      return this;
    }
    unlock() {
      this.locked = false;
      return this;
    }
    playAnimation(animationName, options = {}) {
      const {loop = true, force = false} = options;
      if (this.locked && !force) {
        return;
      }
      const isCurrentAnimation = this.currentAnimationName === animationName;
      const isPlayingWithoutLoop = this.loop === false && this.playing;
      if (isCurrentAnimation || isPlayingWithoutLoop && !force) {
        return;
      }
      let newAnimationName = animationName;
      if (this.animationBook.has(animationName)) {
        newAnimationName = this.animationBook.get(animationName).pickOne();
      }
      this.currentAnimationName = animationName;
      this.textures = this.spritesheet.animations[newAnimationName];
      this.loop = loop;
      this.play();
      return this;
    }
  };
  var animatedsprite_class_default = AnimatedSpriteEx;

  // assets/scripts/ECS/components/tiledmap.js
  var PIXI10 = __toModule(require_pixi());

  // assets/scripts/ECS/components/tiledset.js
  var PIXI7 = __toModule(require_pixi());
  var _TiledSet = class {
    constructor(tiledData, options = {}) {
      _TiledSet.loaded.add(tiledData.name);
      this.name = tiledData.name;
      this.firstgid = tiledData.firstgid;
      this.debug = options.debug;
      this.textures = [];
      const data = findAsset(`${this.name}_json`).data;
      const resource = findAsset(`${this.name}_texture`);
      this.baseTexture = resource.texture.baseTexture;
      this.baseTexture.scaleMode = PIXI7.SCALE_MODES.NEAREST;
      this.tileWidth = data.tilewidth;
      this.tileHeight = data.tileheight;
      this.tileCount = data.tilecount;
      this.animatedTile = new Map();
      if (data.tile) {
        const tiles = Array.isArray(data.tile) ? data.tile : [data.tile];
        tiles.forEach((tile) => this.addAnimatedTile(tile));
      }
      const {margin, image} = data;
      for (let y2 = margin; y2 < image.height; y2 += this.tileHeight) {
        for (let x2 = margin; x2 < image.width; x2 += this.tileWidth) {
          const tileRectangle = new PIXI7.Rectangle(x2, y2, this.tileWidth, this.tileHeight);
          const texture = new PIXI7.Texture(this.baseTexture, tileRectangle);
          this.textures.push(texture);
        }
      }
      if (this.debug) {
        console.log(`[INFO] Loaded TiledSet name '${this.name}' with '${this.textures.length}' textures!`);
      }
      _TiledSet.cache.push(this);
    }
    addAnimatedTile(tile) {
      if (!tile.animation) {
        return;
      }
      this.animatedTile.set(tile.id, tile.animation.frame);
    }
    getTexture(id) {
      const realId = id - this.firstgid;
      const animated = this.animatedTile.has(realId);
      return {
        gid: this.firstgid,
        animated,
        texture: this.textures[realId],
        frames: animated ? this.animatedTile.get(realId) : null
      };
    }
  };
  var TiledSet = _TiledSet;
  __publicField(TiledSet, "cache", []);
  __publicField(TiledSet, "loaded", new Set());
  var tiledset_default = TiledSet;

  // assets/scripts/ECS/components/tiledlayer.js
  var PIXI8 = __toModule(require_pixi());
  var TiledLayer = class extends PIXI8.Container {
    static *iter(chunk) {
      const {width, height} = chunk;
      for (let y2 = 0; y2 < height; y2++) {
        for (let x2 = 0; x2 < width; x2++) {
          const tileIndex = x2 + y2 * width;
          const textureId = chunk.data[tileIndex];
          yield {x: chunk.x + x2, y: chunk.y + y2, textureId};
        }
      }
    }
    constructor(layer, parent) {
      super();
      const {name, opacity, visible} = layer;
      Object.assign(this, {name, opacity, visible});
      this.parent = parent;
      this.tiles = [];
      tiledmap_default.assignProperties(this, layer.properties);
      if ("chunks" in layer) {
        layer.chunks.forEach((chunk) => this.generate(chunk));
      } else if ("data" in layer) {
        this.generate(layer);
      }
      if (this.parent.debug) {
        console.log(`[INFO] Loaded TiledLayer '${this.name}'`);
      }
    }
    generate(chunk) {
      chunk.data = typeof chunk.data === "string" ? JSON.parse(chunk.data) : chunk.data;
      for (const {x: x2, y: y2, textureId} of TiledLayer.iter(chunk)) {
        if (textureId === 0) {
          continue;
        }
        const tile = this.createTile(x2, y2, textureId);
        this.tiles.push(tile);
        this.addChild(tile);
      }
    }
    createTile(x2, y2, textureId) {
      const {gid, animated, texture, frames} = this.parent.getTexture(textureId);
      let tile;
      if (animated) {
        const textures = frames.map((frame) => this.parent.getTexture(gid + frame.tileid).texture);
        tile = new PIXI8.AnimatedSprite(textures);
        if (tile.textures.length > 1) {
          tile.animationSpeed = 1e3 / 60 / frames[0].duration;
          tile.gotoAndPlay(0);
        }
      } else {
        tile = new PIXI8.Sprite(texture);
      }
      tile.x = x2 * this.parent.tileWidth;
      tile.y = y2 * this.parent.tileHeight;
      return tile;
    }
  };
  var tiledlayer_default = TiledLayer;

  // assets/scripts/ECS/components/collisionLayer.class.js
  var PIXI9 = __toModule(require_pixi());
  var CollisionLayer = class extends PIXI9.Container {
    constructor(layer, parent) {
      super();
      this.width = layer.width;
      this.height = layer.height;
      this.tileWidth = parent.tileWidth;
      this.tileHeight = parent.tileHeight;
      this.collisionsMap = new Set();
      if ("chunks" in layer) {
        layer.chunks.forEach((chunk) => this.generate(chunk));
      } else if ("data" in layer) {
        this.generate(layer);
      }
    }
    generate(chunk, offset = null) {
      chunk.data = typeof chunk.data === "string" ? JSON.parse(chunk.data) : chunk.data;
      const xOffset = offset === null ? 0 : offset.x / this.tileWidth;
      const yOffset = offset === null ? 0 : offset.y / this.tileHeight;
      for (const {x: x2, y: y2, textureId} of tiledlayer_default.iter(chunk)) {
        if (textureId !== 0) {
          this.collisionsMap.add(`${x2 + xOffset}|${y2 + yOffset}`);
        }
      }
    }
    getNeighBourWalkable(x2, y2) {
      const posx = Math.floor(x2 / this.tileWidth);
      const posy = Math.floor(y2 / this.tileHeight);
      const leftX = posx - 1;
      const rightX = posx + 1;
      const topY = posy - 1;
      const bottomY = posy;
      return {
        diag: {
          leftTop: this.isRawWalkable(leftX, topY),
          rightTop: this.isRawWalkable(rightX, topY),
          leftBottom: this.isRawWalkable(leftX, bottomY),
          bottom: this.isRawWalkable(rightX, bottomY)
        },
        left: this.isRawWalkable(leftX, posy),
        right: this.isRawWalkable(rightX, posy),
        top: this.isRawWalkable(posx, topY),
        bottom: this.isRawWalkable(posx, bottomY)
      };
    }
    getTilePosition(x2, y2) {
      return {
        x: Math.floor(x2 / this.tileWidth),
        y: Math.floor(y2 / this.tileHeight)
      };
    }
    isRawWalkable(x2, y2) {
      return this.collisionsMap.has(`${x2}|${y2}`);
    }
    isWalkable(x2, y2) {
      const posx = Math.floor(x2 / this.tileWidth);
      const posy = Math.floor(y2 / this.tileHeight);
      return this.collisionsMap.has(`${posx}|${posy}`);
    }
  };
  var collisionLayer_class_default = CollisionLayer;

  // assets/scripts/ECS/components/tiledmap.js
  var kCollisionLayerName = new Set(["collisions", "collision"]);
  var _TiledMap = class extends PIXI10.Container {
    static assignProperties(object, properties = []) {
      object.tileProperties = Object.create(null);
      for (const property of properties) {
        object.tileProperties[property.name] = property.value;
      }
    }
    constructor(mapName, options = {}) {
      super();
      assignSymbols(this);
      this.name = mapName;
      this.debug = options.debug || false;
      this.useSharedCollision = options.useSharedCollision || false;
      this.collisionOffset = options.collisionOffset || null;
      this.layers = new Map();
      this.objects = new Map();
      this.tiledSetMatcher = new Map();
      this.textureIdCache = new Map();
      const data = findAsset(mapName).data;
      this.tileWidth = data.tilewidth;
      this.tileHeight = data.tileheight;
      data.tilesets.filter((config) => !tiledset_default.loaded.has(config.name)).forEach((config) => new tiledset_default(config, {debug: this.debug}));
      this.dataLayers = data.layers;
      let lastTiledSet = null;
      for (const currentTiledSet of tiledset_default.cache) {
        if (lastTiledSet !== null) {
          this.setMatcher(lastTiledSet, currentTiledSet.firstgid);
        }
        lastTiledSet = currentTiledSet;
      }
      this.setMatcher(lastTiledSet, lastTiledSet.firstgid + lastTiledSet.tileCount);
    }
    init() {
      for (const layer of this.dataLayers) {
        switch (layer.type) {
          case "tilelayer":
            this.setTileLayer(layer);
            break;
          case "objectgroup":
            this.setObjects(layer);
            break;
        }
      }
      this.textureIdCache.clear();
      this.dataLayers = null;
      if (this.debug) {
        console.log(`[INFO] loaded TiledMap ${this.name}`);
      }
    }
    get collision() {
      return this.useSharedCollision ? _TiledMap.sharedCollisionLayer : this.layers.get("collision") || null;
    }
    setMatcher(lastTiledSet, currentgid) {
      const lastgid = lastTiledSet.firstgid;
      const matchPattern = (id) => id >= lastgid && id < currentgid;
      if (this.debug) {
        console.log(`[DEBUG] Loaded gid: >= ${lastgid} && < ${currentgid} for tiledsed '${lastTiledSet.name}'`);
      }
      this.tiledSetMatcher.set(matchPattern, lastTiledSet);
    }
    getTexture(id) {
      if (this.textureIdCache.has(id)) {
        return this.textureIdCache.get(id);
      }
      for (const [isMatching, tileSet] of this.tiledSetMatcher.entries()) {
        if (isMatching(id)) {
          const texture = tileSet.getTexture(id);
          this.textureIdCache.set(id, texture);
          return texture;
        }
      }
      return null;
    }
    drawObjectShape(object) {
      const {name, width, height, x: x2, y: y2} = object;
      const actor = new actor_class_default(name);
      actor.width = width;
      actor.height = height;
      actor.position.set(x2, y2);
      actor.rotation = object.rotation;
      _TiledMap.assignProperties(actor, object.properties);
      if (this.debug) {
        const areaGraphic = new PIXI10.Graphics().beginFill(16777215, 0.35);
        if (object.ellipse) {
          areaGraphic.drawEllipse(0, 0, width, height);
        } else {
          areaGraphic.drawRect(0, 0, width, height);
        }
        areaGraphic.interactive = true;
        const areaNameText = new PIXI10.Text(name.toLowerCase(), {
          fill: "#12d94d",
          fontFamily: "Verdana",
          fontSize: 10,
          fontVariant: "small-caps",
          fontWeight: "bold",
          letterSpacing: 1,
          lineJoin: "round",
          strokeThickness: 2,
          align: "center"
        });
        areaNameText.anchor.set(0.5);
        areaGraphic.endFill();
        if (!object.ellipse) {
          areaNameText.position.set(areaGraphic.width / 2, areaGraphic.height / 2);
        }
        areaGraphic.addChild(areaNameText);
        actor.addChild(areaGraphic);
      }
      this.objects.set(actor.name, actor);
      this.emit("object", actor);
      return actor;
    }
    setObjects(layer) {
      const objects = layer.objects || [];
      for (const object of objects) {
        console.log(`[INFO] create object ${object.name}`);
        this.addChild(this.drawObjectShape(object));
      }
    }
    setTileLayer(layer) {
      if (kCollisionLayerName.has(layer.name.toLowerCase())) {
        layer.visible = true;
        let colLayer = null;
        if (this.useSharedCollision) {
          if (_TiledMap.sharedCollisionLayer === null) {
            colLayer = new collisionLayer_class_default(layer, this);
            _TiledMap.sharedCollisionLayer = colLayer;
          } else {
            colLayer = _TiledMap.sharedCollisionLayer;
            if ("chunks" in layer) {
              layer.chunks.forEach((chunk) => colLayer.generate(chunk, this.collisionOffset));
            } else if ("data" in layer) {
              colLayer.generate(layer, this.collisionOffset);
            }
          }
        } else {
          colLayer = new collisionLayer_class_default(layer, this);
        }
        this.layers.set("collision", colLayer);
      } else {
        const tileLayer = new tiledlayer_default(layer, this);
        this.layers.set(layer.name, tileLayer);
        this.addChild(tileLayer);
      }
    }
  };
  var TiledMap = _TiledMap;
  __publicField(TiledMap, "sharedCollisionLayer", null);
  var tiledmap_default = TiledMap;

  // assets/scripts/ECS/component.js
  var kSymComponent = Symbol("component");
  var kSymComponentType = Symbol("componentType");
  var Types = Object.freeze({
    AnimatedSpriteEx: "AnimatedSpriteEx",
    AnimatedSprite: "AnimatedSprite",
    Sprite: "Sprite",
    TiledMap: "TiledMap"
  });
  function isComponent(object) {
    if (!object[kSymComponent]) {
      throw new Error("Not a component!");
    }
  }
  function assignSymbols(object) {
    let type2 = null;
    if (object instanceof animatedsprite_class_default) {
      type2 = Types.AnimatedSpriteEx;
    } else if (object instanceof tiledmap_default) {
      type2 = Types.TiledMap;
    } else if (object instanceof PIXI11.AnimatedSprite) {
      type2 = Types.AnimatedSprite;
    } else if (object instanceof PIXI11.Sprite) {
      type2 = Types.Sprite;
    } else {
      throw new Error("No known type for object");
    }
    Object.defineProperty(object, kSymComponent, {value: true});
    Object.defineProperty(object, kSymComponentType, {value: type2});
    object.linkActorToComponent = (actor) => {
      switch (type2) {
        case "AnimatedSpriteEx":
        case "AnimatedSprite":
        case "Sprite":
          actor.sprite = object;
          break;
        case "TiledMap":
          actor.map = object;
      }
    };
  }
  function type(component) {
    return component[kSymComponentType];
  }

  // assets/scripts/ECS/math/vector2.js
  var Vector2 = class {
    static randomCoordInRadius(radius = 100) {
      const r2 = radius * Math.sqrt(Math.random());
      const theta = Math.random() * 2 * Math.PI;
      return new Vector2(Math.round(0 + r2 * Math.cos(theta)), Math.round(0 + r2 * Math.sin(theta)));
    }
    constructor(x2 = 0, y2 = 0) {
      this.x = x2;
      this.y = y2;
    }
    set(x2, y2) {
      this.x = x2;
      this.y = y2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      return this;
    }
    add(v2) {
      this.x += v2.x;
      this.y += v2.y;
      return this;
    }
    addScalar(s3) {
      this.x += s3;
      this.y += s3;
      return this;
    }
    addVectors(a2, b2) {
      this.x = a2.x + b2.x;
      this.y = a2.y + b2.y;
      return this;
    }
    addScaledVector(v2, s3) {
      this.x += v2.x * s3;
      this.y += v2.y * s3;
      return this;
    }
    sub(v2) {
      this.x -= v2.x;
      this.y -= v2.y;
      return this;
    }
    subScalar(s3) {
      this.x -= s3;
      this.y -= s3;
      return this;
    }
    subVectors(a2, b2) {
      this.x = a2.x - b2.x;
      this.y = a2.y - b2.y;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v2) {
      this.x /= v2.x;
      this.y /= v2.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m2) {
      const x2 = this.x, y2 = this.y;
      const e2 = m2.elements;
      this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
      this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
      return this;
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y;
    }
    cross(v2) {
      return this.x * v2.y - this.y * v2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v2) {
      return Math.sqrt(this.distanceToSquared(v2));
    }
    distanceToSquared(v2) {
      const dx = this.x - v2.x, dy = this.y - v2.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v2) {
      return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center2, angle) {
      const c2 = Math.cos(angle), s3 = Math.sin(angle);
      const x2 = this.x - center2.x;
      const y2 = this.y - center2.y;
      this.x = x2 * c2 - y2 * s3 + center2.x;
      this.y = x2 * s3 + y2 * c2 + center2.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  };
  var vector2_default = Vector2;

  // assets/scripts/ECS/actor.class.js
  var Actor = class extends actortree_class_default {
    constructor(name) {
      super();
      this.destroyed = false;
      this.name = name;
      this.vx = 0;
      this.vy = 0;
      this.wasMoving = false;
      this.sprite = null;
      this.map = null;
      this.behaviors = [];
      this.components = [];
      this.on("destroy", this.cleanup.bind(this));
    }
    cleanup() {
      if (this.sprite) {
        this.sprite.destroy();
      }
      this.destroy({
        children: true,
        texture: true,
        baseTexture: true
      });
      this.destroyed = true;
    }
    moveX(x2 = 0) {
      this.vx += x2;
    }
    moveY(y2 = 0) {
      this.vy += y2;
    }
    get moving() {
      return this.wasMoving || this.vx !== 0 || this.vy !== 0;
    }
    get pos() {
      return new vector2_default(this.x, this.y);
    }
    set pos(vec) {
      this.position.set(vec.x, vec.y);
    }
    get centerPosition() {
      return new vector2_default(this.x + this.width / 2, this.y + this.height / 2);
    }
    applyVelocity() {
      if (this.vx === 0 && this.vy === 0) {
        this.wasMoving = false;
        return;
      }
      if (this.vx !== 0 && this.vy !== 0) {
        this.vx = this.vx / 1.5;
        this.vy = this.vy / 1.5;
      }
      this.x += this.vx;
      this.y += this.vy;
      this.wasMoving = true;
      this.vx = 0;
      this.vy = 0;
    }
    addComponent(component) {
      isComponent(component);
      component.linkActorToComponent(this);
      this.components.push(component);
      this.addChild(component);
      return component;
    }
    getComponent(type2) {
      return this.components.find((comp) => type(comp) === type2);
    }
    getAllComponent(type2) {
      return this.components.filter((comp) => type(comp) === type2);
    }
    createScriptedBehavior(scriptInstance, ...options) {
      if (typeof scriptInstance === "string") {
        const classInstance = scriptbehavior_default.cache.get(scriptInstance);
        if (typeof classInstance === "undefined") {
          throw new Error(`Unable to found Behavior with name: ${scriptInstance}. Please make sure the script is exported in behaviours/index.js and well defined too!`);
        }
        scriptInstance = new classInstance(...options);
      }
      scriptInstance.actor = this;
      this.behaviors.push(scriptInstance);
      return this;
    }
    getScriptedBehavior(name) {
      return this.behaviors.find((object) => object.constructor.name === name);
    }
    sendMessage(name, options = {}, ...args) {
      const toBehaviors = new Set(options.scripts || []);
      for (const behavior of this.behaviors) {
        if (toBehaviors.size === 0 || toBehaviors.has(behavior.constructor.name)) {
          behavior.sendMessage(name, ...args);
        }
      }
    }
    triggerBehaviorEvent(eventName, ...args) {
      if (this.destroyed) {
        return;
      }
      for (const actor of this.getActorsFromComponents()) {
        actor.triggerBehaviorEvent(eventName, ...args);
      }
      for (const behavior of this.behaviors) {
        behavior.emit(eventName, ...args);
        behavior[eventName](...args);
      }
    }
  };
  var actor_class_default = Actor;

  // assets/scripts/ECS/engine.class.js
  var PIXI17 = __toModule(require_pixi());

  // node_modules/pixi-viewport/dist/viewport.es.js
  var PIXI13 = __toModule(require_pixi());
  var import_pixi = __toModule(require_pixi());
  var InputManager = class {
    constructor(viewport) {
      this.viewport = viewport;
      this.touches = [];
      this.addListeners();
    }
    addListeners() {
      this.viewport.interactive = true;
      if (!this.viewport.forceHitArea) {
        this.viewport.hitArea = new import_pixi.Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight);
      }
      this.viewport.on("pointerdown", this.down, this);
      this.viewport.on("pointermove", this.move, this);
      this.viewport.on("pointerup", this.up, this);
      this.viewport.on("pointerupoutside", this.up, this);
      this.viewport.on("pointercancel", this.up, this);
      this.viewport.on("pointerout", this.up, this);
      this.wheelFunction = (e2) => this.handleWheel(e2);
      this.viewport.options.divWheel.addEventListener("wheel", this.wheelFunction, {passive: this.viewport.options.passiveWheel});
      this.isMouseDown = false;
    }
    destroy() {
      this.viewport.options.divWheel.removeEventListener("wheel", this.wheelFunction);
    }
    down(event) {
      if (this.viewport.pause || !this.viewport.worldVisible) {
        return;
      }
      if (event.data.pointerType === "mouse") {
        this.isMouseDown = true;
      } else if (!this.get(event.data.pointerId)) {
        this.touches.push({id: event.data.pointerId, last: null});
      }
      if (this.count() === 1) {
        this.last = event.data.global.clone();
        const decelerate = this.viewport.plugins.get("decelerate", true);
        const bounce = this.viewport.plugins.get("bounce", true);
        if ((!decelerate || !decelerate.isActive()) && (!bounce || !bounce.isActive())) {
          this.clickedAvailable = true;
        } else {
          this.clickedAvailable = false;
        }
      } else {
        this.clickedAvailable = false;
      }
      const stop = this.viewport.plugins.down(event);
      if (stop && this.viewport.options.stopPropagation) {
        event.stopPropagation();
      }
    }
    clear() {
      this.isMouseDown = false;
      this.touches = [];
      this.last = null;
    }
    checkThreshold(change) {
      if (Math.abs(change) >= this.viewport.threshold) {
        return true;
      }
      return false;
    }
    move(event) {
      if (this.viewport.pause || !this.viewport.worldVisible) {
        return;
      }
      const stop = this.viewport.plugins.move(event);
      if (this.clickedAvailable) {
        const distX = event.data.global.x - this.last.x;
        const distY = event.data.global.y - this.last.y;
        if (this.checkThreshold(distX) || this.checkThreshold(distY)) {
          this.clickedAvailable = false;
        }
      }
      if (stop && this.viewport.options.stopPropagation) {
        event.stopPropagation();
      }
    }
    up(event) {
      if (this.viewport.pause || !this.viewport.worldVisible) {
        return;
      }
      if (event.data.pointerType === "mouse") {
        this.isMouseDown = false;
      }
      if (event.data.pointerType !== "mouse") {
        this.remove(event.data.pointerId);
      }
      const stop = this.viewport.plugins.up(event);
      if (this.clickedAvailable && this.count() === 0) {
        this.viewport.emit("clicked", {event, screen: this.last, world: this.viewport.toWorld(this.last), viewport: this});
        this.clickedAvailable = false;
      }
      if (stop && this.viewport.options.stopPropagation) {
        event.stopPropagation();
      }
    }
    getPointerPosition(event) {
      let point = new import_pixi.Point();
      if (this.viewport.options.interaction) {
        this.viewport.options.interaction.mapPositionToPoint(point, event.clientX, event.clientY);
      } else {
        point.x = event.clientX;
        point.y = event.clientY;
      }
      return point;
    }
    handleWheel(event) {
      if (this.viewport.pause || !this.viewport.worldVisible) {
        return;
      }
      if (this.viewport.options.interaction && this.viewport.options.interaction.interactionDOMElement !== event.target) {
        return;
      }
      const point = this.viewport.toLocal(this.getPointerPosition(event));
      if (this.viewport.left <= point.x && point.x <= this.viewport.right && this.viewport.top <= point.y && point.y <= this.viewport.bottom) {
        const stop = this.viewport.plugins.wheel(event);
        if (stop && !this.viewport.options.passiveWheel) {
          event.preventDefault();
        }
      }
    }
    pause() {
      this.touches = [];
      this.isMouseDown = false;
    }
    get(id) {
      for (let touch of this.touches) {
        if (touch.id === id) {
          return touch;
        }
      }
      return null;
    }
    remove(id) {
      for (let i2 = 0; i2 < this.touches.length; i2++) {
        if (this.touches[i2].id === id) {
          this.touches.splice(i2, 1);
          return;
        }
      }
    }
    count() {
      return (this.isMouseDown ? 1 : 0) + this.touches.length;
    }
  };
  var PLUGIN_ORDER = ["drag", "pinch", "wheel", "follow", "mouse-edges", "decelerate", "aniamte", "bounce", "snap-zoom", "clamp-zoom", "snap", "clamp"];
  var PluginManager = class {
    constructor(viewport) {
      this.viewport = viewport;
      this.list = [];
      this.plugins = {};
    }
    add(name, plugin, index = PLUGIN_ORDER.length) {
      this.plugins[name] = plugin;
      const current = PLUGIN_ORDER.indexOf(name);
      if (current !== -1) {
        PLUGIN_ORDER.splice(current, 1);
      }
      PLUGIN_ORDER.splice(index, 0, name);
      this.sort();
    }
    get(name, ignorePaused) {
      if (ignorePaused) {
        if (this.plugins[name] && this.plugins[name].paused) {
          return null;
        }
      }
      return this.plugins[name];
    }
    update(elapsed) {
      for (let plugin of this.list) {
        plugin.update(elapsed);
      }
    }
    resize() {
      for (let plugin of this.list) {
        plugin.resize();
      }
    }
    reset() {
      for (let plugin of this.list) {
        plugin.reset();
      }
    }
    removeAll() {
      this.plugins = {};
      this.sort();
    }
    remove(name) {
      if (this.plugins[name]) {
        delete this.plugins[name];
        this.viewport.emit(name + "-remove");
        this.sort();
      }
    }
    pause(name) {
      if (this.plugins[name]) {
        this.plugins[name].pause();
      }
    }
    resume(name) {
      if (this.plugins[name]) {
        this.plugins[name].resume();
      }
    }
    sort() {
      this.list = [];
      for (let plugin of PLUGIN_ORDER) {
        if (this.plugins[plugin]) {
          this.list.push(this.plugins[plugin]);
        }
      }
    }
    down(event) {
      let stop = false;
      for (let plugin of this.list) {
        if (plugin.down(event)) {
          stop = true;
        }
      }
      return stop;
    }
    move(event) {
      let stop = false;
      for (let plugin of this.viewport.plugins.list) {
        if (plugin.move(event)) {
          stop = true;
        }
      }
      return stop;
    }
    up(event) {
      let stop = false;
      for (let plugin of this.list) {
        if (plugin.up(event)) {
          stop = true;
        }
      }
      return stop;
    }
    wheel(e2) {
      let result = false;
      for (let plugin of this.list) {
        if (plugin.wheel(e2)) {
          result = true;
        }
      }
      return result;
    }
  };
  var Plugin = class {
    constructor(parent) {
      this.parent = parent;
      this.paused = false;
    }
    destroy() {
    }
    down() {
      return false;
    }
    move() {
      return false;
    }
    up() {
      return false;
    }
    wheel() {
      return false;
    }
    update() {
    }
    resize() {
    }
    reset() {
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
    }
  };
  var dragOptions = {
    direction: "all",
    pressDrag: true,
    wheel: true,
    wheelScroll: 1,
    reverse: false,
    clampWheel: false,
    underflow: "center",
    factor: 1,
    mouseButtons: "all",
    keyToPress: null,
    ignoreKeyToPressOnTouch: false,
    lineHeight: 20
  };
  var Drag = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, dragOptions, options);
      this.moved = false;
      this.reverse = this.options.reverse ? 1 : -1;
      this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x";
      this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y";
      this.keyIsPressed = false;
      this.parseUnderflow();
      this.mouseButtons(this.options.mouseButtons);
      if (this.options.keyToPress) {
        this.handleKeyPresses(this.options.keyToPress);
      }
    }
    handleKeyPresses(codes) {
      window.addEventListener("keydown", (e2) => {
        if (codes.includes(e2.code))
          this.keyIsPressed = true;
      });
      window.addEventListener("keyup", (e2) => {
        if (codes.includes(e2.code))
          this.keyIsPressed = false;
      });
    }
    mouseButtons(buttons) {
      if (!buttons || buttons === "all") {
        this.mouse = [true, true, true];
      } else {
        this.mouse = [
          buttons.indexOf("left") === -1 ? false : true,
          buttons.indexOf("middle") === -1 ? false : true,
          buttons.indexOf("right") === -1 ? false : true
        ];
      }
    }
    parseUnderflow() {
      const clamp = this.options.underflow.toLowerCase();
      if (clamp === "center") {
        this.underflowX = 0;
        this.underflowY = 0;
      } else {
        this.underflowX = clamp.indexOf("left") !== -1 ? -1 : clamp.indexOf("right") !== -1 ? 1 : 0;
        this.underflowY = clamp.indexOf("top") !== -1 ? -1 : clamp.indexOf("bottom") !== -1 ? 1 : 0;
      }
    }
    checkButtons(event) {
      const isMouse = event.data.pointerType === "mouse";
      const count = this.parent.input.count();
      if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
        if (!isMouse || this.mouse[event.data.button]) {
          return true;
        }
      }
      return false;
    }
    checkKeyPress(event) {
      if (!this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && event.data.pointerType === "touch")
        return true;
      return false;
    }
    down(event) {
      if (this.paused || !this.options.pressDrag) {
        return;
      }
      if (this.checkButtons(event) && this.checkKeyPress(event)) {
        this.last = {x: event.data.global.x, y: event.data.global.y};
        this.current = event.data.pointerId;
        return true;
      } else {
        this.last = null;
      }
    }
    get active() {
      return this.moved;
    }
    move(event) {
      if (this.paused || !this.options.pressDrag) {
        return;
      }
      if (this.last && this.current === event.data.pointerId) {
        const x2 = event.data.global.x;
        const y2 = event.data.global.y;
        const count = this.parent.input.count();
        if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
          const distX = x2 - this.last.x;
          const distY = y2 - this.last.y;
          if (this.moved || (this.xDirection && this.parent.input.checkThreshold(distX) || this.yDirection && this.parent.input.checkThreshold(distY))) {
            const newPoint = {x: x2, y: y2};
            if (this.xDirection) {
              this.parent.x += (newPoint.x - this.last.x) * this.options.factor;
            }
            if (this.yDirection) {
              this.parent.y += (newPoint.y - this.last.y) * this.options.factor;
            }
            this.last = newPoint;
            if (!this.moved) {
              this.parent.emit("drag-start", {event, screen: new import_pixi.Point(this.last.x, this.last.y), world: this.parent.toWorld(new import_pixi.Point(this.last.x, this.last.y)), viewport: this.parent});
            }
            this.moved = true;
            this.parent.emit("moved", {viewport: this.parent, type: "drag"});
            return true;
          }
        } else {
          this.moved = false;
        }
      }
    }
    up(event) {
      if (this.paused) {
        return;
      }
      const touches = this.parent.input.touches;
      if (touches.length === 1) {
        const pointer = touches[0];
        if (pointer.last) {
          this.last = {x: pointer.last.x, y: pointer.last.y};
          this.current = pointer.id;
        }
        this.moved = false;
        return true;
      } else if (this.last) {
        if (this.moved) {
          const screen = new import_pixi.Point(this.last.x, this.last.y);
          this.parent.emit("drag-end", {event, screen, world: this.parent.toWorld(screen), viewport: this.parent});
          this.last = null;
          this.moved = false;
          return true;
        }
      }
    }
    wheel(event) {
      if (this.paused) {
        return;
      }
      if (this.options.wheel) {
        const wheel = this.parent.plugins.get("wheel", true);
        if (!wheel) {
          const step = event.deltaMode ? this.options.lineHeight : 1;
          if (this.xDirection) {
            this.parent.x += event.deltaX * step * this.options.wheelScroll * this.reverse;
          }
          if (this.yDirection) {
            this.parent.y += event.deltaY * step * this.options.wheelScroll * this.reverse;
          }
          if (this.options.clampWheel) {
            this.clamp();
          }
          this.parent.emit("wheel-scroll", this.parent);
          this.parent.emit("moved", {viewport: this.parent, type: "wheel"});
          if (!this.parent.options.passiveWheel) {
            event.preventDefault();
          }
          return true;
        }
      }
    }
    resume() {
      this.last = null;
      this.paused = false;
    }
    clamp() {
      const decelerate = this.parent.plugins.get("decelerate", true) || {};
      if (this.options.clampWheel !== "y") {
        if (this.parent.screenWorldWidth < this.parent.screenWidth) {
          switch (this.underflowX) {
            case -1:
              this.parent.x = 0;
              break;
            case 1:
              this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
              break;
            default:
              this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
          }
        } else {
          if (this.parent.left < 0) {
            this.parent.x = 0;
            decelerate.x = 0;
          } else if (this.parent.right > this.parent.worldWidth) {
            this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth;
            decelerate.x = 0;
          }
        }
      }
      if (this.options.clampWheel !== "x") {
        if (this.parent.screenWorldHeight < this.parent.screenHeight) {
          switch (this.underflowY) {
            case -1:
              this.parent.y = 0;
              break;
            case 1:
              this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
              break;
            default:
              this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
          }
        } else {
          if (this.parent.top < 0) {
            this.parent.y = 0;
            decelerate.y = 0;
          }
          if (this.parent.bottom > this.parent.worldHeight) {
            this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight;
            decelerate.y = 0;
          }
        }
      }
    }
  };
  var pinchOptions = {
    noDrag: false,
    percent: 1,
    center: null,
    factor: 1,
    axis: "all"
  };
  var Pinch = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, pinchOptions, options);
    }
    down() {
      if (this.parent.input.count() >= 2) {
        this.active = true;
        return true;
      }
    }
    isAxisX() {
      return ["all", "x"].includes(this.options.axis);
    }
    isAxisY() {
      return ["all", "y"].includes(this.options.axis);
    }
    move(e2) {
      if (this.paused || !this.active) {
        return;
      }
      const x2 = e2.data.global.x;
      const y2 = e2.data.global.y;
      const pointers = this.parent.input.touches;
      if (pointers.length >= 2) {
        const first = pointers[0];
        const second = pointers[1];
        const last = first.last && second.last ? Math.sqrt(Math.pow(second.last.x - first.last.x, 2) + Math.pow(second.last.y - first.last.y, 2)) : null;
        if (first.id === e2.data.pointerId) {
          first.last = {x: x2, y: y2, data: e2.data};
        } else if (second.id === e2.data.pointerId) {
          second.last = {x: x2, y: y2, data: e2.data};
        }
        if (last) {
          let oldPoint;
          const point = {x: first.last.x + (second.last.x - first.last.x) / 2, y: first.last.y + (second.last.y - first.last.y) / 2};
          if (!this.options.center) {
            oldPoint = this.parent.toLocal(point);
          }
          let dist = Math.sqrt(Math.pow(second.last.x - first.last.x, 2) + Math.pow(second.last.y - first.last.y, 2));
          dist = dist === 0 ? dist = 1e-10 : dist;
          const change = (1 - last / dist) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
          if (this.isAxisX()) {
            this.parent.scale.x += change;
          }
          if (this.isAxisY()) {
            this.parent.scale.y += change;
          }
          this.parent.emit("zoomed", {viewport: this.parent, type: "pinch", center: point});
          const clamp = this.parent.plugins.get("clamp-zoom", true);
          if (clamp) {
            clamp.clamp();
          }
          if (this.options.center) {
            this.parent.moveCenter(this.options.center);
          } else {
            const newPoint = this.parent.toGlobal(oldPoint);
            this.parent.x += (point.x - newPoint.x) * this.options.factor;
            this.parent.y += (point.y - newPoint.y) * this.options.factor;
            this.parent.emit("moved", {viewport: this.parent, type: "pinch"});
          }
          if (!this.options.noDrag && this.lastCenter) {
            this.parent.x += (point.x - this.lastCenter.x) * this.options.factor;
            this.parent.y += (point.y - this.lastCenter.y) * this.options.factor;
            this.parent.emit("moved", {viewport: this.parent, type: "pinch"});
          }
          this.lastCenter = point;
          this.moved = true;
        } else {
          if (!this.pinching) {
            this.parent.emit("pinch-start", this.parent);
            this.pinching = true;
          }
        }
        return true;
      }
    }
    up() {
      if (this.pinching) {
        if (this.parent.input.touches.length <= 1) {
          this.active = false;
          this.lastCenter = null;
          this.pinching = false;
          this.moved = false;
          this.parent.emit("pinch-end", this.parent);
          return true;
        }
      }
    }
  };
  var clampOptions = {
    left: false,
    right: false,
    top: false,
    bottom: false,
    direction: null,
    underflow: "center"
  };
  var Clamp = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, clampOptions, options);
      if (this.options.direction) {
        this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null;
        this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null;
        this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null;
        this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null;
      }
      this.parseUnderflow();
      this.last = {x: null, y: null, scaleX: null, scaleY: null};
      this.update();
    }
    parseUnderflow() {
      const clamp = this.options.underflow.toLowerCase();
      if (clamp === "none") {
        this.noUnderflow = true;
      } else if (clamp === "center") {
        this.underflowX = this.underflowY = 0;
        this.noUnderflow = false;
      } else {
        this.underflowX = clamp.indexOf("left") !== -1 ? -1 : clamp.indexOf("right") !== -1 ? 1 : 0;
        this.underflowY = clamp.indexOf("top") !== -1 ? -1 : clamp.indexOf("bottom") !== -1 ? 1 : 0;
        this.noUnderflow = false;
      }
    }
    move() {
      this.update();
      return false;
    }
    update() {
      if (this.paused) {
        return;
      }
      if (this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY) {
        return;
      }
      const original = {x: this.parent.x, y: this.parent.y};
      const decelerate = this.parent.plugins["decelerate"] || {};
      if (this.options.left !== null || this.options.right !== null) {
        let moved = false;
        if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth) {
          switch (this.underflowX) {
            case -1:
              if (this.parent.x !== 0) {
                this.parent.x = 0;
                moved = true;
              }
              break;
            case 1:
              if (this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth) {
                this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
                moved = true;
              }
              break;
            default:
              if (this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2) {
                this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
                moved = true;
              }
          }
        } else {
          if (this.options.left !== null) {
            if (this.parent.left < (this.options.left === true ? 0 : this.options.left)) {
              this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x;
              decelerate.x = 0;
              moved = true;
            }
          }
          if (this.options.right !== null) {
            if (this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right)) {
              this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth;
              decelerate.x = 0;
              moved = true;
            }
          }
        }
        if (moved) {
          this.parent.emit("moved", {viewport: this.parent, original, type: "clamp-x"});
        }
      }
      if (this.options.top !== null || this.options.bottom !== null) {
        let moved = false;
        if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight) {
          switch (this.underflowY) {
            case -1:
              if (this.parent.y !== 0) {
                this.parent.y = 0;
                moved = true;
              }
              break;
            case 1:
              if (this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight) {
                this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
                moved = true;
              }
              break;
            default:
              if (this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2) {
                this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
                moved = true;
              }
          }
        } else {
          if (this.options.top !== null) {
            if (this.parent.top < (this.options.top === true ? 0 : this.options.top)) {
              this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y;
              decelerate.y = 0;
              moved = true;
            }
          }
          if (this.options.bottom !== null) {
            if (this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom)) {
              this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight;
              decelerate.y = 0;
              moved = true;
            }
          }
        }
        if (moved) {
          this.parent.emit("moved", {viewport: this.parent, original, type: "clamp-y"});
        }
      }
      this.last.x = this.parent.x;
      this.last.y = this.parent.y;
      this.last.scaleX = this.parent.scale.x;
      this.last.scaleY = this.parent.scale.y;
    }
    reset() {
      this.update();
    }
  };
  var clampZoomOptions = {
    minWidth: null,
    minHeight: null,
    maxWidth: null,
    maxHeight: null,
    minScale: null,
    maxScale: null
  };
  var ClampZoom = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, clampZoomOptions, options);
      this.clamp();
    }
    resize() {
      this.clamp();
    }
    clamp() {
      if (this.paused) {
        return;
      }
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let width = this.parent.worldScreenWidth;
        let height = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && width < this.options.minWidth) {
          const original = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true);
          this.parent.scale.y *= this.parent.scale.x / original;
          width = this.parent.worldScreenWidth;
          height = this.parent.worldScreenHeight;
          this.parent.emit("zoomed", {viewport: this.parent, type: "clamp-zoom"});
        }
        if (this.options.maxWidth !== null && width > this.options.maxWidth) {
          const original = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true);
          this.parent.scale.y *= this.parent.scale.x / original;
          width = this.parent.worldScreenWidth;
          height = this.parent.worldScreenHeight;
          this.parent.emit("zoomed", {viewport: this.parent, type: "clamp-zoom"});
        }
        if (this.options.minHeight !== null && height < this.options.minHeight) {
          const original = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true);
          this.parent.scale.x *= this.parent.scale.y / original;
          width = this.parent.worldScreenWidth;
          height = this.parent.worldScreenHeight;
          this.parent.emit("zoomed", {viewport: this.parent, type: "clamp-zoom"});
        }
        if (this.options.maxHeight !== null && height > this.options.maxHeight) {
          const original = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true);
          this.parent.scale.x *= this.parent.scale.y / original;
          this.parent.emit("zoomed", {viewport: this.parent, type: "clamp-zoom"});
        }
      } else {
        let scale = this.parent.scale.x;
        if (this.options.minScale !== null && scale < this.options.minScale) {
          scale = this.options.minScale;
        }
        if (this.options.maxScale !== null && scale > this.options.maxScale) {
          scale = this.options.maxScale;
        }
        if (scale !== this.parent.scale.x) {
          this.parent.scale.set(scale);
          this.parent.emit("zoomed", {viewport: this.parent, type: "clamp-zoom"});
        }
      }
    }
    reset() {
      this.clamp();
    }
  };
  var decelerateOptions = {
    friction: 0.98,
    bounce: 0.8,
    minSpeed: 0.01
  };
  var TP = 16;
  var Decelerate = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, decelerateOptions, options);
      this.saved = [];
      this.timeSinceRelease = 0;
      this.reset();
      this.parent.on("moved", (data) => this.moved(data));
    }
    destroy() {
      this.parent;
    }
    down() {
      this.saved = [];
      this.x = this.y = false;
    }
    isActive() {
      return this.x || this.y;
    }
    move() {
      if (this.paused) {
        return;
      }
      const count = this.parent.input.count();
      if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
        this.saved.push({x: this.parent.x, y: this.parent.y, time: performance.now()});
        if (this.saved.length > 60) {
          this.saved.splice(0, 30);
        }
      }
    }
    moved(data) {
      if (this.saved.length) {
        const last = this.saved[this.saved.length - 1];
        if (data.type === "clamp-x") {
          if (last.x === data.original.x) {
            last.x = this.parent.x;
          }
        } else if (data.type === "clamp-y") {
          if (last.y === data.original.y) {
            last.y = this.parent.y;
          }
        }
      }
    }
    up() {
      if (this.parent.input.count() === 0 && this.saved.length) {
        const now = performance.now();
        for (let save of this.saved) {
          if (save.time >= now - 100) {
            const time = now - save.time;
            this.x = (this.parent.x - save.x) / time;
            this.y = (this.parent.y - save.y) / time;
            this.percentChangeX = this.percentChangeY = this.options.friction;
            this.timeSinceRelease = 0;
            break;
          }
        }
      }
    }
    activate(options) {
      options = options || {};
      if (typeof options.x !== "undefined") {
        this.x = options.x;
        this.percentChangeX = this.options.friction;
      }
      if (typeof options.y !== "undefined") {
        this.y = options.y;
        this.percentChangeY = this.options.friction;
      }
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      const moved = this.x || this.y;
      const ti = this.timeSinceRelease;
      const tf = this.timeSinceRelease + elapsed;
      if (this.x) {
        const k2 = this.percentChangeX;
        const lnk = Math.log(k2);
        this.parent.x += this.x * TP / lnk * (Math.pow(k2, tf / TP) - Math.pow(k2, ti / TP));
      }
      if (this.y) {
        const k2 = this.percentChangeY;
        const lnk = Math.log(k2);
        this.parent.y += this.y * TP / lnk * (Math.pow(k2, tf / TP) - Math.pow(k2, ti / TP));
      }
      this.timeSinceRelease += elapsed;
      this.x *= Math.pow(this.percentChangeX, elapsed / TP);
      this.y *= Math.pow(this.percentChangeY, elapsed / TP);
      if (Math.abs(this.x) < this.options.minSpeed) {
        this.x = 0;
      }
      if (Math.abs(this.y) < this.options.minSpeed) {
        this.y = 0;
      }
      if (moved) {
        this.parent.emit("moved", {viewport: this.parent, type: "decelerate"});
      }
    }
    reset() {
      this.x = this.y = null;
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn) {
    var module = {exports: {}};
    return fn(module, module.exports), module.exports;
  }
  var penner = createCommonjsModule(function(module, exports) {
    (function() {
      var penner2, umd;
      umd = function(factory) {
        {
          return module.exports = factory;
        }
      };
      penner2 = {
        linear: function(t2, b2, c2, d2) {
          return c2 * t2 / d2 + b2;
        },
        easeInQuad: function(t2, b2, c2, d2) {
          return c2 * (t2 /= d2) * t2 + b2;
        },
        easeOutQuad: function(t2, b2, c2, d2) {
          return -c2 * (t2 /= d2) * (t2 - 2) + b2;
        },
        easeInOutQuad: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * t2 * t2 + b2;
          } else {
            return -c2 / 2 * (--t2 * (t2 - 2) - 1) + b2;
          }
        },
        easeInCubic: function(t2, b2, c2, d2) {
          return c2 * (t2 /= d2) * t2 * t2 + b2;
        },
        easeOutCubic: function(t2, b2, c2, d2) {
          return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
        },
        easeInOutCubic: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * t2 * t2 * t2 + b2;
          } else {
            return c2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
          }
        },
        easeInQuart: function(t2, b2, c2, d2) {
          return c2 * (t2 /= d2) * t2 * t2 * t2 + b2;
        },
        easeOutQuart: function(t2, b2, c2, d2) {
          return -c2 * ((t2 = t2 / d2 - 1) * t2 * t2 * t2 - 1) + b2;
        },
        easeInOutQuart: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * t2 * t2 * t2 * t2 + b2;
          } else {
            return -c2 / 2 * ((t2 -= 2) * t2 * t2 * t2 - 2) + b2;
          }
        },
        easeInQuint: function(t2, b2, c2, d2) {
          return c2 * (t2 /= d2) * t2 * t2 * t2 * t2 + b2;
        },
        easeOutQuint: function(t2, b2, c2, d2) {
          return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 * t2 * t2 + 1) + b2;
        },
        easeInOutQuint: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * t2 * t2 * t2 * t2 * t2 + b2;
          } else {
            return c2 / 2 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2) + b2;
          }
        },
        easeInSine: function(t2, b2, c2, d2) {
          return -c2 * Math.cos(t2 / d2 * (Math.PI / 2)) + c2 + b2;
        },
        easeOutSine: function(t2, b2, c2, d2) {
          return c2 * Math.sin(t2 / d2 * (Math.PI / 2)) + b2;
        },
        easeInOutSine: function(t2, b2, c2, d2) {
          return -c2 / 2 * (Math.cos(Math.PI * t2 / d2) - 1) + b2;
        },
        easeInExpo: function(t2, b2, c2, d2) {
          if (t2 === 0) {
            return b2;
          } else {
            return c2 * Math.pow(2, 10 * (t2 / d2 - 1)) + b2;
          }
        },
        easeOutExpo: function(t2, b2, c2, d2) {
          if (t2 === d2) {
            return b2 + c2;
          } else {
            return c2 * (-Math.pow(2, -10 * t2 / d2) + 1) + b2;
          }
        },
        easeInOutExpo: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * Math.pow(2, 10 * (t2 - 1)) + b2;
          } else {
            return c2 / 2 * (-Math.pow(2, -10 * --t2) + 2) + b2;
          }
        },
        easeInCirc: function(t2, b2, c2, d2) {
          return -c2 * (Math.sqrt(1 - (t2 /= d2) * t2) - 1) + b2;
        },
        easeOutCirc: function(t2, b2, c2, d2) {
          return c2 * Math.sqrt(1 - (t2 = t2 / d2 - 1) * t2) + b2;
        },
        easeInOutCirc: function(t2, b2, c2, d2) {
          if ((t2 /= d2 / 2) < 1) {
            return -c2 / 2 * (Math.sqrt(1 - t2 * t2) - 1) + b2;
          } else {
            return c2 / 2 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1) + b2;
          }
        },
        easeInElastic: function(t2, b2, c2, d2) {
          var a2, p2, s3;
          s3 = 1.70158;
          p2 = 0;
          a2 = c2;
          if (t2 === 0)
            ;
          else if ((t2 /= d2) === 1)
            ;
          if (!p2) {
            p2 = d2 * 0.3;
          }
          if (a2 < Math.abs(c2)) {
            a2 = c2;
            s3 = p2 / 4;
          } else {
            s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
          }
          return -(a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * d2 - s3) * (2 * Math.PI) / p2)) + b2;
        },
        easeOutElastic: function(t2, b2, c2, d2) {
          var a2, p2, s3;
          s3 = 1.70158;
          p2 = 0;
          a2 = c2;
          if (t2 === 0)
            ;
          else if ((t2 /= d2) === 1)
            ;
          if (!p2) {
            p2 = d2 * 0.3;
          }
          if (a2 < Math.abs(c2)) {
            a2 = c2;
            s3 = p2 / 4;
          } else {
            s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
          }
          return a2 * Math.pow(2, -10 * t2) * Math.sin((t2 * d2 - s3) * (2 * Math.PI) / p2) + c2 + b2;
        },
        easeInOutElastic: function(t2, b2, c2, d2) {
          var a2, p2, s3;
          s3 = 1.70158;
          p2 = 0;
          a2 = c2;
          if (t2 === 0)
            ;
          else if ((t2 /= d2 / 2) === 2)
            ;
          if (!p2) {
            p2 = d2 * (0.3 * 1.5);
          }
          if (a2 < Math.abs(c2)) {
            a2 = c2;
            s3 = p2 / 4;
          } else {
            s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
          }
          if (t2 < 1) {
            return -0.5 * (a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * d2 - s3) * (2 * Math.PI) / p2)) + b2;
          } else {
            return a2 * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 * d2 - s3) * (2 * Math.PI) / p2) * 0.5 + c2 + b2;
          }
        },
        easeInBack: function(t2, b2, c2, d2, s3) {
          if (s3 === void 0) {
            s3 = 1.70158;
          }
          return c2 * (t2 /= d2) * t2 * ((s3 + 1) * t2 - s3) + b2;
        },
        easeOutBack: function(t2, b2, c2, d2, s3) {
          if (s3 === void 0) {
            s3 = 1.70158;
          }
          return c2 * ((t2 = t2 / d2 - 1) * t2 * ((s3 + 1) * t2 + s3) + 1) + b2;
        },
        easeInOutBack: function(t2, b2, c2, d2, s3) {
          if (s3 === void 0) {
            s3 = 1.70158;
          }
          if ((t2 /= d2 / 2) < 1) {
            return c2 / 2 * (t2 * t2 * (((s3 *= 1.525) + 1) * t2 - s3)) + b2;
          } else {
            return c2 / 2 * ((t2 -= 2) * t2 * (((s3 *= 1.525) + 1) * t2 + s3) + 2) + b2;
          }
        },
        easeInBounce: function(t2, b2, c2, d2) {
          var v2;
          v2 = penner2.easeOutBounce(d2 - t2, 0, c2, d2);
          return c2 - v2 + b2;
        },
        easeOutBounce: function(t2, b2, c2, d2) {
          if ((t2 /= d2) < 1 / 2.75) {
            return c2 * (7.5625 * t2 * t2) + b2;
          } else if (t2 < 2 / 2.75) {
            return c2 * (7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75) + b2;
          } else if (t2 < 2.5 / 2.75) {
            return c2 * (7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375) + b2;
          } else {
            return c2 * (7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375) + b2;
          }
        },
        easeInOutBounce: function(t2, b2, c2, d2) {
          var v2;
          if (t2 < d2 / 2) {
            v2 = penner2.easeInBounce(t2 * 2, 0, c2, d2);
            return v2 * 0.5 + b2;
          } else {
            v2 = penner2.easeOutBounce(t2 * 2 - d2, 0, c2, d2);
            return v2 * 0.5 + c2 * 0.5 + b2;
          }
        }
      };
      umd(penner2);
    }).call(commonjsGlobal);
  });
  function ease(ease2, defaults) {
    if (!ease2) {
      return penner[defaults];
    } else if (typeof ease2 === "function") {
      return ease2;
    } else if (typeof ease2 === "string") {
      return penner[ease2];
    }
  }
  var bounceOptions = {
    sides: "all",
    friction: 0.5,
    time: 150,
    ease: "easeInOutSine",
    underflow: "center",
    bounceBox: null
  };
  var Bounce = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, bounceOptions, options);
      this.ease = ease(this.options.ease, "easeInOutSine");
      if (this.options.sides) {
        if (this.options.sides === "all") {
          this.top = this.bottom = this.left = this.right = true;
        } else if (this.options.sides === "horizontal") {
          this.right = this.left = true;
        } else if (this.options.sides === "vertical") {
          this.top = this.bottom = true;
        } else {
          this.top = this.options.sides.indexOf("top") !== -1;
          this.bottom = this.options.sides.indexOf("bottom") !== -1;
          this.left = this.options.sides.indexOf("left") !== -1;
          this.right = this.options.sides.indexOf("right") !== -1;
        }
      }
      this.parseUnderflow();
      this.last = {};
      this.reset();
    }
    parseUnderflow() {
      const clamp = this.options.underflow.toLowerCase();
      if (clamp === "center") {
        this.underflowX = 0;
        this.underflowY = 0;
      } else {
        this.underflowX = clamp.indexOf("left") !== -1 ? -1 : clamp.indexOf("right") !== -1 ? 1 : 0;
        this.underflowY = clamp.indexOf("top") !== -1 ? -1 : clamp.indexOf("bottom") !== -1 ? 1 : 0;
      }
    }
    isActive() {
      return this.toX !== null || this.toY !== null;
    }
    down() {
      this.toX = this.toY = null;
    }
    up() {
      this.bounce();
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      this.bounce();
      if (this.toX) {
        const toX = this.toX;
        toX.time += elapsed;
        this.parent.emit("moved", {viewport: this.parent, type: "bounce-x"});
        if (toX.time >= this.options.time) {
          this.parent.x = toX.end;
          this.toX = null;
          this.parent.emit("bounce-x-end", this.parent);
        } else {
          this.parent.x = this.ease(toX.time, toX.start, toX.delta, this.options.time);
        }
      }
      if (this.toY) {
        const toY = this.toY;
        toY.time += elapsed;
        this.parent.emit("moved", {viewport: this.parent, type: "bounce-y"});
        if (toY.time >= this.options.time) {
          this.parent.y = toY.end;
          this.toY = null;
          this.parent.emit("bounce-y-end", this.parent);
        } else {
          this.parent.y = this.ease(toY.time, toY.start, toY.delta, this.options.time);
        }
      }
    }
    calcUnderflowX() {
      let x2;
      switch (this.underflowX) {
        case -1:
          x2 = 0;
          break;
        case 1:
          x2 = this.parent.screenWidth - this.parent.screenWorldWidth;
          break;
        default:
          x2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
      }
      return x2;
    }
    calcUnderflowY() {
      let y2;
      switch (this.underflowY) {
        case -1:
          y2 = 0;
          break;
        case 1:
          y2 = this.parent.screenHeight - this.parent.screenWorldHeight;
          break;
        default:
          y2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
      }
      return y2;
    }
    oob() {
      const box = this.options.bounceBox;
      if (box) {
        const x1 = typeof box.x === "undefined" ? 0 : box.x;
        const y1 = typeof box.y === "undefined" ? 0 : box.y;
        const width = typeof box.width === "undefined" ? this.parent.worldWidth : box.width;
        const height = typeof box.height === "undefined" ? this.parent.worldHeight : box.height;
        return {
          left: this.parent.left < x1,
          right: this.parent.right > width,
          top: this.parent.top < y1,
          bottom: this.parent.bottom > height,
          topLeft: new import_pixi.Point(x1 * this.parent.scale.x, y1 * this.parent.scale.y),
          bottomRight: new import_pixi.Point(width * this.parent.scale.x - this.parent.screenWidth, height * this.parent.scale.y - this.parent.screenHeight)
        };
      }
      return {
        left: this.parent.left < 0,
        right: this.parent.right > this.parent.worldWidth,
        top: this.parent.top < 0,
        bottom: this.parent.bottom > this.parent.worldHeight,
        topLeft: new import_pixi.Point(0, 0),
        bottomRight: new import_pixi.Point(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth, this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
      };
    }
    bounce() {
      if (this.paused) {
        return;
      }
      let oob;
      let decelerate = this.parent.plugins.get("decelerate", true);
      if (decelerate && (decelerate.x || decelerate.y)) {
        if (decelerate.x && decelerate.percentChangeX === decelerate.options.friction || decelerate.y && decelerate.percentChangeY === decelerate.options.friction) {
          oob = this.oob();
          if (oob.left && this.left || oob.right && this.right) {
            decelerate.percentChangeX = this.options.friction;
          }
          if (oob.top && this.top || oob.bottom && this.bottom) {
            decelerate.percentChangeY = this.options.friction;
          }
        }
      }
      const drag = this.parent.plugins.get("drag", true) || {};
      const pinch = this.parent.plugins.get("pinch", true) || {};
      decelerate = decelerate || {};
      if (!drag.active && !pinch.active && ((!this.toX || !this.toY) && (!decelerate.x || !decelerate.y))) {
        oob = oob || this.oob();
        const topLeft = oob.topLeft;
        const bottomRight = oob.bottomRight;
        if (!this.toX && !decelerate.x) {
          let x2 = null;
          if (oob.left && this.left) {
            x2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -topLeft.x;
          } else if (oob.right && this.right) {
            x2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -bottomRight.x;
          }
          if (x2 !== null && this.parent.x !== x2) {
            this.toX = {time: 0, start: this.parent.x, delta: x2 - this.parent.x, end: x2};
            this.parent.emit("bounce-x-start", this.parent);
          }
        }
        if (!this.toY && !decelerate.y) {
          let y2 = null;
          if (oob.top && this.top) {
            y2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -topLeft.y;
          } else if (oob.bottom && this.bottom) {
            y2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -bottomRight.y;
          }
          if (y2 !== null && this.parent.y !== y2) {
            this.toY = {time: 0, start: this.parent.y, delta: y2 - this.parent.y, end: y2};
            this.parent.emit("bounce-y-start", this.parent);
          }
        }
      }
    }
    reset() {
      this.toX = this.toY = null;
      this.bounce();
    }
  };
  var snapOptions = {
    topLeft: false,
    friction: 0.8,
    time: 1e3,
    ease: "easeInOutSine",
    interrupt: true,
    removeOnComplete: false,
    removeOnInterrupt: false,
    forceStart: false
  };
  var Snap = class extends Plugin {
    constructor(parent, x2, y2, options = {}) {
      super(parent);
      this.options = Object.assign({}, snapOptions, options);
      this.ease = ease(options.ease, "easeInOutSine");
      this.x = x2;
      this.y = y2;
      if (this.options.forceStart) {
        this.snapStart();
      }
    }
    snapStart() {
      this.percent = 0;
      this.snapping = {time: 0};
      const current = this.options.topLeft ? this.parent.corner : this.parent.center;
      this.deltaX = this.x - current.x;
      this.deltaY = this.y - current.y;
      this.startX = current.x;
      this.startY = current.y;
      this.parent.emit("snap-start", this.parent);
    }
    wheel() {
      if (this.options.removeOnInterrupt) {
        this.parent.plugins.remove("snap");
      }
    }
    down() {
      if (this.options.removeOnInterrupt) {
        this.parent.plugins.remove("snap");
      } else if (this.options.interrupt) {
        this.snapping = null;
      }
    }
    up() {
      if (this.parent.input.count() === 0) {
        const decelerate = this.parent.plugins.get("decelerate", true);
        if (decelerate && (decelerate.x || decelerate.y)) {
          decelerate.percentChangeX = decelerate.percentChangeY = this.options.friction;
        }
      }
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      if (this.options.interrupt && this.parent.input.count() !== 0) {
        return;
      }
      if (!this.snapping) {
        const current = this.options.topLeft ? this.parent.corner : this.parent.center;
        if (current.x !== this.x || current.y !== this.y) {
          this.snapStart();
        }
      } else {
        const snapping = this.snapping;
        snapping.time += elapsed;
        let finished, x2, y2;
        if (snapping.time > this.options.time) {
          finished = true;
          x2 = this.startX + this.deltaX;
          y2 = this.startY + this.deltaY;
        } else {
          const percent = this.ease(snapping.time, 0, 1, this.options.time);
          x2 = this.startX + this.deltaX * percent;
          y2 = this.startY + this.deltaY * percent;
        }
        if (this.options.topLeft) {
          this.parent.moveCorner(x2, y2);
        } else {
          this.parent.moveCenter(x2, y2);
        }
        this.parent.emit("moved", {viewport: this.parent, type: "snap"});
        if (finished) {
          if (this.options.removeOnComplete) {
            this.parent.plugins.remove("snap");
          }
          this.parent.emit("snap-end", this.parent);
          this.snapping = null;
        }
      }
    }
  };
  var snapZoomOptions = {
    width: 0,
    height: 0,
    time: 1e3,
    ease: "easeInOutSine",
    center: null,
    interrupt: true,
    removeOnComplete: false,
    removeOnInterrupts: false,
    forceStart: false,
    noMove: false
  };
  var SnapZoom = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, snapZoomOptions, options);
      this.ease = ease(this.options.ease);
      if (this.options.width > 0) {
        this.xScale = parent.screenWidth / this.options.width;
      }
      if (this.options.height > 0) {
        this.yScale = parent.screenHeight / this.options.height;
      }
      this.xIndependent = this.xScale ? true : false;
      this.yIndependent = this.yScale ? true : false;
      this.xScale = this.xIndependent ? this.xScale : this.yScale;
      this.yScale = this.yIndependent ? this.yScale : this.xScale;
      if (this.options.time === 0) {
        parent.container.scale.x = this.xScale;
        parent.container.scale.y = this.yScale;
        if (this.options.removeOnComplete) {
          this.parent.plugins.remove("snap-zoom");
        }
      } else if (options.forceStart) {
        this.createSnapping();
      }
    }
    createSnapping() {
      this.parent.scale;
      const startWorldScreenWidth = this.parent.worldScreenWidth;
      const startWorldScreenHeight = this.parent.worldScreenHeight;
      const endWorldScreenWidth = this.parent.screenWidth / this.xScale;
      const endWorldScreenHeight = this.parent.screenHeight / this.yScale;
      this.snapping = {
        time: 0,
        startX: startWorldScreenWidth,
        startY: startWorldScreenHeight,
        deltaX: endWorldScreenWidth - startWorldScreenWidth,
        deltaY: endWorldScreenHeight - startWorldScreenHeight
      };
      this.parent.emit("snap-zoom-start", this.parent);
    }
    resize() {
      this.snapping = null;
      if (this.options.width > 0) {
        this.xScale = this.parent.screenWidth / this.options.width;
      }
      if (this.options.height > 0) {
        this.yScale = this.parent.screenHeight / this.options.height;
      }
      this.xScale = this.xIndependent ? this.xScale : this.yScale;
      this.yScale = this.yIndependent ? this.yScale : this.xScale;
    }
    wheel() {
      if (this.options.removeOnInterrupt) {
        this.parent.plugins.remove("snap-zoom");
      }
    }
    down() {
      if (this.options.removeOnInterrupt) {
        this.parent.plugins.remove("snap-zoom");
      } else if (this.options.interrupt) {
        this.snapping = null;
      }
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      if (this.options.interrupt && this.parent.input.count() !== 0) {
        return;
      }
      let oldCenter;
      if (!this.options.center && !this.options.noMove) {
        oldCenter = this.parent.center;
      }
      if (!this.snapping) {
        if (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) {
          this.createSnapping();
        }
      } else if (this.snapping) {
        const snapping = this.snapping;
        snapping.time += elapsed;
        if (snapping.time >= this.options.time) {
          this.parent.scale.set(this.xScale, this.yScale);
          if (this.options.removeOnComplete) {
            this.parent.plugins.remove("snap-zoom");
          }
          this.parent.emit("snap-zoom-end", this.parent);
          this.snapping = null;
        } else {
          const snapping2 = this.snapping;
          const worldScreenWidth = this.ease(snapping2.time, snapping2.startX, snapping2.deltaX, this.options.time);
          const worldScreenHeight = this.ease(snapping2.time, snapping2.startY, snapping2.deltaY, this.options.time);
          this.parent.scale.x = this.parent.screenWidth / worldScreenWidth;
          this.parent.scale.y = this.parent.screenHeight / worldScreenHeight;
        }
        const clamp = this.parent.plugins.get("clamp-zoom", true);
        if (clamp) {
          clamp.clamp();
        }
        if (!this.options.noMove) {
          if (!this.options.center) {
            this.parent.moveCenter(oldCenter);
          } else {
            this.parent.moveCenter(this.options.center);
          }
        }
      }
    }
    resume() {
      this.snapping = null;
      super.resume();
    }
  };
  var followOptions = {
    speed: 0,
    acceleration: null,
    radius: null
  };
  var Follow = class extends Plugin {
    constructor(parent, target, options = {}) {
      super(parent);
      this.target = target;
      this.options = Object.assign({}, followOptions, options);
      this.velocity = {x: 0, y: 0};
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      const center2 = this.parent.center;
      let toX = this.target.x, toY = this.target.y;
      if (this.options.radius) {
        const distance = Math.sqrt(Math.pow(this.target.y - center2.y, 2) + Math.pow(this.target.x - center2.x, 2));
        if (distance > this.options.radius) {
          const angle = Math.atan2(this.target.y - center2.y, this.target.x - center2.x);
          toX = this.target.x - Math.cos(angle) * this.options.radius;
          toY = this.target.y - Math.sin(angle) * this.options.radius;
        } else {
          return;
        }
      }
      const deltaX = toX - center2.x;
      const deltaY = toY - center2.y;
      if (deltaX || deltaY) {
        if (this.options.speed) {
          if (this.options.acceleration) {
            const angle = Math.atan2(toY - center2.y, toX - center2.x);
            const distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
            if (distance) {
              const decelerationDistance = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
              if (distance > decelerationDistance) {
                this.velocity = {
                  x: Math.min(this.velocity.x + this.options.acceleration * elapsed, this.options.speed),
                  y: Math.min(this.velocity.y + this.options.acceleration * elapsed, this.options.speed)
                };
              } else {
                this.velocity = {
                  x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
                  y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
                };
              }
              const changeX = Math.cos(angle) * this.velocity.x;
              const changeY = Math.sin(angle) * this.velocity.y;
              const x2 = Math.abs(changeX) > Math.abs(deltaX) ? toX : center2.x + changeX;
              const y2 = Math.abs(changeY) > Math.abs(deltaY) ? toY : center2.y + changeY;
              this.parent.moveCenter(x2, y2);
              this.parent.emit("moved", {viewport: this.parent, type: "follow"});
            }
          } else {
            const angle = Math.atan2(toY - center2.y, toX - center2.x);
            const changeX = Math.cos(angle) * this.options.speed;
            const changeY = Math.sin(angle) * this.options.speed;
            const x2 = Math.abs(changeX) > Math.abs(deltaX) ? toX : center2.x + changeX;
            const y2 = Math.abs(changeY) > Math.abs(deltaY) ? toY : center2.y + changeY;
            this.parent.moveCenter(x2, y2);
            this.parent.emit("moved", {viewport: this.parent, type: "follow"});
          }
        } else {
          this.parent.moveCenter(toX, toY);
          this.parent.emit("moved", {viewport: this.parent, type: "follow"});
        }
      }
    }
  };
  var wheelOptions = {
    percent: 0.1,
    smooth: false,
    interrupt: true,
    reverse: false,
    center: null,
    lineHeight: 20,
    axis: "all"
  };
  var Wheel = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, wheelOptions, options);
    }
    down() {
      if (this.options.interrupt) {
        this.smoothing = null;
      }
    }
    isAxisX() {
      return ["all", "x"].includes(this.options.axis);
    }
    isAxisY() {
      return ["all", "y"].includes(this.options.axis);
    }
    update() {
      if (this.smoothing) {
        const point = this.smoothingCenter;
        const change = this.smoothing;
        let oldPoint;
        if (!this.options.center) {
          oldPoint = this.parent.toLocal(point);
        }
        if (this.isAxisX()) {
          this.parent.scale.x += change.x;
        }
        if (this.isAxisY()) {
          this.parent.scale.y += change.y;
        }
        this.parent.emit("zoomed", {viewport: this.parent, type: "wheel"});
        const clamp = this.parent.plugins.get("clamp-zoom", true);
        if (clamp) {
          clamp.clamp();
        }
        if (this.options.center) {
          this.parent.moveCenter(this.options.center);
        } else {
          const newPoint = this.parent.toGlobal(oldPoint);
          this.parent.x += point.x - newPoint.x;
          this.parent.y += point.y - newPoint.y;
        }
        this.parent.emit("moved", {viewport: this.parent, type: "wheel"});
        this.smoothingCount++;
        if (this.smoothingCount >= this.options.smooth) {
          this.smoothing = null;
        }
      }
    }
    wheel(e2) {
      if (this.paused) {
        return;
      }
      let point = this.parent.input.getPointerPosition(e2);
      const sign = this.options.reverse ? -1 : 1;
      const step = sign * -e2.deltaY * (e2.deltaMode ? this.options.lineHeight : 1) / 500;
      const change = Math.pow(2, (1 + this.options.percent) * step);
      if (this.options.smooth) {
        const original = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + original.x) * change - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + original.y) * change - this.parent.scale.y) / this.options.smooth
        };
        this.smoothingCount = 0;
        this.smoothingCenter = point;
      } else {
        let oldPoint;
        if (!this.options.center) {
          oldPoint = this.parent.toLocal(point);
        }
        if (this.isAxisX()) {
          this.parent.scale.x *= change;
        }
        if (this.isAxisY()) {
          this.parent.scale.y *= change;
        }
        this.parent.emit("zoomed", {viewport: this.parent, type: "wheel"});
        const clamp = this.parent.plugins.get("clamp-zoom", true);
        if (clamp) {
          clamp.clamp();
        }
        if (this.options.center) {
          this.parent.moveCenter(this.options.center);
        } else {
          const newPoint = this.parent.toGlobal(oldPoint);
          this.parent.x += point.x - newPoint.x;
          this.parent.y += point.y - newPoint.y;
        }
      }
      this.parent.emit("moved", {viewport: this.parent, type: "wheel"});
      this.parent.emit("wheel", {wheel: {dx: e2.deltaX, dy: e2.deltaY, dz: e2.deltaZ}, event: e2, viewport: this.parent});
      if (!this.parent.options.passiveWheel) {
        return true;
      }
    }
  };
  var mouseEdgesOptions = {
    radius: null,
    distance: null,
    top: null,
    bottom: null,
    left: null,
    right: null,
    speed: 8,
    reverse: false,
    noDecelerate: false,
    linear: false,
    allowButtons: false
  };
  var MouseEdges = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, mouseEdgesOptions, options);
      this.reverse = this.options.reverse ? 1 : -1;
      this.radiusSquared = Math.pow(this.options.radius, 2);
      this.resize();
    }
    resize() {
      const distance = this.options.distance;
      if (distance !== null) {
        this.left = distance;
        this.top = distance;
        this.right = this.parent.worldScreenWidth - distance;
        this.bottom = this.parent.worldScreenHeight - distance;
      } else if (!this.radius) {
        this.left = this.options.left;
        this.top = this.options.top;
        this.right = this.options.right === null ? null : this.parent.worldScreenWidth - this.options.right;
        this.bottom = this.options.bottom === null ? null : this.parent.worldScreenHeight - this.options.bottom;
      }
    }
    down() {
      if (this.paused) {
        return;
      }
      if (!this.options.allowButtons) {
        this.horizontal = this.vertical = null;
      }
    }
    move(event) {
      if (this.paused) {
        return;
      }
      if (event.data.pointerType !== "mouse" && event.data.identifier !== 1 || !this.options.allowButtons && event.data.buttons !== 0) {
        return;
      }
      const x2 = event.data.global.x;
      const y2 = event.data.global.y;
      if (this.radiusSquared) {
        const center2 = this.parent.toScreen(this.parent.center);
        const distance = Math.pow(center2.x - x2, 2) + Math.pow(center2.y - y2, 2);
        if (distance >= this.radiusSquared) {
          const angle = Math.atan2(center2.y - y2, center2.x - x2);
          if (this.options.linear) {
            this.horizontal = Math.round(Math.cos(angle)) * this.options.speed * this.reverse * (60 / 1e3);
            this.vertical = Math.round(Math.sin(angle)) * this.options.speed * this.reverse * (60 / 1e3);
          } else {
            this.horizontal = Math.cos(angle) * this.options.speed * this.reverse * (60 / 1e3);
            this.vertical = Math.sin(angle) * this.options.speed * this.reverse * (60 / 1e3);
          }
        } else {
          if (this.horizontal) {
            this.decelerateHorizontal();
          }
          if (this.vertical) {
            this.decelerateVertical();
          }
          this.horizontal = this.vertical = 0;
        }
      } else {
        if (this.left !== null && x2 < this.left) {
          this.horizontal = 1 * this.reverse * this.options.speed * (60 / 1e3);
        } else if (this.right !== null && x2 > this.right) {
          this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3);
        } else {
          this.decelerateHorizontal();
          this.horizontal = 0;
        }
        if (this.top !== null && y2 < this.top) {
          this.vertical = 1 * this.reverse * this.options.speed * (60 / 1e3);
        } else if (this.bottom !== null && y2 > this.bottom) {
          this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3);
        } else {
          this.decelerateVertical();
          this.vertical = 0;
        }
      }
    }
    decelerateHorizontal() {
      const decelerate = this.parent.plugins.get("decelerate", true);
      if (this.horizontal && decelerate && !this.options.noDecelerate) {
        decelerate.activate({x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60)});
      }
    }
    decelerateVertical() {
      const decelerate = this.parent.plugins.get("decelerate", true);
      if (this.vertical && decelerate && !this.options.noDecelerate) {
        decelerate.activate({y: this.vertical * this.options.speed * this.reverse / (1e3 / 60)});
      }
    }
    up() {
      if (this.paused) {
        return;
      }
      if (this.horizontal) {
        this.decelerateHorizontal();
      }
      if (this.vertical) {
        this.decelerateVertical();
      }
      this.horizontal = this.vertical = null;
    }
    update() {
      if (this.paused) {
        return;
      }
      if (this.horizontal || this.vertical) {
        const center2 = this.parent.center;
        if (this.horizontal) {
          center2.x += this.horizontal * this.options.speed;
        }
        if (this.vertical) {
          center2.y += this.vertical * this.options.speed;
        }
        this.parent.moveCenter(center2);
        this.parent.emit("moved", {viewport: this.parent, type: "mouse-edges"});
      }
    }
  };
  var animateOptions = {
    removeOnInterrupt: false,
    ease: "linear",
    time: 1e3
  };
  var Animate = class extends Plugin {
    constructor(parent, options = {}) {
      super(parent);
      this.options = Object.assign({}, animateOptions, options);
      this.options.ease = ease(this.options.ease);
      this.setupPosition();
      this.setupZoom();
    }
    setupPosition() {
      if (typeof this.options.position !== "undefined") {
        this.startX = this.parent.center.x;
        this.startY = this.parent.center.y;
        this.deltaX = this.options.position.x - this.parent.center.x;
        this.deltaY = this.options.position.y - this.parent.center.y;
        this.keepCenter = false;
      } else {
        this.keepCenter = true;
      }
    }
    setupZoom() {
      this.width = null;
      this.height = null;
      if (typeof this.options.scale !== "undefined") {
        this.width = this.parent.screenWidth / this.options.scale;
      } else if (typeof this.options.scaleX !== "undefined" || typeof this.options.scaleY !== "undefined") {
        if (typeof this.options.scaleX !== "undefined") {
          this.width = this.parent.screenWidth / this.options.scaleX;
        }
        if (typeof this.options.scaleY !== "undefined") {
          this.height = this.parent.screenHeight / this.options.scaleY;
        }
      } else {
        if (typeof this.options.width !== "undefined") {
          this.width = this.options.width;
        }
        if (typeof this.options.height !== "undefined") {
          this.height = this.options.height;
        }
      }
      if (typeof this.width !== null) {
        this.startWidth = this.parent.screenWidthInWorldPixels;
        this.deltaWidth = this.width - this.startWidth;
      }
      if (typeof this.height !== null) {
        this.startHeight = this.parent.screenHeightInWorldPixels;
        this.deltaHeight = this.height - this.startHeight;
      }
      this.time = 0;
    }
    down() {
      if (this.options.removeOnInterrupt) {
        this.parent.plugins.remove("animate");
      }
    }
    complete() {
      this.parent.plugins.remove("animate");
      if (this.width !== null) {
        this.parent.fitWidth(this.width, this.keepCenter, this.height === null);
      }
      if (this.height !== null) {
        this.parent.fitHeight(this.height, this.keepCenter, this.width === null);
      }
      if (!this.keepCenter) {
        this.parent.moveCenter(this.options.position.x, this.options.position.y);
      }
      this.parent.emit("animate-end", this.parent);
      if (this.options.callbackOnComplete) {
        this.options.callbackOnComplete(this.parent);
      }
    }
    update(elapsed) {
      if (this.paused) {
        return;
      }
      this.time += elapsed;
      if (this.time >= this.options.time) {
        this.complete();
      } else {
        const originalZoom = new import_pixi.Point(this.parent.scale.x, this.parent.scale.y);
        const percent = this.options.ease(this.time, 0, 1, this.options.time);
        if (this.width !== null) {
          this.parent.fitWidth(this.startWidth + this.deltaWidth * percent, this.keepCenter, this.height === null);
        }
        if (this.height !== null) {
          this.parent.fitHeight(this.startHeight + this.deltaHeight * percent, this.keepCenter, this.width === null);
        }
        if (this.width === null) {
          this.parent.scale.x = this.parent.scale.y;
        } else if (this.height === null) {
          this.parent.scale.y = this.parent.scale.x;
        }
        if (!this.keepCenter) {
          const original = new import_pixi.Point(this.parent.x, this.parent.y);
          this.parent.moveCenter(this.startX + this.deltaX * percent, this.startY + this.deltaY * percent);
          this.parent.emit("moved", {viewport: this.parent, original, type: "animate"});
        }
        if (this.width || this.height) {
          this.parent.emit("zoomed", {viewport: this.parent, original: originalZoom, type: "animate"});
        }
        if (!this.keepCenter)
          ;
      }
    }
  };
  var viewportOptions = {
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: null,
    worldHeight: null,
    threshold: 5,
    passiveWheel: true,
    stopPropagation: false,
    forceHitArea: null,
    noTicker: false,
    interaction: null,
    disableOnContextMenu: false
  };
  var Viewport = class extends import_pixi.Container {
    constructor(options = {}) {
      super();
      this.options = Object.assign({}, viewportOptions, options);
      if (options.ticker) {
        this.options.ticker = options.ticker;
      } else {
        let ticker;
        const pixiNS = PIXI13;
        if (parseInt(/^(\d+)\./.exec(import_pixi.VERSION)[1]) < 5) {
          ticker = pixiNS.ticker.shared;
        } else {
          ticker = pixiNS.Ticker.shared;
        }
        this.options.ticker = options.ticker || ticker;
      }
      this.screenWidth = this.options.screenWidth;
      this.screenHeight = this.options.screenHeight;
      this._worldWidth = this.options.worldWidth;
      this._worldHeight = this.options.worldHeight;
      this.forceHitArea = this.options.forceHitArea;
      this.threshold = this.options.threshold;
      this.options.divWheel = this.options.divWheel || document.body;
      if (this.options.disableOnContextMenu) {
        this.options.divWheel.oncontextmenu = (e2) => e2.preventDefault();
      }
      if (!this.options.noTicker) {
        this.tickerFunction = () => this.update(this.options.ticker.elapsedMS);
        this.options.ticker.add(this.tickerFunction);
      }
      this.input = new InputManager(this);
      this.plugins = new PluginManager(this);
    }
    destroy(options) {
      if (!this.options.noTicker) {
        this.options.ticker.remove(this.tickerFunction);
      }
      this.input.destroy();
      super.destroy(options);
    }
    update(elapsed) {
      if (!this.pause) {
        this.plugins.update(elapsed);
        if (this.lastViewport) {
          if (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y) {
            this.moving = true;
          } else {
            if (this.moving) {
              this.emit("moved-end", this);
              this.moving = false;
            }
          }
          if (this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y) {
            this.zooming = true;
          } else {
            if (this.zooming) {
              this.emit("zoomed-end", this);
              this.zooming = false;
            }
          }
        }
        if (!this.forceHitArea) {
          this._hitAreaDefault = new import_pixi.Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
          this.hitArea = this._hitAreaDefault;
        }
        this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y;
        this.lastViewport = {
          x: this.x,
          y: this.y,
          scaleX: this.scale.x,
          scaleY: this.scale.y
        };
        this.emit("frame-end", this);
      }
    }
    resize(screenWidth = window.innerWidth, screenHeight = window.innerHeight, worldWidth, worldHeight) {
      this.screenWidth = screenWidth;
      this.screenHeight = screenHeight;
      if (typeof worldWidth !== "undefined") {
        this._worldWidth = worldWidth;
      }
      if (typeof worldHeight !== "undefined") {
        this._worldHeight = worldHeight;
      }
      this.plugins.resize();
      this.dirty = true;
    }
    get worldWidth() {
      if (this._worldWidth) {
        return this._worldWidth;
      } else {
        return this.width / this.scale.x;
      }
    }
    set worldWidth(value) {
      this._worldWidth = value;
      this.plugins.resize();
    }
    get worldHeight() {
      if (this._worldHeight) {
        return this._worldHeight;
      } else {
        return this.height / this.scale.y;
      }
    }
    set worldHeight(value) {
      this._worldHeight = value;
      this.plugins.resize();
    }
    getVisibleBounds() {
      return new import_pixi.Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
    }
    toWorld(x2, y2) {
      if (arguments.length === 2) {
        return this.toLocal(new import_pixi.Point(x2, y2));
      } else {
        return this.toLocal(x2);
      }
    }
    toScreen(x2, y2) {
      if (arguments.length === 2) {
        return this.toGlobal(new import_pixi.Point(x2, y2));
      } else {
        return this.toGlobal(x2);
      }
    }
    get worldScreenWidth() {
      return this.screenWidth / this.scale.x;
    }
    get worldScreenHeight() {
      return this.screenHeight / this.scale.y;
    }
    get screenWorldWidth() {
      return this.worldWidth * this.scale.x;
    }
    get screenWorldHeight() {
      return this.worldHeight * this.scale.y;
    }
    get center() {
      return new import_pixi.Point(this.worldScreenWidth / 2 - this.x / this.scale.x, this.worldScreenHeight / 2 - this.y / this.scale.y);
    }
    set center(value) {
      this.moveCenter(value);
    }
    moveCenter() {
      let x2, y2;
      if (!isNaN(arguments[0])) {
        x2 = arguments[0];
        y2 = arguments[1];
      } else {
        x2 = arguments[0].x;
        y2 = arguments[0].y;
      }
      const newX = (this.worldScreenWidth / 2 - x2) * this.scale.x;
      const newY = (this.worldScreenHeight / 2 - y2) * this.scale.y;
      if (this.x !== newX || this.y !== newY) {
        this.position.set(newX, newY);
        this.plugins.reset();
        this.dirty = true;
      }
      return this;
    }
    get corner() {
      return new import_pixi.Point(-this.x / this.scale.x, -this.y / this.scale.y);
    }
    set corner(value) {
      this.moveCorner(value);
    }
    moveCorner() {
      let x2, y2;
      if (arguments.length === 1) {
        x2 = -arguments[0].x * this.scale.x;
        y2 = -arguments[0].y * this.scale.y;
      } else {
        x2 = -arguments[0] * this.scale.x;
        y2 = -arguments[1] * this.scale.y;
      }
      if (x2 !== this.x || y2 !== this.y) {
        this.position.set(x2, y2);
        this.plugins.reset();
        this.dirty = true;
      }
      return this;
    }
    get screenWidthInWorldPixels() {
      return this.screenWidth / this.scale.x;
    }
    get screenHeightInWorldPixels() {
      return this.screenHeight / this.scale.y;
    }
    findFitWidth(width) {
      return this.screenWidth / width;
    }
    findFitHeight(height) {
      return this.screenHeight / height;
    }
    findFit(width, height) {
      const scaleX = this.screenWidth / width;
      const scaleY = this.screenHeight / height;
      return Math.min(scaleX, scaleY);
    }
    findCover(width, height) {
      const scaleX = this.screenWidth / width;
      const scaleY = this.screenHeight / height;
      return Math.max(scaleX, scaleY);
    }
    fitWidth(width, center2, scaleY = true, noClamp) {
      let save;
      if (center2) {
        save = this.center;
      }
      this.scale.x = this.screenWidth / width;
      if (scaleY) {
        this.scale.y = this.scale.x;
      }
      const clampZoom = this.plugins.get("clamp-zoom", true);
      if (!noClamp && clampZoom) {
        clampZoom.clamp();
      }
      if (center2) {
        this.moveCenter(save);
      }
      return this;
    }
    fitHeight(height, center2, scaleX = true, noClamp) {
      let save;
      if (center2) {
        save = this.center;
      }
      this.scale.y = this.screenHeight / height;
      if (scaleX) {
        this.scale.x = this.scale.y;
      }
      const clampZoom = this.plugins.get("clamp-zoom", true);
      if (!noClamp && clampZoom) {
        clampZoom.clamp();
      }
      if (center2) {
        this.moveCenter(save);
      }
      return this;
    }
    fitWorld(center2) {
      let save;
      if (center2) {
        save = this.center;
      }
      this.scale.x = this.screenWidth / this.worldWidth;
      this.scale.y = this.screenHeight / this.worldHeight;
      if (this.scale.x < this.scale.y) {
        this.scale.y = this.scale.x;
      } else {
        this.scale.x = this.scale.y;
      }
      const clampZoom = this.plugins.get("clamp-zoom", true);
      if (clampZoom) {
        clampZoom.clamp();
      }
      if (center2) {
        this.moveCenter(save);
      }
      return this;
    }
    fit(center2, width = this.worldWidth, height = this.worldHeight) {
      let save;
      if (center2) {
        save = this.center;
      }
      this.scale.x = this.screenWidth / width;
      this.scale.y = this.screenHeight / height;
      if (this.scale.x < this.scale.y) {
        this.scale.y = this.scale.x;
      } else {
        this.scale.x = this.scale.y;
      }
      const clampZoom = this.plugins.get("clamp-zoom", true);
      if (clampZoom) {
        clampZoom.clamp();
      }
      if (center2) {
        this.moveCenter(save);
      }
      return this;
    }
    set visible(value) {
      if (!value) {
        this.input.clear();
      }
      super.visible = value;
    }
    setZoom(scale, center2) {
      let save;
      if (center2) {
        save = this.center;
      }
      this.scale.set(scale);
      const clampZoom = this.plugins.get("clamp-zoom", true);
      if (clampZoom) {
        clampZoom.clamp();
      }
      if (center2) {
        this.moveCenter(save);
      }
      return this;
    }
    zoomPercent(percent, center2) {
      return this.setZoom(this.scale.x + this.scale.x * percent, center2);
    }
    zoom(change, center2) {
      this.fitWidth(change + this.worldScreenWidth, center2);
      return this;
    }
    set scaled(scale) {
      this.setZoom(scale, true);
    }
    get scaled() {
      return this.scale.x;
    }
    snapZoom(options) {
      this.plugins.add("snap-zoom", new SnapZoom(this, options));
      return this;
    }
    OOB() {
      return {
        left: this.left < 0,
        right: this.right > this.worldWidth,
        top: this.top < 0,
        bottom: this.bottom > this._worldHeight,
        cornerPoint: new import_pixi.Point(this.worldWidth * this.scale.x - this.screenWidth, this.worldHeight * this.scale.y - this.screenHeight)
      };
    }
    get right() {
      return -this.x / this.scale.x + this.worldScreenWidth;
    }
    set right(value) {
      this.x = -value * this.scale.x + this.screenWidth;
      this.plugins.reset();
    }
    get left() {
      return -this.x / this.scale.x;
    }
    set left(value) {
      this.x = -value * this.scale.x;
      this.plugins.reset();
    }
    get top() {
      return -this.y / this.scale.y;
    }
    set top(value) {
      this.y = -value * this.scale.y;
      this.plugins.reset();
    }
    get bottom() {
      return -this.y / this.scale.y + this.worldScreenHeight;
    }
    set bottom(value) {
      this.y = -value * this.scale.y + this.screenHeight;
      this.plugins.reset();
    }
    get dirty() {
      return this._dirty;
    }
    set dirty(value) {
      this._dirty = value;
    }
    get forceHitArea() {
      return this._forceHitArea;
    }
    set forceHitArea(value) {
      if (value) {
        this._forceHitArea = value;
        this.hitArea = value;
      } else {
        this._forceHitArea = null;
        this.hitArea = new import_pixi.Rectangle(0, 0, this.worldWidth, this.worldHeight);
      }
    }
    drag(options) {
      this.plugins.add("drag", new Drag(this, options));
      return this;
    }
    clamp(options) {
      this.plugins.add("clamp", new Clamp(this, options));
      return this;
    }
    decelerate(options) {
      this.plugins.add("decelerate", new Decelerate(this, options));
      return this;
    }
    bounce(options) {
      this.plugins.add("bounce", new Bounce(this, options));
      return this;
    }
    pinch(options) {
      this.plugins.add("pinch", new Pinch(this, options));
      return this;
    }
    snap(x2, y2, options) {
      this.plugins.add("snap", new Snap(this, x2, y2, options));
      return this;
    }
    follow(target, options) {
      this.plugins.add("follow", new Follow(this, target, options));
      return this;
    }
    wheel(options) {
      this.plugins.add("wheel", new Wheel(this, options));
      return this;
    }
    animate(options) {
      this.plugins.add("animate", new Animate(this, options));
      return this;
    }
    clampZoom(options) {
      this.plugins.add("clamp-zoom", new ClampZoom(this, options));
      return this;
    }
    mouseEdges(options) {
      this.plugins.add("mouse-edges", new MouseEdges(this, options));
      return this;
    }
    get pause() {
      return this._pause;
    }
    set pause(value) {
      this._pause = value;
      this.lastViewport = null;
      this.moving = false;
      this.zooming = false;
      if (value) {
        this.input.pause();
      }
    }
    ensureVisible(x2, y2, width, height, resizeToFit) {
      if (resizeToFit && (width > this.worldScreenWidth || height > this.worldScreenHeight)) {
        this.fit(true, width, height);
        this.emit("zoomed", {viewport: this, type: "ensureVisible"});
      }
      let moved = false;
      if (x2 < this.left) {
        this.left = x2;
        moved = true;
      } else if (x2 + width > this.right) {
        this.right = x2 + width;
        moved = true;
      }
      if (y2 < this.top) {
        this.top = y2;
        moved = true;
      } else if (y2 + height > this.bottom) {
        this.bottom = y2 + height;
        moved = true;
      }
      if (moved) {
        this.emit("moved", {viewport: this, type: "ensureVisible"});
      }
    }
  };

  // assets/scripts/helpers/input.class.js
  var PIXI14 = __toModule(require_pixi());
  var Input = class extends PIXI14.utils.EventEmitter {
    constructor(canvas) {
      super();
      this.canvas = canvas;
      this.canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitPointerLockElement;
      document.addEventListener("pointerlockchange", this.onPointerLockChange.bind(this), false);
      document.addEventListener("mozpointerlockchange", this.onPointerLockChange.bind(this), false);
      document.addEventListener("webkitpointerlockchange", this.onPointerLockChange.bind(this), false);
      this.wantsPointerLock = false;
      this.wasPointerLocked = false;
      this.autoRepeatedKey = null;
      this.keyboardButtons = new Map();
      this.keyboardButtonsDown = new Set();
      document.addEventListener("keydown", this.onKeyDown.bind(this), true);
      document.addEventListener("keyup", this.onKeyUp.bind(this), true);
    }
    destroy() {
      document.removeEventListener("keydown", this.onKeyDown, true);
      document.removeEventListener("keyup", this.onKeyUp, true);
    }
    lockMouse() {
      this.wantsPointerLock = true;
      this.canvas.requestPointerLock();
    }
    unlockMouse() {
      this.wantsPointerLock = false;
      this.wasPointerLocked = false;
      if (!this.isPointerLocked()) {
        return;
      }
      document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
      document.exitPointerLock();
    }
    isPointerLocked() {
      return document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
    }
    onPointerLockChange() {
      const isPointerLocked = this.isPointerLocked();
      if (this.wasPointerLocked !== isPointerLocked) {
        this.emit("mouseLockStateChange", isPointerLocked ? "active" : "suspended");
        this.wasPointerLocked = isPointerLocked;
      }
    }
    onPointerLockError() {
      if (this.wasPointerLocked) {
        this.emit("mouseLockStateChange", "suspended");
        this.wasPointerLocked = false;
      }
    }
    reset() {
      this.autoRepeatedKey = null;
      this.keyboardButtons.clear();
      this.keyboardButtonsDown.clear();
    }
    key(code) {
      let button = this.keyboardButtons.get(code);
      if (!button) {
        button = {
          isDown: false,
          wasJustPressed: false,
          wasJustAutoRepeated: false,
          wasJustReleased: false
        };
        this.keyboardButtons.set(code, button);
      }
      return button;
    }
    _checkKeyboard(keyName, type2 = "isDown") {
      if (keyName === "ANY") {
        return [...this.keyboardButtons.values()].some((button) => button[type2]);
      }
      return this.key(keyName);
    }
    isKeyDown(keyName) {
      const keyboardButton = this._checkKeyboard(keyName, "isDown");
      return keyboardButton.isDown;
    }
    wasKeyJustPressed(keyName, autoRepeat = false) {
      const keyboardButton = this._checkKeyboard(keyName, "wasJustPressed");
      return keyboardButton.wasJustPressed || autoRepeat && keyboardButton.wasJustAutoRepeated;
    }
    wasKeyJustReleased(keyName) {
      const keyboardButton = this._checkKeyboard(keyName, "wasJustReleased");
      return keyboardButton.wasJustReleased;
    }
    onKeyDown(event) {
      const key = event.which || event.keyCode;
      const isControlKey = key < 48 && key !== 32;
      if (isControlKey) {
        event.preventDefault();
      }
      if (this.keyboardButtonsDown.has(key)) {
        this.autoRepeatedKey = key;
      } else {
        this.keyboardButtonsDown.add(key);
        const button = this.key(key);
        button.wasJustPressed = true;
        button.isDown = true;
      }
      return !isControlKey;
    }
    onKeyUp(event) {
      const key = event.which || event.keyCode;
      this.keyboardButtonsDown.delete(key);
    }
    update() {
      for (const [code, keyboardButton] of this.keyboardButtons) {
        const wasDown = keyboardButton.isDown;
        keyboardButton.isDown = this.keyboardButtonsDown.has(code);
        keyboardButton.wasJustAutoRepeated = false;
        keyboardButton.wasJustReleased = wasDown && !keyboardButton.isDown;
        if (keyboardButton.isDown) {
          this.emit("isDown", code);
        }
        if (keyboardButton.wasJustReleased) {
          this.emit("wasJustReleased", code);
        }
        if (keyboardButton.wasJustPressed) {
          this.emit("wasJustPressed", code);
        }
        keyboardButton.wasJustPressed = false;
      }
      if (this.autoRepeatedKey !== null) {
        this.key(this.autoRepeatedKey).wasJustAutoRepeated = true;
        this.autoRepeatedKey = null;
      }
    }
  };
  var input_class_default = Input;
  var Key = Object.freeze({
    ANY: "ANY",
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    PAUSE: 19,
    CTRL: 17,
    ALT: 18,
    CAPS_LOCK: 20,
    ESCAPE: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    _0: 48,
    _1: 49,
    _2: 50,
    _3: 51,
    _4: 52,
    _5: 53,
    _6: 54,
    _7: 55,
    _8: 56,
    _9: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    CMD: 91,
    CMD_RIGHT: 93,
    NUM_0: 96,
    NUM_1: 97,
    NUM_2: 98,
    NUM_3: 99,
    NUM_4: 100,
    NUM_5: 101,
    NUM_6: 102,
    NUM_7: 103,
    NUM_8: 104,
    NUM_9: 105,
    MULTIPLY: 106,
    ADD: 107,
    SUBTRACT: 109,
    DECIMAL_POINT: 110,
    DIVIDE: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUM_LOCK: 144,
    SCROLL_LOCK: 145,
    SEMI_COLON: 186,
    EQUAL: 187,
    COMMA: 188,
    DASH: 189,
    PERIOD: 190,
    FORWARD_SLASH: 191,
    OPEN_BRACKET: 219,
    BACK_SLASH: 220,
    CLOSE_BRACKET: 221,
    SINGLE_QUOTE: 222
  });

  // assets/scripts/ECS/scene.class.js
  var _Scene = class extends actortree_class_default {
    static define(sceneName, classInstance) {
      this.cache.set(sceneName, classInstance);
    }
    constructor(options = {}) {
      super({
        useLRUCache: options.useLRUCache || true
      });
      this.name = this.constructor.name;
      this.awakened = false;
      this.started = false;
      this.destroyed = false;
      this.debug = options.debug || false;
      this.isUpdated = false;
      this.childScenes = [];
      if (this.debug) {
        console.log(`[INFO] New scene '${this.name}' instanciated!`);
      }
    }
    init(controller = null) {
      this.awake();
      if (controller !== null) {
        controller.emit("awake");
      }
      this.start();
      if (controller !== null) {
        controller.emit("start");
      }
      this.setupUpdateTick();
    }
    setupUpdateTick() {
      if (this.isUpdated) {
        return;
      }
      this.isUpdated = true;
      game.app.ticker.add(this.update.bind(this));
    }
    add(...entities) {
      for (const entity of entities) {
        if (entity instanceof actor_class_default) {
          this.appendActor(entity);
          if (this.awakened) {
            entity.triggerBehaviorEvent("awake");
          }
        } else if (entity instanceof _Scene) {
          this.childScenes.push(entity);
          this.addChild(entity);
          if (this.awakened) {
            entity.init(null);
          }
          return entity;
        }
      }
      return this;
    }
    awake() {
      if (this.debug) {
        console.log(`[INFO] Scene '${this.name}' awake phase started!`);
      }
      for (const child of this.childScenes) {
        child.awake();
      }
      this.emitEventForAllActors("awake");
      this.awakened = true;
      if (this.debug) {
        console.log(`[INFO] Scene '${this.name}' awake phase ended!`);
      }
      return this;
    }
    start() {
      if (this.debug) {
        console.log(`[INFO] Scene '${this.name}' start phase started!`);
      }
      for (const child of this.childScenes) {
        child.start();
      }
      this.emitEventForAllActors("start");
      this.started = true;
      if (this.debug) {
        console.log(`[INFO] Scene '${this.name}' start phase ended!`);
      }
      for (const child of this.childScenes) {
        child.setupUpdateTick();
      }
      return this;
    }
    update(delta) {
      if (this.destroyed) {
        return true;
      }
      this.emit("update");
      this.emitEventForAllActors("update", delta);
      return false;
    }
    cleanup() {
      if (this.debug) {
        console.log(`[WARN] Scene '${this.name}' cleanup triggered!`);
      }
      for (const child of this.childScenes) {
        child.cleanup();
      }
      game.app.ticker.remove(this.update.bind(this));
      this.cleanupTree();
      this.destroy({children: true});
      this.destroyed = true;
    }
  };
  var Scene = _Scene;
  __publicField(Scene, "cache", new Map());
  var scene_class_default = Scene;

  // assets/scripts/ECS/assetloader.class.js
  var PIXI15 = __toModule(require_pixi());
  var kSoundsAssetExt = new Set(["mp3", "ogg", "wav"]);
  function center(gameObject, padding = {x: 0, y: 0}) {
    const {width, height} = game.screenSize;
    gameObject.x = width / game.resolution + (padding.x || 0);
    gameObject.y = height / game.resolution + (padding.y || 0);
  }
  var AssetLoader = class extends PIXI15.utils.EventEmitter {
    static createLoadingScreen() {
      const textStyle = {
        fontFamily: "Arial",
        fontSize: 34,
        fill: "#FFF",
        align: "center"
      };
      const container = new PIXI15.Container();
      const loadingText = new PIXI15.Text("Loading assets...", {...textStyle, fontWeight: "bold"});
      const percentText = new PIXI15.Text("0%", {...textStyle, fontSize: 24});
      loadingText.anchor.set(0.5, 0.5);
      percentText.anchor.set(0.5, 0.5);
      center(loadingText);
      center(percentText, {y: 50});
      container.addChild(loadingText);
      container.addChild(percentText);
      return container;
    }
    constructor() {
      super();
      this.assets = new Map();
      this.assetsFilesLoading = [];
    }
    _parseAssetFile(data) {
      const tilesets = data.tilesets || [];
      const assets = data.assets || {};
      for (const tileSetName of tilesets) {
        this.registerTileSet(tileSetName);
      }
      for (const [name, assetURL] of Object.entries(assets)) {
        this.registerAsset(name, assetURL);
      }
    }
    loadAssetFromFile(fileURL) {
      const promise = fetch(fileURL).then((raw) => raw.json()).then(this._parseAssetFile.bind(this));
      this.assetsFilesLoading.push(promise);
      return this;
    }
    registerAsset(name, assetURL) {
      const extension = assetURL.split(".").pop();
      this.assets.set(name, {url: assetURL, extension});
      return this;
    }
    registerTileSet(tileSetName, fileName = tileSetName) {
      return this.registerAsset(`${tileSetName}_texture`, `tilesets/${fileName}.png`).registerAsset(`${tileSetName}_json`, `tilesets/${fileName}.json`);
    }
    loadAsync(callback) {
      if (this.assetsFilesLoading.length === 0) {
        callback();
      } else {
        Promise.all(this.assetsFilesLoading).then(callback);
      }
    }
    loadAssets(loader, callback) {
      const loadingContainer = AssetLoader.createLoadingScreen();
      this.app.stage.addChild(loadingContainer);
      for (const [name, assetOptions] of this.assets.entries()) {
        const {url, extension} = assetOptions;
        if (kSoundsAssetExt.has(extension)) {
          I.add(name, url);
        } else {
          loader.add(name, url);
        }
      }
      const lazyCallback = () => setTimeout(() => {
        loadingContainer.destroy({children: true});
        this.app.stage.removeChild(loadingContainer);
        console.log("!!! ASSETS LOADED !!!");
        callback();
      }, 200);
      loader.onLoad.add((loader2, _2) => {
        loadingContainer.children[1].text = `${loader2.progress.toFixed(2)}%`;
      });
      loader.load(lazyCallback);
    }
  };
  var assetloader_class_default = AssetLoader;

  // assets/scripts/ECS/math/fade.js
  var PIXI16 = __toModule(require_pixi());

  // assets/scripts/ECS/math/easing.js
  var easing_exports = {};
  __export(easing_exports, {
    easeInBack: () => easeInBack,
    easeInBounce: () => easeInBounce,
    easeInCirc: () => easeInCirc,
    easeInCubic: () => easeInCubic,
    easeInElastic: () => easeInElastic,
    easeInExpo: () => easeInExpo,
    easeInOutBack: () => easeInOutBack,
    easeInOutBounce: () => easeInOutBounce,
    easeInOutCirc: () => easeInOutCirc,
    easeInOutCubic: () => easeInOutCubic,
    easeInOutElastic: () => easeInOutElastic,
    easeInOutExpo: () => easeInOutExpo,
    easeInOutQuad: () => easeInOutQuad,
    easeInOutQuart: () => easeInOutQuart,
    easeInOutQuint: () => easeInOutQuint,
    easeInOutSine: () => easeInOutSine,
    easeInQuad: () => easeInQuad,
    easeInQuart: () => easeInQuart,
    easeInQuint: () => easeInQuint,
    easeInSine: () => easeInSine,
    easeOutBack: () => easeOutBack,
    easeOutBounce: () => easeOutBounce,
    easeOutCirc: () => easeOutCirc,
    easeOutCubic: () => easeOutCubic,
    easeOutElastic: () => easeOutElastic,
    easeOutExpo: () => easeOutExpo,
    easeOutQuad: () => easeOutQuad,
    easeOutQuart: () => easeOutQuart,
    easeOutQuint: () => easeOutQuint,
    easeOutSine: () => easeOutSine,
    linearTween: () => linearTween
  });
  function linearTween(t2, b2, c2, d2) {
    return c2 * t2 / d2 + b2;
  }
  function easeInQuad(t2, b2, c2, d2) {
    return c2 * (t2 /= d2) * t2 + b2;
  }
  function easeOutQuad(t2, b2, c2, d2) {
    return -c2 * (t2 /= d2) * (t2 - 2) + b2;
  }
  function easeInOutQuad(t2, b2, c2, d2) {
    t2 /= d2 / 2;
    if (t2 < 1) {
      return c2 / 2 * t2 * t2 + b2;
    }
    t2--;
    return -c2 / 2 * (t2 * (t2 - 2) - 1) + b2;
  }
  function easeInCubic(t2, b2, c2, d2) {
    return c2 * Math.pow(t2 / d2, 3) + b2;
  }
  function easeOutCubic(t2, b2, c2, d2) {
    return c2 * (Math.pow(t2 / d2 - 1, 3) + 1) + b2;
  }
  function easeInOutCubic(t2, b2, c2, d2) {
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * Math.pow(t2, 3) + b2;
    }
    return c2 / 2 * (Math.pow(t2 - 2, 3) + 2) + b2;
  }
  function easeInQuart(t2, b2, c2, d2) {
    return c2 * Math.pow(t2 / d2, 4) + b2;
  }
  function easeOutQuart(t2, b2, c2, d2) {
    return -c2 * (Math.pow(t2 / d2 - 1, 4) - 1) + b2;
  }
  function easeInOutQuart(t2, b2, c2, d2) {
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * Math.pow(t2, 4) + b2;
    }
    return -c2 / 2 * (Math.pow(t2 - 2, 4) - 2) + b2;
  }
  function easeInQuint(t2, b2, c2, d2) {
    return c2 * Math.pow(t2 / d2, 5) + b2;
  }
  function easeOutQuint(t2, b2, c2, d2) {
    return c2 * (Math.pow(t2 / d2 - 1, 5) + 1) + b2;
  }
  function easeInOutQuint(t2, b2, c2, d2) {
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * Math.pow(t2, 5) + b2;
    }
    return c2 / 2 * (Math.pow(t2 - 2, 5) + 2) + b2;
  }
  function easeInSine(t2, b2, c2, d2) {
    return c2 * (1 - Math.cos(t2 / d2 * (Math.PI / 2))) + b2;
  }
  function easeOutSine(t2, b2, c2, d2) {
    return c2 * Math.sin(t2 / d2 * (Math.PI / 2)) + b2;
  }
  function easeInOutSine(t2, b2, c2, d2) {
    return c2 / 2 * (1 - Math.cos(Math.PI * (t2 / d2))) + b2;
  }
  function easeInExpo(t2, b2, c2, d2) {
    return c2 * Math.pow(2, 10 * (t2 / d2 - 1)) + b2;
  }
  function easeOutExpo(t2, b2, c2, d2) {
    return c2 * -Math.pow(2, -10 * (t2 / d2) + 1) + b2;
  }
  function easeInOutExpo(t2, b2, c2, d2) {
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * Math.pow(2, 10 * (t2 - 1)) + b2;
    }
    return c2 / 2 * (-Math.pow(2, -10 * --t2) + 2) + b2;
  }
  function easeInCirc(t2, b2, c2, d2) {
    return c2 * (1 - Math.sqrt(1 - (t2 /= d2) * t2)) + b2;
  }
  function easeOutCirc(t2, b2, c2, d2) {
    return c2 * Math.sqrt(1 - ((t2 = t2 / d2) - 1) * t2) + b2;
  }
  function easeInOutCirc(t2, b2, c2, d2) {
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * (1 - Math.sqrt(1 - t2 * t2)) + b2;
    }
    return c2 / 2 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1) + b2;
  }
  function easeOutBounce(t2, b2, c2, d2) {
    if ((t2 /= d2) < 1 / 2.75) {
      return c2 * (7.5625 * t2 * t2) + b2;
    } else if (t2 < 2 / 2.75) {
      return c2 * (7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75) + b2;
    } else if (t2 < 2.5 / 2.75) {
      return c2 * (7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375) + b2;
    }
    return c2 * (7.5625 * ((t2 -= 2.625 / 2.75) * t2) + 0.984375) + b2;
  }
  function easeInBounce(t2, b2, c2, d2) {
    return c2 - easeOutBounce(d2 - t2, 0, c2, d2) + b2;
  }
  function easeInOutBounce(t2, b2, c2, d2) {
    if (t2 < d2 / 2) {
      return easeInBounce(t2 * 2, 0, c2, d2) * 0.5 + b2;
    }
    return easeOutBounce(t2 * 2 - d2, 0, c2, d2) * 0.5 + c2 * 0.5 + b2;
  }
  function easeInBack(t2, b2, c2, d2, s3) {
    if (s3 === void 0) {
      s3 = 1.70158;
    }
    return c2 * (t2 /= d2) * t2 * ((s3 + 1) * t2 - s3) + b2;
  }
  function easeOutBack(t2, b2, c2, d2, s3) {
    if (s3 === void 0) {
      s3 = 1.70158;
    }
    return c2 * ((t2 = t2 / d2 - 1) * t2 * ((s3 + 1) * t2 + s3) + 1) + b2;
  }
  function easeInOutBack(t2, b2, c2, d2, s3) {
    if (s3 === void 0) {
      s3 = 1.70158;
    }
    if ((t2 /= d2 / 2) < 1) {
      return c2 / 2 * (t2 * t2 * (((s3 *= 1.525) + 1) * t2 - s3)) + b2;
    }
    return c2 / 2 * ((t2 -= 2) * t2 * (((s3 *= 1.525) + 1) * t2 + s3) + 2) + b2;
  }
  function easeInElastic(t2, b2, c2, d2, a2, p2) {
    if (t2 === 0) {
      return b2;
    }
    if ((t2 /= d2) === 1) {
      return b2 + c2;
    }
    if (!p2) {
      p2 = d2 * 0.3;
    }
    if (a2 < Math.abs(c2)) {
      a2 = c2;
      const s3 = p2 / 4;
    } else {
      const s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
    }
    return -(a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * d2 - s) * (2 * Math.PI) / p2)) + b2;
  }
  function easeOutElastic(t2, b2, c2, d2, a2, p2) {
    if (t2 === 0) {
      return b2;
    }
    if ((t2 /= d2) === 1) {
      return b2 + c2;
    }
    if (!p2) {
      p2 = d2 * 0.3;
    }
    if (a2 < Math.abs(c2)) {
      a2 = c2;
      const s3 = p2 / 4;
    } else {
      const s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
    }
    return a2 * Math.pow(2, -10 * t2) * Math.sin((t2 * d2 - s) * (2 * Math.PI) / p2) + c2 + b2;
  }
  function easeInOutElastic(t2, b2, c2, d2, a2, p2) {
    if (t2 === 0) {
      return b2;
    }
    if ((t2 /= d2 / 2) === 2) {
      return b2 + c2;
    }
    if (!p2) {
      p2 = d2 * (0.3 * 1.5);
    }
    if (a2 < Math.abs(c2)) {
      a2 = c2;
      const s3 = p2 / 4;
    } else {
      const s3 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
    }
    if (t2 < 1) {
      return -0.5 * (a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * d2 - s) * (2 * Math.PI) / p2)) + b2;
    }
    return a2 * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 * d2 - s) * (2 * Math.PI) / p2) * 0.5 + c2 + b2;
  }

  // assets/scripts/ECS/math/timer.class.js
  var _Timer = class {
    constructor(tickInterval = 60, options = {}) {
      const {autoStart = _Timer.AutoStart, keepIterating = _Timer.KeepIterating, callback = null} = options;
      this.tickInterval = tickInterval;
      this.isStarted = autoStart;
      this.defaultStarted = autoStart;
      this.keepIterating = keepIterating;
      this.callback = callback;
      this.tick = 0;
    }
    progression(easingName, start = 0, end = 1) {
      return easing_exports[easingName](this.tick, start, end, this.tickInterval);
    }
    upTick() {
      if (this.tick === this.tickInterval) {
        return true;
      }
      this.tick++;
      return this.tick <= this.tickInterval;
    }
    start() {
      this.isStarted = true;
      return this;
    }
    reset() {
      this.isStarted = this.defaultStarted;
      this.tick = 0;
      return this;
    }
    walk() {
      if (!this.isStarted) {
        return false;
      }
      if (this.tick < this.tickInterval) {
        this.tick++;
        return false;
      }
      if (!this.keepIterating) {
        this.isStarted = false;
      }
      this.tick = 0;
      if (this.callback !== null) {
        this.callback();
      }
      return true;
    }
  };
  var Timer = _Timer;
  __publicField(Timer, "AutoStart", true);
  __publicField(Timer, "KeepIterating", true);
  var timer_class_default = Timer;

  // assets/scripts/ECS/math/progressiveNumber.js
  var ProgressiveNumber = class {
    constructor(min, max, options = {}) {
      if (max <= min) {
        throw new Error("max must be an higher value than min!");
      }
      const {frame = 60, easing = "linearTween", reverse = false} = options;
      this.timer = new timer_class_default(frame, {autoStart: true, keepIterating: false});
      this.min = min;
      this.max = max;
      this.dx = this.max - this.min;
      this.easing = easing;
      this.defaultReverse = reverse;
      this.reverted = reverse;
    }
    reset() {
      this.revert(this.defaultReverse);
    }
    get baseValue() {
      return this.reverted ? this.max : this.min;
    }
    revert(newValue = !this.reverted) {
      this.reverted = newValue;
      this.timer.reset();
    }
    getProgression() {
      const progression = this.timer.progression(this.easing);
      const factor = this.reverted ? 1 - progression : progression;
      return this.min + this.dx * factor;
    }
    walk(reset = true) {
      if (reset) {
        this.timer.reset();
        return this.baseValue;
      }
      if (this.timer.upTick()) {
        return this.getProgression();
      }
      return this.baseValue;
    }
  };
  var progressiveNumber_default = ProgressiveNumber;

  // assets/scripts/ECS/math/fade.js
  var Fade = class {
    constructor(displayObject, options = {}) {
      const {frame, easing, defaultState = "out", delayIn = null, delayOut = null} = options;
      this.displayObject = displayObject;
      this.displayObject.alpha = defaultState === "out" ? 0 : 1;
      this.debug = options.debug || false;
      this.delayTimer = null;
      this.delayIn = delayIn;
      this.delayOut = delayOut;
      this.callback = null;
      this.defaultState = defaultState;
      this.innerFadePn = new progressiveNumber_default(0, 1, {
        frame,
        easing,
        reverse: defaultState === "in"
      });
    }
    reset() {
      this.displayObject.alpha = this.defaultState === "out" ? 0 : 1;
      this.innerFadePn.reset();
      this.delayTimer = null;
      this.callback = null;
    }
    set centerPosition(pos) {
      this.displayObject.position.set(pos.x - window.innerWidth / 2, pos.y - window.innerHeight / 2);
    }
    auto(callback = null) {
      const currentState = this.state;
      const autoCallback = callback === null ? null : () => {
        callback();
        this[currentState]();
      };
      if (currentState === "out") {
        this.in(autoCallback);
      } else {
        this.out(autoCallback);
      }
    }
    out(callback = null) {
      if (this.state === "out") {
        return;
      }
      if (this.delayOut !== null) {
        this.delayTimer = new timer_class_default(this.delayOut, {autoStart: true, keepIterating: false});
      }
      this.callback = callback;
      this.displayObject.alpha = 0;
      this.innerFadePn.revert(false);
    }
    in(callback = null) {
      if (this.state === "in") {
        return;
      }
      if (this.delayIn !== null) {
        this.delayTimer = new timer_class_default(this.delayIn, {autoStart: true, keepIterating: false});
      }
      this.callback = callback;
      this.displayObject.alpha = 1;
      this.innerFadePn.revert(true);
    }
    get state() {
      return this.innerFadePn.reverted ? "in" : "out";
    }
    autoUpdate() {
      this.displayObject.on("update", this.update.bind(this));
      return this;
    }
    update() {
      const hasDelayTimer = this.delayTimer !== null;
      if (hasDelayTimer && !this.delayTimer.walk()) {
        return false;
      }
      if (hasDelayTimer) {
        this.delayTimer = null;
      }
      const alpha = this.innerFadePn.walk(false);
      this.displayObject.alpha = alpha;
      if (this.state === "out" && alpha >= 1 || this.state === "in" && alpha <= 0) {
        if (typeof this.callback === "function") {
          this.callback();
          this.callback = null;
        }
        return true;
      }
      return false;
    }
  };
  var fade_default = Fade;

  // assets/scripts/ECS/engine.class.js
  var Engine = class extends assetloader_class_default {
    constructor(options = Object.create(null)) {
      super();
      this.debug = options.debug || false;
      this.state = options.state || new state_class_default({});
      this.waitingScenes = [];
      this.app = new PIXI17.Application({
        width: window.innerWidth,
        height: window.innerHeight,
        autoResize: true,
        antialias: false
      });
      this.app.stage.interactive = true;
      window.game = this;
      this.viewport = new Viewport({
        screenWidth: window.innerWidth,
        screenHeight: window.innerHeight,
        worldWidth: 500,
        worldHeight: 500,
        interaction: this.app.renderer.plugins.interaction
      });
      this.input = new input_class_default(this.app.view);
      this.mousePosition = null;
      this.app.renderer.view.addEventListener("mousedown", () => {
      }, {once: true});
      this.defaultRootScene = options.defaultScene;
      this.rootScene = null;
      document.body.appendChild(this.app.view);
      window.addEventListener("resize", this.resizeRendererToScreenSize.bind(this));
    }
    get resolution() {
      return PIXI17.settings.RESOLUTION * 2;
    }
    get screenSize() {
      const {width, height} = this.app.renderer.view;
      return {width, height};
    }
    get stage() {
      return this.app.stage;
    }
    get renderer() {
      return this.app.renderer;
    }
    loadScene(sceneName, ...options) {
      const sceneInstance = scene_class_default.cache.get(sceneName);
      if (typeof sceneInstance === "undefined") {
        throw new Error(`Unable to found scene with name '${sceneName}'`);
      }
      this.fade.out(() => {
        this._destroyRootScene();
        tiledset_default.cache = [];
        tiledset_default.loaded.clear();
        tiledmap_default.sharedCollisionLayer = null;
        this.rootScene = null;
        this._initRootScene(sceneInstance, ...options);
      });
    }
    appendScene(sceneName, options = {}) {
      const sceneInstance = scene_class_default.cache.get(sceneName);
      if (typeof sceneInstance === "undefined") {
        throw new Error(`Unable to found scene with name '${sceneName}'`);
      }
      const params = options.params || [];
      const loaded = options.loaded || null;
      if (this.rootScene === null || this.rootScene.constructor.name !== sceneInstance.constructor.name) {
        this.waitingScenes.push({
          scene: new sceneInstance(...params),
          callback: loaded
        });
      } else {
        const scene = this.rootScene.add(new sceneInstance(...params));
        if (loaded !== null) {
          loaded(scene);
        }
      }
    }
    init() {
      console.log(`[INFO] init engine`);
      this.resizeRendererToScreenSize();
      this.loadAsync(() => {
        this.loadAssets(this.app.loader, () => this._initStage());
      });
      this.emit("init");
      return this;
    }
    _initStage() {
      console.log(`[INFO] initStage start`);
      this.app.stage.addChild(this.viewport);
      this.viewport.zoomPercent(1);
      this.viewport.wheel({smooth: 150, lineHeight: 300});
      this._initRootScene(this.defaultRootScene);
      this.app.ticker.add(this.update.bind(this));
      console.log(`[INFO] initStage end`);
    }
    _initRootScene(sceneInstance, ...options) {
      this.rootScene = new sceneInstance(...options);
      this.viewport.addChild(this.rootScene);
      for (const {scene, callback} of this.waitingScenes) {
        this.rootScene.add(scene);
        callback(scene);
      }
      this.waitingScenes = [];
      console.log("[INFO] Waiting scenes added to current scene!");
      this.cursorSprite = new PIXI17.Graphics().beginFill(PIXI17.utils.string2hex("#000"), 1).drawCircle(0, 0, 5).endFill();
      this.cursorSprite.zIndex = 29;
      this.app.stage.on("pointermove", (event) => {
        this.mousePosition = event.data.global;
        const localPos = this.viewport.toWorld(this.mousePosition.x, this.mousePosition.y);
        this.cursorSprite.position.set(localPos.x, localPos.y);
      });
      const fadeGraphic = new PIXI17.Graphics().beginFill(PIXI17.utils.string2hex("#000"), 1).drawRect(0, 0, window.innerWidth, window.innerHeight).endFill();
      fadeGraphic.zIndex = 30;
      this.fade = new fade_default(fadeGraphic, {
        frame: 30,
        delayIn: 20,
        delayOut: 20,
        defaultState: "in"
      });
      this.rootScene.addChild(this.cursorSprite);
      this.rootScene.addChild(fadeGraphic);
      this.rootScene.init(this);
    }
    _destroyRootScene() {
      this.app.stage.removeAllListeners("pointermove");
      this.cursorSprite.destroy();
      this.fade.displayObject.destroy({children: true});
      this.fade = null;
      this.rootScene.cleanup();
      this.viewport.removeChild(this.rootScene);
    }
    update(delta = 0) {
      if (this.fade !== null) {
        this.fade.update();
      }
      this.emit("update", delta);
      this.input.update(delta);
    }
    resizeRendererToScreenSize() {
      console.log(`[INFO] resize renderer triggered!`);
      const {innerWidth, innerHeight} = window;
      this.app.renderer.resize(innerWidth, innerHeight);
      this.viewport.resize(innerWidth, innerHeight);
    }
  };
  var engine_class_default = Engine;

  // assets/scripts/ECS/searchtree.js
  var kAlwaysTrue = () => true;
  var SearchTree = class {
    static parsePattern(pattern) {
      const type2 = typeof pattern;
      return (actor) => {
        return type2 === "string" ? actor.name.startsWith(pattern) : pattern.test(actor.name);
      };
    }
    constructor(pattern, filter = null) {
      this.pattern = SearchTree.parsePattern(pattern);
      this.filter = filter || kAlwaysTrue;
      this.active = false;
      this.sources = new Set();
      this.currentActorsRef = new Set();
    }
    get actors() {
      return [...this.currentActorsRef];
    }
    search() {
      for (const source of this.sources) {
        for (const actor of source.getActors(true)) {
          this.addActor(actor);
        }
      }
      this.active = true;
    }
    use(tree) {
      if (!(tree instanceof actortree_class_default)) {
        throw new TypeError("tree must be an instanceof ActorTree");
      }
      this.sources.add(tree);
      const bindFn = this.addActor.bind(this);
      tree.on("appendActor", bindFn);
      tree.once("cleanup", () => {
        this.sources.delete(tree);
        tree.removeListener("appendActor", bindFn);
      });
    }
    addActor(actor) {
      if (!this.active || !this.pattern(actor) || !this.filter(actor)) {
        return false;
      }
      this.currentActorsRef.add(actor);
      actor.once("destroy", () => {
        this.currentActorsRef.delete(actor);
      });
      return true;
    }
    *[Symbol.iterator]() {
      yield* this.currentActorsRef;
    }
  };
  var searchtree_default = SearchTree;

  // assets/scripts/ECS/index.js
  var Components = {
    Types,
    AnimatedSpriteEx: animatedsprite_class_default,
    TiledMap: tiledmap_default
  };

  // assets/scripts/helpers/entitybuilder.js
  var entitybuilder_exports = {};
  __export(entitybuilder_exports, {
    cache: () => cache,
    create: () => create,
    createMany: () => createMany,
    define: () => define2,
    getKeys: () => getKeys,
    increment: () => increment
  });
  var cache = new Map();
  var incrementStore = new Map();
  function increment(name) {
    const count = incrementStore.get(name) || 0;
    incrementStore.set(name, count + 1);
    return `${name}${count}`;
  }
  function getKeys(pattern) {
    const filterFn = typeof entityName === "string" ? (key) => key.startsWith(pattern) : (key) => pattern.test(key);
    return [...cache.keys()].filter(filterFn);
  }
  function define2(entityName2, action) {
    if (typeof entityName2 !== "string") {
      throw new TypeError("entityName must be a string");
    }
    cache.set(entityName2, action);
  }
  function create(entityName2, ...options) {
    if (!cache.has(entityName2)) {
      throw new Error(`No entity with name '${entityName2}'`);
    }
    const action = cache.get(entityName2);
    return action(...options);
  }
  function createMany(entityName2, count = 1, ...options) {
    const entities = [];
    for (let i2 = 0; i2 < count; i2++) {
      entities.push(create(entityName2, ...options));
    }
    return entities;
  }

  // assets/scripts/helpers/spatialSound.js
  var PIXI18 = __toModule(require_pixi());
  function rad(degress) {
    return degress * (Math.PI / 180);
  }
  function deg(radians) {
    return radians * (180 / Math.PI);
  }
  var SpatialSound = class {
    constructor(assetName, gameObject, listener, options = {}) {
      this.gameObject = gameObject;
      this.listener = listener;
      this.loop = options.loop || true;
      this.maxsound = options.maxsound || 1;
      this.max = options.max || 100;
      this.min = options.min || 3;
      this.panBalancer = options.panBalancer || 100;
      this.easing = options.easing || "linearTween";
      this.debug = options.debug || false;
      if (this.debug) {
        this.createCircleGraphic();
      }
      this.sound = I.find(assetName);
      this.sound.volume = this.maxsound;
      this.sound.loop = this.loop;
      this.stereo = new k.StereoFilter();
      this.sound.filters = [this.stereo];
      this.sound.play();
    }
    createCircleGraphic() {
      const circle = new PIXI18.Graphics();
      circle.beginFill(16777215, 0.35);
      circle.drawCircle(0, 0, this.max);
      circle.endFill();
      this.gameObject.addChild(circle);
    }
    check() {
      const currentPos = this.gameObject.pos;
      const distance = currentPos.distanceTo(this.listener.pos);
      if (distance < this.max && distance > 0) {
        if (distance < this.min) {
          this.sound.volume = this.maxsound;
        } else {
          const factor = 1 - easing_exports[this.easing](distance - this.min, 0, 1, this.max - this.min);
          this.sound.volume = factor * this.maxsound;
        }
        const listenerOrient = rad(this.listener.angle);
        const listenerDirection = new vector2_default(Math.sin(listenerOrient), Math.cos(listenerOrient));
        const normalizedListenerDirection = listenerDirection.clone().normalize();
        const soundDirection = this.listener.pos.clone().sub(currentPos);
        let pan = 0;
        {
          const dotProduct = normalizedListenerDirection.dot(soundDirection);
          const lengthProd = normalizedListenerDirection.length() * soundDirection.length();
          const resultAngle = deg(Math.acos(dotProduct / lengthProd));
          pan = resultAngle > 90 ? (90 - resultAngle % 90) / this.panBalancer : resultAngle / this.panBalancer;
        }
        const determinent = listenerDirection.x * soundDirection.y - listenerDirection.y * soundDirection.x;
        this.stereo.pan = determinent >= 0 ? -pan : pan;
      } else {
        this.sound.volume = 0;
      }
    }
  };
  var spatialSound_default = SpatialSound;

  // assets/scripts/helpers/zIndexManager.js
  var PIXI19 = __toModule(require_pixi());
  var _zIndexManager = class {
    constructor(target, items = []) {
      this.target = target;
      this.target.zIndex = 2;
      this.items = new Set(items);
      this.started = true;
    }
    addItem(item) {
      this.items.add(item);
      item.once("destroy", () => this.items.delete(item));
      return this;
    }
    stop() {
      this.items = new Set();
      this.started = false;
    }
    update() {
      if (!this.started || this.target === null) {
        return;
      }
      const targetY = this.target.position.y;
      for (const item of this.items) {
        const itemPosY = item.position.y;
        if (itemPosY > targetY) {
          if (item.zIndex !== _zIndexManager.positiveId) {
            console.log("target at the top!");
            item.zIndex = _zIndexManager.positiveId;
          }
        } else if (item.zIndex !== _zIndexManager.negativeId) {
          console.log("target at the bottom!");
          item.zIndex = _zIndexManager.negativeId;
        }
      }
    }
  };
  var zIndexManager = _zIndexManager;
  __publicField(zIndexManager, "negativeId", 1);
  __publicField(zIndexManager, "positiveId", 3);
  var zIndexManager_default = zIndexManager;

  // assets/scripts/helpers/AnimatedText.js
  var AnimatedText_exports = {};
  __export(AnimatedText_exports, {
    FadeTextAnimation: () => FadeTextAnimation,
    MovingTextAnimation: () => MovingTextAnimation,
    WritingTextAnimation: () => WritingTextAnimation,
    default: () => AnimatedText_default
  });
  var PIXI20 = __toModule(require_pixi());
  var TextAnimation = class {
    init() {
    }
    update() {
    }
  };
  var WritingTextAnimation = class extends TextAnimation {
    constructor(options = {}) {
      super();
      this.charTick = options.charTick || 5;
      this.pauseTimeBetweenLine = options.pauseTimeBetweenLine || 0;
      this.pauseTimer = new timer_class_default(this.pauseTimeBetweenLine, {autoStart: false, keepIterating: false});
      this.tick = 0;
      this.maxTextLength = 0;
      this._parent = null;
    }
    init(parent) {
      this._parent = parent;
      this.maxTextLength = this._parent.gameObject.text.length;
      this._parent.gameObject.text = "";
    }
    reset() {
      this.tick = 0;
      this._parent.gameObject.text = "";
    }
    spaceLength(text = null) {
      if (text === null || text === "") {
        return 0;
      }
      return text.length - text.trimLeft().length;
    }
    update() {
      if (this.pauseTimer.isStarted) {
        if (!this.pauseTimer.walk()) {
          return false;
        }
        this.pauseTimer.reset();
      }
      const sliceIndex = Math.floor(this.tick / this.charTick);
      if (sliceIndex > this.maxTextLength) {
        return true;
      }
      if (sliceIndex > this._parent.gameObject.text.length) {
        const slicedText = this._parent.textStr.slice(sliceIndex);
        const spaceCount = this.spaceLength(slicedText);
        this._parent.gameObject.text = this._parent.textStr.slice(0, sliceIndex) + " ".repeat(spaceCount);
        const isNewLine = slicedText.charAt(0) === "\n";
        if (this.pauseTimeBetweenLine > 0 && isNewLine) {
          this.pauseTimer.start();
        }
        this.tick += this.charTick * spaceCount;
      }
      this.tick++;
      return false;
    }
  };
  var FadeTextAnimation = class extends TextAnimation {
    constructor(options = {}) {
      super();
      this.fade = null;
      this.fadeOptions = options;
      this.done = false;
      this.startAt = options.startAt || null;
      this.decalTimer = this.startAt !== null ? new timer_class_default(this.startAt, {autoStart: true, keepIterating: false}) : null;
    }
    init(parent) {
      this._parent = parent;
      this.fade = new fade_default(this._parent.gameObject, this.fadeOptions);
    }
    reset() {
      this.done = false;
      if (this.decalTimer !== null) {
        this.decalTimer.reset();
      }
      this.fade.reset();
    }
    update() {
      if (this.decalTimer !== null && this.decalTimer.isStarted) {
        if (!this.decalTimer.walk()) {
          return false;
        }
      }
      if (this.done) {
        return true;
      }
      const state = this.fade.update();
      if (state) {
        this.done = true;
      }
      return state;
    }
  };
  var MovingTextAnimation = class extends TextAnimation {
    constructor(options = {}) {
      super();
      this.decalX = options.decalX || 0;
      this.decalY = options.decalY || 0;
      this.frame = options.frame;
      this.easing = options.easing || "linearTween";
      this.position = new vector2_default(0, 0);
      this.target = new vector2_default(this.decalX, this.decalY);
      this.done = false;
      this.pn = new progressiveNumber_default(0, 1, {
        frame: this.frame,
        easing: this.easing
      });
    }
    init(parent) {
      this._parent = parent;
      const position = this._parent.gameObject.position;
      this.position = new vector2_default(position.x, position.y);
      this._parent.gameObject.position.set(this.decalX, this.decalY);
    }
    reset() {
      this._parent.gameObject.position.set(this.decalX, this.decalY);
      this.pn.reset();
      this.done = false;
    }
    lerpPosition(progression) {
      return this.target.clone().lerp(this.position, progression);
    }
    update() {
      if (this.done) {
        return true;
      }
      const progression = this.pn.walk(false);
      if (progression === 1) {
        this.done = true;
        this._parent.gameObject.position.set(this.position.x, this.position.y);
        return true;
      }
      const warpPosition = this.lerpPosition(progression);
      this._parent.gameObject.position.set(warpPosition.x, warpPosition.y);
      return false;
    }
  };
  var AnimatedText = class extends PIXI20.Container {
    constructor(text, style, options = {}) {
      super();
      this.textStr = text;
      this.textStyle = style;
      this.started = false;
      this.loop = options.loop || false;
      this.autoStart = typeof options.autoStart === "boolean" ? options.autoStart : true;
      this.autoDestroy = options.autoDestroy || false;
      this.resetOnLinkedStop = options.resetOnLinkedStop || false;
      this.autoHide = options.autoHide || false;
      this.animations = options.animations || [];
      this.linked = [];
      this.linkedFrom = null;
      this.linkedInitialized = false;
      if (this.loop && this.autoDestroy) {
        throw new Error("cannot use loop true in combinaison with autoDestroy");
      }
      this.animationsName = new Set();
      this.gameObject = new PIXI20.Text(text, style);
      if (this.autoHide && !this.animationsName.has("FadeTextAnimation")) {
        this.gameObject.alpha = 0;
      }
      for (const animation of this.animations) {
        this.animationsName.add(animation.constructor.name);
        animation.init(this);
      }
      this.addChild(this.gameObject);
      if (this.autoStart) {
        this.start();
      }
    }
    linkTo(animatedText) {
      this.linked.push(animatedText);
    }
    linkFrom(animatedText, options = {}) {
      this.linkedFrom = animatedText;
      this.start();
      if (options.reset) {
        this.once("stop", () => animatedText.reset());
      }
    }
    destroy() {
      this.started = false;
      super.destroy({children: true, baseTexture: true, texture: true});
    }
    start() {
      this.started = true;
      if (this.autoHide && !this.animationsName.has("FadeTextAnimation")) {
        this.gameObject.alpha = 1;
      }
      this.emit("start");
    }
    stop() {
      if (this.loop) {
        this.reset();
      } else {
        this.started = false;
      }
      if (!this.linkedInitialized) {
        for (const linkedAt of this.linked) {
          linkedAt.linkFrom(this, {reset: this.resetOnLinkedStop});
        }
        this.linkedInitialized = true;
      }
      this.emit("stop");
    }
    reset() {
      for (const animation of this.animations) {
        animation.reset();
      }
      this.started = this.autoStart;
    }
    update() {
      if (!this.started) {
        return;
      }
      let completed = 0;
      for (const animation of this.animations) {
        animation.update() && completed++;
      }
      if (completed < this.animations.length) {
        return;
      }
      if (this.autoDestroy) {
        return this.destroy();
      }
      this.stop();
    }
  };
  var AnimatedText_default = AnimatedText;

  // assets/scripts/behaviours/CreatureBehavior.js
  var kHandicapForDeplacement = 120;
  var kHandicapForShooting = 280;
  var CreatureBehavior = class extends scriptbehavior_default {
    constructor() {
      super();
      const {x: x2, y: y2} = vector2_default.randomCoordInRadius(200);
      this.position = {x: x2, y: y2};
      this.nextPos = {x: null, y: null};
      this.radius = 80;
      this.isInAction = false;
      this.action = null;
      this.delayToMove = new timer_class_default(kHandicapForDeplacement, {autoStart: true, keepIterating: false});
      this.delayToShoot = new timer_class_default(kHandicapForShooting, {autoStart: false, keepIterating: false});
    }
    awake() {
      this.sprite = this.actor.addComponent(new Components.AnimatedSpriteEx("adventurer", {defaultAnimation: "adventurer-idle"}));
      this.actor.position.set(this.position.x, this.position.y);
    }
    start() {
      this.target = getActor("player");
    }
    update() {
      if (this.canShoot()) {
        this.initShoot();
        return;
      }
      if (!this.isInAction) {
        if (this.delayToMove.walk()) {
          const r2 = this.radius / 2 * Math.sqrt(Math.random());
          const theta = Math.random() * 2 * Math.PI;
          const x2 = Math.round(this.position.x + r2 * Math.cos(theta));
          const y2 = Math.round(this.position.y + r2 * Math.sin(theta));
          this.nextPos.x = x2;
          this.nextPos.y = y2;
          this.isInAction = true;
          this.action = "DEPLACEMENT";
          this.goTo();
        }
      } else {
        this.goTo();
      }
      this.sprite.playAnimation(this.actor.moving ? "adventurer-run" : "adventurer-idle");
    }
    canShoot() {
      const isInside = Math.pow(this.actor.x - this.target.x, 2) + Math.pow(this.actor.y - this.target.y, 2) <= this.radius * this.radius;
      if (isInside) {
        if (!this.delayToShoot.isStarted) {
          this.delayToShoot.start();
          return false;
        }
        if (this.delayToShoot.walk()) {
          this.delayToShoot.reset();
          return true;
        }
      }
      return false;
    }
    initShoot() {
      game.rootScene.add(create("actor:projectile", {
        startPos: {x: this.actor.x, y: this.actor.y},
        targetPos: {x: this.target.x, y: this.target.y}
      }));
    }
    goTo() {
      this.isInAction = true;
      if (this.nextPos.x === this.actor.x && this.nextPos.y === this.actor.y) {
        this.action = null;
        this.nextPos.x = null;
        this.nextPos.y = null;
        this.isInAction = false;
        this.delayToMove = new timer_class_default(kHandicapForDeplacement);
      } else {
        if (this.actor.x !== this.nextPos.x)
          this.actor.x = this.actor.x < this.nextPos.x ? this.actor.x + 1 : this.actor.x - 1;
        if (this.actor.y !== this.nextPos.y)
          this.actor.y = this.actor.y < this.nextPos.y ? this.actor.y + 1 : this.actor.y - 1;
      }
    }
  };
  var CreatureBehavior_default = CreatureBehavior;
  scriptbehavior_default.define("CreatureBehavior", CreatureBehavior);
  define2("actor:creature", () => {
    return new actor_class_default(increment("creature")).createScriptedBehavior(new CreatureBehavior());
  });

  // assets/scripts/keys.js
  var Keys = {
    left: [Key.Q, Key.LEFT],
    right: [Key.D, Key.RIGHT],
    top: [Key.Z, Key.UP],
    bottom: [Key.S, Key.DOWN],
    use: [Key.E, Key.SPACE]
  };
  function isDown(keyName) {
    return Keys[keyName].some((key) => game.input.isKeyDown(key));
  }
  var Inputs = {
    left: () => isDown("left"),
    right: () => isDown("right"),
    up: () => isDown("top"),
    down: () => isDown("bottom"),
    use() {
      return Keys.use.some((key) => game.input.wasKeyJustPressed(key));
    }
  };

  // assets/scripts/behaviours/DoorBehavior.js
  var DoorBehavior = class extends scriptbehavior_default {
    awake() {
      this.warpTimer = new timer_class_default(30, {autoStart: false, keepIterating: false});
    }
    start() {
      this.target = getActor("player");
      this.connectedTo = getActor(this.actor.tileProperties.connectTo);
    }
    warp() {
      this.warpTimer.start();
      const script = this.target.getScriptedBehavior("PlayerBehavior");
      script.sendMessage("teleport", this.connectedTo.centerPosition);
    }
    update() {
      if (this.warpTimer.isStarted && !this.warpTimer.walk()) {
        return;
      }
      if (Inputs.use() && hitTestRectangle(this.actor, this.target)) {
        this.warp();
      }
    }
  };
  var DoorBehavior_default = DoorBehavior;
  scriptbehavior_default.define("DoorBehavior", DoorBehavior);

  // assets/scripts/behaviours/DungeonDoorBehavior.js
  var DungeonDoorBehavior = class extends scriptbehavior_default {
    awake() {
      this.teleporting = false;
    }
    start() {
      this.target = getActor("player");
    }
    warp() {
      this.teleporting = true;
      const script = this.target.getScriptedBehavior("PlayerBehavior");
      script.playable = false;
      console.clear();
      console.log("load scene");
      game.loadScene("dungeon");
    }
    update() {
      if (this.teleporting) {
        return;
      }
      const distance = this.actor.pos.distanceTo(this.target.pos);
      if (distance < 50 && Inputs.use()) {
        this.warp();
      }
    }
  };
  var DungeonDoorBehavior_default = DungeonDoorBehavior;
  scriptbehavior_default.define("DungeonDoorBehavior", DungeonDoorBehavior);

  // assets/scripts/behaviours/PlayerBehavior.js
  var kPlayerStats = {
    speed: 1,
    currentHp: 1,
    maxHp: 20
  };
  var PlayerBehavior = class extends scriptbehavior_default {
    constructor(speed = kPlayerStats.speed, currentHp = kPlayerStats.currentHp, maxHp = kPlayerStats.maxHp) {
      super({
        currentHp: "player.currentHp",
        maxHp: "player.maxHp"
      });
      this.currentHp = currentHp;
      this.maxHp = maxHp;
      this.playable = true;
      this.time = new timer_class_default(60);
      this.speed = new progressiveNumber_default(speed, speed * 2, {
        easing: "easeInQuad",
        frame: 90
      });
    }
    teleport(position) {
      console.log("player teleport at: ", position);
      this.playable = false;
      game.fade.auto(() => {
        game.fade.centerPosition = position;
        this.actor.pos = position;
        game.viewport.moveCenter(this.actor.x, this.actor.y);
        this.playable = true;
      });
    }
    awake() {
      {
        const spriteComponent = new Components.AnimatedSpriteEx("adventurer", {
          defaultAnimation: "adventurer-idle"
        });
        spriteComponent.anchor.set(0.5, 1);
        spriteComponent.oneToMany("idle", ["adventurer-idle", "adventurer-idle-2"]);
        this.sprite = this.actor.addComponent(spriteComponent);
      }
      this.deathSound = I.find("death");
      this.deathSound.volume = 0.1;
    }
    start() {
      const map = getActor("map") || getActor("start_room");
      if (map) {
        const spawn = map.findChild("spawn", true);
        if (spawn) {
          this.actor.pos = spawn.centerPosition;
        }
        this.collision = map.getComponent(Components.Types.TiledMap).collision;
      }
      game.viewport.moveCenter(this.actor.x, this.actor.y);
      game.viewport.follow(this.actor, {
        speed: 1.5,
        acceleration: 0.01,
        radius: 40
      });
    }
    update() {
      game.fade.centerPosition = this.actor.pos;
      if (!this.playable) {
        return;
      }
      if (this.time.walk() && this.currentHp < this.maxHp) {
        this.currentHp += 1;
      }
      const neighbours = this.collision.getNeighBourWalkable(this.actor.x, this.actor.y);
      const isLeftWalkable = !neighbours.left || neighbours.right;
      const isRightWalkable = !neighbours.right || neighbours.left;
      const isTopWalkable = !neighbours.top || neighbours.bottom;
      const isBottomWalkable = !neighbours.bottom || neighbours.top;
      const currentSpeed = this.speed.walk(!this.actor.moving);
      if (Inputs.left() && isLeftWalkable) {
        this.actor.moveX(-currentSpeed);
        this.sprite.scale.x = -1;
      } else if (Inputs.right() && isRightWalkable) {
        this.actor.moveX(currentSpeed);
        this.sprite.scale.x = 1;
      }
      if (Inputs.up() && isTopWalkable) {
        this.actor.moveY(-currentSpeed);
      } else if (Inputs.down() && isBottomWalkable) {
        this.actor.moveY(currentSpeed);
      }
      if (game.input.wasKeyJustPressed(Key.L)) {
        this.sprite.playAnimation("adventurer-die", {loop: false});
        if (!this.deathSound.isPlaying) {
          this.deathSound.play();
        }
      }
      this.sprite.playAnimation(this.actor.moving ? "adventurer-run" : "idle");
      this.actor.applyVelocity();
    }
  };
  var PlayerBehavior_default = PlayerBehavior;
  scriptbehavior_default.define("PlayerBehavior", PlayerBehavior);
  entitybuilder_exports.define("actor:player", () => {
    return new actor_class_default("player").createScriptedBehavior("PlayerBehavior");
  });

  // assets/scripts/behaviours/ProjectileBehavior.js
  var kDefaultFadeInFrames = 240;
  var ProjectileBehavior = class extends scriptbehavior_default {
    constructor(options = {}) {
      const {startPos, targetPos} = options;
      super();
      this.startPos = startPos;
      this.targetPos = targetPos;
      this.targetPos.x = Math.round(this.targetPos.x);
      this.targetPos.y = Math.round(this.targetPos.y);
      this.radius = 15;
    }
    awake() {
      console.log(`Projectile with name: ${this.actor.name} created`);
      this.sprite = this.actor.addComponent(new animatedsprite_class_default("adventurer", {defaultAnimation: "adventurer-idle"}));
      this.actor.pos = this.startPos;
      this.tick = 0;
    }
    die(cause) {
      console.log("projectile die because: ", cause);
      this.actor.cleanup();
    }
    update() {
      this.tick++;
      if (this.tick >= kDefaultFadeInFrames) {
        this.die("timeout");
      } else if (Math.round(this.actor.x) !== this.targetPos.x || Math.round(this.actor.y) !== this.targetPos.y) {
        if (this.actor.x < this.targetPos.x) {
          this.actor.moveX(1);
        } else if (this.actor.x > this.targetPos.x) {
          this.actor.moveX(-1);
        }
        if (this.actor.y < this.targetPos.y) {
          this.actor.moveY(1);
        } else if (this.actor.y > this.targetPos.y) {
          this.actor.moveY(-1);
        }
        this.actor.applyVelocity();
        this.sprite.playAnimation(this.actor.moving ? "adventurer-run" : "adventurer-die");
      } else {
        this.die("hit");
      }
    }
  };
  var ProjectileBehavior_default = ProjectileBehavior;
  scriptbehavior_default.define("ProjectileBehavior", ProjectileBehavior);
  entitybuilder_exports.define("actor:projectile", (options = {}) => {
    return new actor_class_default(entitybuilder_exports.increment("projectile")).createScriptedBehavior(new ProjectileBehavior(options));
  });

  // assets/scripts/behaviours/SpatialSoundBehavior.js
  var SpatialSoundBehavior = class extends scriptbehavior_default {
    constructor(soundName, radius = 100) {
      super();
      this.soundRadius = radius;
      this.soundName = soundName;
    }
    awake() {
      const {x: x2, y: y2} = vector2_default.randomCoordInRadius(60);
      this.actor.position.set(x2, y2);
    }
    start() {
      const listener = getActor("player");
      this.sound = new spatialSound_default(this.soundName, this.actor, listener, {
        maxsound: 0.5,
        max: this.soundRadius,
        debug: true
      });
    }
    update() {
      this.sound.check();
    }
  };
  var SpatialSoundBehavior_default = SpatialSoundBehavior;
  scriptbehavior_default.define("SpatialSoundBehavior", SpatialSoundBehavior);
  entitybuilder_exports.define("sound:3D", (soundName, radius) => {
    return new actor_class_default(entitybuilder_exports.increment("sound")).createScriptedBehavior("SpatialSoundBehavior", soundName, radius);
  });

  // assets/scripts/scenes/DefaultScene.js
  var DefaultScene = class extends scene_class_default {
    constructor() {
      super({useLRUCache: true, debug: true});
      {
        const map = new actor_class_default("map");
        const tiledMap = new Components.TiledMap("map1", {debug: true});
        tiledMap.on("object", this.build.bind(this));
        tiledMap.init();
        map.addComponent(tiledMap);
        this.add(map);
      }
      const playerActor = entitybuilder_exports.create("actor:player");
      this.add(playerActor);
      this.graph = new actor_class_default("graph");
      {
        const temp = new PIXI.Graphics().beginFill(PIXI.utils.string2hex("#000"), 1).drawCircle(0, 0, 30).endFill();
        this.graph.addChild(temp);
      }
      this.graph.position.set(0, 0);
      this.addChild(this.graph);
      this.zManager = new zIndexManager_default(playerActor, [this.graph]);
    }
    cleanup() {
      this.zManager.stop();
      this.zManager = null;
      super.cleanup();
    }
    build(actor) {
      if (actor.name.startsWith("door")) {
        actor.createScriptedBehavior("DoorBehavior");
      } else if (actor.name === "test") {
        actor.createScriptedBehavior("DungeonDoorBehavior");
      }
    }
    update() {
      super.update();
      if (this.zManager !== null) {
        this.zManager.update();
      }
    }
  };
  var DefaultScene_default = DefaultScene;
  scene_class_default.define("default", DefaultScene);

  // assets/scripts/scenes/DungeonScene.js
  var PIXI21 = __toModule(require_pixi());
  var import_RoomSpawner = __toModule(require_RoomSpawner_class());
  var DungeonScene = class extends scene_class_default {
    constructor() {
      super({useLRUCache: true, debug: true});
      this.roomWidth = 40;
      this.roomHeight = 26;
      const spawner = new import_RoomSpawner.default(10, {
        includeSecretRoom: false,
        minRooms: 6,
        maxRooms: 10,
        roomWidth: this.roomWidth,
        roomHeight: this.roomHeight,
        tileSize: 16
      });
      spawner.draw();
      this.levelRooms = [...spawner.getWorldRooms()];
      this.startRoom = this.levelRooms[0];
      for (let i2 = 0; i2 < this.levelRooms.length; i2++) {
        game.appendScene("room", {
          params: [i2 === 0 ? "start_room" : `room_${i2}`, this.levelRooms[i2]],
          loaded: this.sceneLoaded.bind(this)
        });
      }
    }
    sceneLoaded(scene) {
      const areaNameText = new PIXI21.Text(`${scene.roomName} - ${scene.type}`, {
        fill: "#12d94d",
        fontFamily: "Verdana",
        fontSize: 20,
        fontVariant: "small-caps",
        fontWeight: "bold",
        letterSpacing: 1,
        lineJoin: "round",
        strokeThickness: 2,
        align: "center"
      });
      areaNameText.anchor.set(0.5);
      areaNameText.position.set(this.roomWidth * 16 / 2, this.roomHeight * 16 / 2);
      scene.addChild(areaNameText);
    }
    centerOfRoom(room) {
      return {
        x: room.x + this.roomWidth * 16 / 2,
        y: room.y + this.roomHeight * 16 / 2
      };
    }
    awake() {
      super.awake();
      const playerActor = entitybuilder_exports.create("actor:player");
      const startCenter = this.centerOfRoom(this.startRoom);
      playerActor.position.set(startCenter.x, startCenter.y);
      this.add(playerActor);
    }
  };
  var DungeonScene_default = DungeonScene;
  scene_class_default.define("dungeon", DungeonScene);

  // assets/scripts/scenes/RoomScene.js
  var RoomScene = class extends scene_class_default {
    constructor(roomName, options = {}) {
      super({useLRUCache: true, debug: false});
      const {x: x2, y: y2, type: type2, doors} = options;
      this.roomName = roomName;
      this.position.set(x2, y2);
      this.type = type2;
      this.doors = doors;
      {
        const map = new actor_class_default(roomName);
        this.add(map);
        const tiledMap = new Components.TiledMap("room", {
          debug: false,
          useSharedCollision: true,
          collisionOffset: {x: x2, y: y2}
        });
        tiledMap.init();
        map.addComponent(tiledMap);
      }
      console.log(`Init room '${roomName}': ${type2} - ${doors}`);
    }
  };
  var RoomScene_default = RoomScene;
  scene_class_default.define("room", RoomScene);

  // assets/scripts/scenes/TextScene.js
  var TextScene = class extends scene_class_default {
    constructor() {
      super({useLRUCache: true, debug: false});
    }
    getStyle() {
      return {
        fill: "#12d94d",
        fontFamily: "Verdana",
        fontSize: 10,
        fontVariant: "small-caps",
        fontWeight: "bold",
        letterSpacing: 1,
        lineJoin: "round",
        strokeThickness: 2,
        align: "center"
      };
    }
    awake() {
      super.awake();
      const {width, height} = game.screenSize;
      this.animatedText = new AnimatedText_default("bienvenue fraxken...", this.getStyle(), {
        resetOnLinkedStop: true,
        animations: [
          new AnimatedText_exports.WritingTextAnimation({
            charTick: 4,
            pauseTimeBetweenLine: 60
          }),
          new AnimatedText_exports.FadeTextAnimation({
            frame: 60,
            easing: "easeInQuad",
            defaultState: "out"
          }),
          new AnimatedText_exports.MovingTextAnimation({
            decalY: 40,
            frame: 80,
            easing: "easeOutQuad"
          })
        ]
      });
      this.animatedText.position.set(width / 8, height / 8);
      this.animatedText.gameObject.anchor.set(0.5);
      const style2 = this.getStyle();
      style2.fill = "#FFEB3B";
      this.animatedText2 = new AnimatedText_default("Press any key to start the game!", style2, {
        autoStart: false,
        animations: [
          new AnimatedText_exports.FadeTextAnimation({
            frame: 60,
            easing: "easeInQuad",
            defaultState: "out"
          }),
          new AnimatedText_exports.MovingTextAnimation({
            decalY: 60,
            frame: 120,
            easing: "easeOutQuad"
          })
        ]
      });
      this.animatedText2.position.set(width / 8, height / 8 + 15);
      this.animatedText2.gameObject.anchor.set(0.5);
      this.animatedText.linkTo(this.animatedText2);
      this.addChild(this.animatedText);
      this.addChild(this.animatedText2);
    }
    update() {
      super.update();
      this.animatedText.update();
      this.animatedText2.update();
    }
  };
  var TextScene_default = TextScene;
  scene_class_default.define("text", TextScene);

  // assets/assets.json
  var assets_default = "./assets-7FVE44YS.json";

  // assets/scripts/main.js
  var PIXI22 = require_pixi();
  window.PIXI = PIXI22;
  PIXI22.settings.SCALE_MODE = PIXI22.SCALE_MODES.NEAREST;
  PIXI22.settings.RESOLUTION = 2;
  PIXI22.settings.PRECISION_FRAGMENT = "highp";
  PIXI22.settings.SORTABLE_CHILDREN = true;
  require_pixi_layers();
  async function main() {
    const gameState = new state_class_default("gameState", {
      player: {
        name: "Thomas",
        currentHp: 1,
        maxHp: 15
      }
    });
    const game2 = new engine_class_default({defaultScene: DefaultScene_default, state: gameState}).loadAssetFromFile(assets_default).init();
    game2.on("awake", () => {
      loadHUD("test_hud");
      const layer = new PIXI22.display.Layer();
      console.log(layer);
    });
  }
  main().catch(console.error);
})();
//# sourceMappingURL=main.js.map
